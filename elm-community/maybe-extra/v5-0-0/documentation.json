[{"name":"Maybe.Extra","comment":" Convenience functions for Maybe.\n\n\n# Common helpers\n\n@docs join, isNothing, isJust, unwrap, unpack, filter\n\n\n# Applicative functions\n\n@docs andMap, next, prev\n\n\n# Alternatives\n\n@docs or, orLazy, orElseLazy, orElse\n\n\n# List and array functions\n\n@docs toList, toArray, traverse, combine, traverseArray, combineArray, values\n\n","unions":[],"aliases":[],"values":[{"name":"andMap","comment":" Apply the function that is inside `Maybe` to a value that is inside `Maybe`. Return the result inside `Maybe`. If one of the `Maybe` arguments is `Nothing`, return `Nothing`.\n\n    Just ((+) 2) |> andMap (Just 3) == Just 5\n\n    Nothing |> andMap (Just 3) == Nothing\n\n    Just ((+) 2) |> andMap Nothing == Nothing\n\nAdvanced functional programmers will recognize this as the implementation of `<*>` for `Maybe`s from the `Applicative` typeclass.\n\n","type":"Maybe.Maybe a -> Maybe.Maybe (a -> b) -> Maybe.Maybe b"},{"name":"combine","comment":" Take a list of `Maybe`s and return a `Maybe` with a list of values. `combine == traverse identity`.\n\n    combine [] == Just []\n\n    combine [ Just 1, Just 2, Just 3 ] == Just [ 1, 2, 3 ]\n\n    combine [ Just 1, Nothing, Just 3 ] == Nothing\n\n","type":"List.List (Maybe.Maybe a) -> Maybe.Maybe (List.List a)"},{"name":"combineArray","comment":" ","type":"Array.Array (Maybe.Maybe a) -> Maybe.Maybe (Array.Array a)"},{"name":"filter","comment":" Take a `Maybe` and a predicate function and return a `Maybe` with the original value when a predicate matches.\n\n    filter (\\v -> v == 1) (Just 1) == Just 1\n\n    filter (\\v -> v == 2) (Just 1) == Nothing\n\n","type":"(a -> Basics.Bool) -> Maybe.Maybe a -> Maybe.Maybe a"},{"name":"isJust","comment":" Conveniently check if a `Maybe` matches `Just _`.\n\n    isJust (Just 42) == True\n\n    isJust (Just []) == True\n\n    isJust Nothing == False\n\n","type":"Maybe.Maybe a -> Basics.Bool"},{"name":"isNothing","comment":" Conveniently check if a `Maybe` matches `Nothing`.\n\n    isNothing (Just 42) == False\n\n    isNothing (Just []) == False\n\n    isNothing Nothing == True\n\n","type":"Maybe.Maybe a -> Basics.Bool"},{"name":"join","comment":" Flattens nested `Maybe`s\n\n    join (Just (Just 1)) == Just 1\n\n    join (Just Nothing) == Nothing\n\n    join Nothing == Nothing\n\n","type":"Maybe.Maybe (Maybe.Maybe a) -> Maybe.Maybe a"},{"name":"next","comment":" Take two `Maybe` values. If the first one equals `Nothing`, return `Nothing`. Otherwise return the second value.\n\n    next (Just 1) (Just 2) == Just 2\n\n    next Nothing (Just 2) == Nothing\n\n    next (Just 1) Nothing == Nothing\n\nAdvanced functional programmers will recognize this as the implementation of `*>` for `Maybe`s from the `Applicative` typeclass.\n\n","type":"Maybe.Maybe a -> Maybe.Maybe b -> Maybe.Maybe b"},{"name":"or","comment":" Like the boolean `||` this will return the first value that is\npositive (`Just`). However, unlike with `||`, both values will be\ncomputed anyway (there is no short-circuiting).\n\n    or (Just 4) (Just 5) == Just 4\n\n    or (Just 4) Nothing == Just 4\n\n    or Nothing (Just 5) == Just 5\n\n    or Nothing Nothing == Nothing\n\nAdvanced functional programmers will recognize this as the\nimplementation of `mplus` for `Maybe`s from the `MonadPlus` type\nclass.\n\n","type":"Maybe.Maybe a -> Maybe.Maybe a -> Maybe.Maybe a"},{"name":"orElse","comment":" Strict version of `orElseLazy` (and at the same time,\npiping-friendly version of `or`).\n\n    orElse (Just 4) (Just 5) == Just 5 -- crucial difference from `or`\n\n    orElse (Just 4) Nothing == Just 4\n\n    orElse Nothing (Just 5) == Just 5\n\n    orElse Nothing Nothing == Nothing\n\nAlso:\n\n    List.head []\n        |> orElse (List.head [ 4 ])\n\n","type":"Maybe.Maybe a -> Maybe.Maybe a -> Maybe.Maybe a"},{"name":"orElseLazy","comment":" Piping-friendly version of `orLazy`. The first argument will only\nbe evaluated if the second argument is `Nothing`. Example use:\n\n    List.head []\n        |> orElseLazy (\\() -> List.head [ 4 ])\n\n","type":"(() -> Maybe.Maybe a) -> Maybe.Maybe a -> Maybe.Maybe a"},{"name":"orLazy","comment":" Non-strict version of `or`. The second argument will only be\nevaluated if the first argument is `Nothing`.\n","type":"Maybe.Maybe a -> (() -> Maybe.Maybe a) -> Maybe.Maybe a"},{"name":"prev","comment":" Take two `Maybe` values. If the second one equals `Nothing`, return `Nothing`. Otherwise return the first value.\n\n    prev (Just 1) (Just 2) == Just 1\n\n    prev Nothing (Just 2) == Nothing\n\n    prev (Just 1) Nothing == Nothing\n\nAdvanced functional programmers will recognize this as the implementation of `<*` for `Maybe`s from the `Applicative` typeclass.\n\n","type":"Maybe.Maybe a -> Maybe.Maybe b -> Maybe.Maybe a"},{"name":"toArray","comment":" Return an empty array on `Nothing` or a list with one element, where the element is the value of `Just`.\n\n    toArray Nothing == Array.fromList []\n\n    toArray (Just 1) == Array.fromList [ 1 ]\n\n","type":"Maybe.Maybe a -> Array.Array a"},{"name":"toList","comment":" Return an empty list on `Nothing` or a list with one element, where the element is the value of `Just`.\n\n    toList Nothing == []\n\n    toList (Just 1) == [ 1 ]\n\n","type":"Maybe.Maybe a -> List.List a"},{"name":"traverse","comment":" Take a function that returns `Maybe` value and a list. Map a function over each element of the list. Collect the result in the list within `Maybe`.\n\n    traverse (\\x -> Just (x * 10)) [ 1, 2, 3, 4, 5 ] == Just [ 10, 20, 30, 40, 50 ]\n\n","type":"(a -> Maybe.Maybe b) -> List.List a -> Maybe.Maybe (List.List b)"},{"name":"traverseArray","comment":" ","type":"(a -> Maybe.Maybe b) -> Array.Array a -> Maybe.Maybe (Array.Array b)"},{"name":"unpack","comment":" A version of `unwrap` that is non-strict in the default value (by\nhaving it passed in a thunk).\n","type":"(() -> b) -> (a -> b) -> Maybe.Maybe a -> b"},{"name":"unwrap","comment":" Take a default value, a function and a `Maybe`.\nReturn the default value if the `Maybe` is `Nothing`.\nIf the `Maybe` is `Just a`, apply the function on `a` and return the `b`.\nThat is, `unwrap d f` is equivalent to `Maybe.map f >> Maybe.withDefault d`.\n","type":"b -> (a -> b) -> Maybe.Maybe a -> b"},{"name":"values","comment":" Convert a list of `Maybe a` to a list of `a` only for the values different\nfrom `Nothing`.\n\n    values [ Just 1, Nothing, Just 2 ] == [ 1, 2 ]\n\n","type":"List.List (Maybe.Maybe a) -> List.List a"}],"binops":[]}]