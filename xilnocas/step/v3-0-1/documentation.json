[{"name":"Step","comment":"\n@docs Step, map, stay, orElse, run, to, withCmd, mapMsg, exit, mapExit, onExit, asUpdateFunction, foldSteps, withAttempt, fromUpdate, fromMaybe\n","unions":[{"name":"Step","comment":" Step\n\nA `Step s msg o` describes one step of an interaction. Here's a few things about the interactions we're talking about her\n\n  - Interactions can involve the end user of your app, external servers, javascript: anything you might need to coordinate with in an Elm app\n  - Interactions can be in one of a finite set of _states_. The states are represented by the type `s`\n  - Interactions change state in response to _messages_, actions from the outside world. The messages are represented by the type `msg`\n  - When responding to a message, the state of the interaction might change, and `Cmd`s may be fired, potentially producing more messages.\n  - Interactions might go on indefinitely, or end. If they end, they result in a final value of type `o`. This might seem a little weird, but it has some nice properties\n\n`Step s msg o` is inteneded to be the return value of an update function. It encodes a bunch of common update function patterns, uniting them under a simple mental model, that simultaneously reduces boilerplate and eases composition.\n\n","args":["s","msg","o"],"cases":[]}],"aliases":[],"values":[{"name":"asUpdateFunction","comment":" turn an update function that returns a `Step` to a normal Elm Architecture update function\n\nuses `run` internally to default with the provided model in case of a `stay`\n\n","type":"(msg -> model -> Step.Step model msg Basics.Never) -> msg -> model -> ( model, Platform.Cmd.Cmd msg )"},{"name":"exit","comment":" End the interaction by returning a value of type `o`\n","type":"o -> Step.Step s msg o"},{"name":"foldSteps","comment":" starting from an initial state, fold an update function over a list of messages\n","type":"(msg -> model -> Step.Step model msg o) -> Step.Step model msg o -> List.List msg -> Step.Step model msg o"},{"name":"fromMaybe","comment":" Step to the state denoted by the `a` in the `Just` case, and stay otherwise\n","type":"Maybe.Maybe a -> Step.Step a msg o"},{"name":"fromUpdate","comment":" Build a step from a normal elm update tuple\n","type":"( s, Platform.Cmd.Cmd msg ) -> Step.Step s msg o"},{"name":"map","comment":" Apply a function to the state inside a step, if it's there\n\nMost useful in building a bigger step out of a sub-step you happen to have lying around\n\n","type":"(a -> b) -> Step.Step a msg o -> Step.Step b msg o"},{"name":"mapExit","comment":" Map over the output of an interaction, if we've reached the end\n","type":"(o -> p) -> Step.Step s msg o -> Step.Step s msg p"},{"name":"mapMsg","comment":" Apply a function to any `msg`s conteined in the step\n\nAlso used for building larger interaction steps out of smaller ones\n\n","type":"(a -> b) -> Step.Step state a o -> Step.Step state b o"},{"name":"onExit","comment":" Choose a step based on the result of another interaction\n\nYou can use this in combination with `map` and `mapMsg` to glue the end of one interaction to the beginning of another.\n\n","type":"(o -> Step.Step s msg p) -> Step.Step s msg o -> Step.Step s msg p"},{"name":"orElse","comment":" Run the first suceeding step, with priority given to the second argument\n\nIntended to be used pipeline style\n\n    Step.to { loading = True } |> Step.orElse (Step.to { loading = False }) == Step.to { loading = True }\n\n    Step.noop |> Step.orElse Step.to { loading = True } == Step.to { loading = True }\n\n","type":"Step.Step s msg o -> Step.Step s msg o -> Step.Step s msg o"},{"name":"run","comment":" Turn a Step into the usual TEA update tuple\n\nIt must be a step in an interaction that continues forever. We know it is if the type variable `o` isn't a specifc type, and can thus be chosen to be `Never`\n\n","type":"Step.Step state msg Basics.Never -> Maybe.Maybe ( state, Platform.Cmd.Cmd msg )"},{"name":"stay","comment":" Keep the interaction in the state it was in.\n\nNOTE: This will prevent any commands from being returned\n\n    Step.stay == (Step.stay |> Step.withCmd myHttpCall)\n\nIf you want to stay in the same state, but run some commands, use `Step.to` explicitly\n\n    Step.to MySameState |> Step.withCmd myHttpCall\n\n","type":"Step.Step s msg o"},{"name":"to","comment":" Step to a new state in the interaction\n","type":"s -> Step.Step s msg o"},{"name":"withAttempt","comment":" A helper for building steps out of tasks\n","type":"(Result.Result x a -> msg) -> Task.Task x a -> Step.Step s msg o -> Step.Step s msg o"},{"name":"withCmd","comment":" If we're stepping `to` a new state, add an action to fire off\n","type":"Platform.Cmd.Cmd msg -> Step.Step s msg o -> Step.Step s msg o"}],"binops":[]}]