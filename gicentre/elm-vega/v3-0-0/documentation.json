[
  {
    "name": "Vega",
    "comment": " Create full Vega specifications in Elm. The module can generate JSON specs\nthat may be passed to the Vega runtime library to activate the visualization.\n\n\n# Creating A Vega Specification\n\n@docs toVega\n@docs combineSpecs\n\n@docs VProperty\n\n\n# Passing Values into a Vega Specification\n\nData types such as numbers, strings and Booleans are generated by functions. For\nexample, _expressions_ generate new values based on operations applied to\nexisting ones; _fields_ reference a column of a data table; _signals_\nrespond dynamically to data or interaction.\n\n\n## Numbers\n\n@docs num\n@docs nums\n@docs numSignal\n@docs numSignals\n@docs numExpr\n@docs numList\n@docs numNull\n\n\n## Strings\n\n@docs str\n@docs strs\n@docs strSignal\n@docs strSignals\n@docs strExpr\n@docs strNull\n\n\n## Booleans\n\n@docs true\n@docs false\n@docs boos\n@docs booSignal\n@docs booSignals\n@docs booExpr\n\n\n## Generic Values\n\nUsed by functions that expect values of mixed types.\n\n@docs vNum\n@docs vNums\n@docs vStr\n@docs vStrs\n@docs vTrue\n@docs vFalse\n@docs vBoos\n@docs vSignal\n@docs vField\n@docs vColor\n@docs vBand\n@docs vObject\n@docs keyValue\n@docs vValues\n@docs ifElse\n@docs vNull\n@docs vMultiply\n@docs vExponent\n@docs vOffset\n@docs vRound\n@docs vScale\n@docs vScaleField\n\n\n## Indirect References\n\nSee the\n[Vega field value documentation](https://vega.github.io/vega/docs/types/#FieldValue).\n\n@docs field\n@docs fSignal\n@docs fExpr\n@docs fDatum\n@docs fGroup\n@docs fParent\n@docs expr\n@docs exField\n\n\n## Thematic Data Types\n\n@docs TimeUnit\n@docs timeUnitSignal\n@docs cHCL\n@docs cHSL\n@docs cLAB\n@docs cRGB\n\n\n# Creating an Input Data Specification\n\nSee the [Vega data](https://vega.github.io/vega/docs/data) and the\n[Vega data reference](https://vega.github.io/vega/docs/scales/#dataref) documentation.\n\n@docs dataSource\n@docs data\n\n@docs dataFromColumns\n@docs dataColumn\n\n@docs dataFromRows\n@docs dataRow\n@docs DataProperty\n\n@docs daUrl\n@docs daFormat\n@docs daSource\n@docs daSources\n@docs daValue\n@docs daOn\n\n@docs daDataset\n@docs daField\n@docs daFields\n@docs daValues\n@docs daSignal\n@docs daReferences\n\n\n## Data Sorting\n\nSee the\n[Vega sort documentation](https://vega.github.io/vega/docs/scales/#sort).\n\n@docs daSort\n@docs SortProperty\n@docs sortPropertySignal\n@docs soOp\n@docs soByField\n\n@docs Order\n@docs orderSignal\n\n\n## Data Parsing and Formatting\n\n@docs FormatProperty\n@docs dsv\n@docs jsonProperty\n@docs topojsonMesh\n@docs topojsonFeature\n@docs formatPropertySignal\n\n@docs DataType\n@docs parse\n@docs foDate\n@docs foUtc\n\n\n# Transforming Data\n\nApplying a transform to a data stream can filter or generate new fields in the\nstream, or derive new data streams. Pipe (`|>`) the stream into the `transform`\nfunction and specify the transform to apply via one or more of these functions.\nSee the [Vega transform documentation](https://vega.github.io/vega/docs/transforms).\n\n@docs transform\n\n\n## Basic Transforms\n\n\n### Aggregation\n\nSee the\n[Vega aggregate documentation](https://vega.github.io/vega/docs/transforms/aggregate/)\n\n@docs trAggregate\n@docs agGroupBy\n@docs agFields\n@docs agOps\n@docs agAs\n@docs agCross\n@docs agDrop\n@docs agKey\n\n@docs Operation\n@docs operationSignal\n\n\n### Join Aggregation\n\nSee the\n[Vega join aggregation documentation](https://vega.github.io/vega/docs/transforms/joinaggregate/).\n\n@docs trJoinAggregate\n@docs jaGroupBy\n@docs jaFields\n@docs jaOps\n@docs jaAs\n\n\n### Binning\n\nSee the\n[Vega bin documentation](https://vega.github.io/vega/docs/transforms/bin/)\n\n@docs trBin\n@docs bnAnchor\n@docs bnMaxBins\n@docs bnBase\n@docs bnStep\n@docs bnSteps\n@docs bnMinStep\n@docs bnDivide\n@docs bnNice\n@docs bnSignal\n@docs bnAs\n\n\n### Collection\n\nSee the\n[Vega collect documentation](https://vega.github.io/vega/docs/transforms/collect/).\n\n@docs trCollect\n\n\n### Text Pattern Counting\n\nSee the\n[Vega count pattern documentation](https://vega.github.io/vega/docs/transforms/countpattern/).\n\n@docs trCountPattern\n@docs cpPattern\n@docs cpCase\n@docs Case\n@docs cpStopwords\n@docs cpAs\n\n\n### Cross Product\n\nSee the\n[Vega cross-product documentation](https://vega.github.io/vega/docs/transforms/cross/).\n\n@docs trCross\n@docs crFilter\n@docs crAs\n\n\n### Probability Density Function Calculation\n\nSee the\n[Vega density documentation](https://vega.github.io/vega/docs/transforms/density/).\n\n@docs trDensity\n@docs dnExtent\n@docs dnMethod\n@docs DensityFunction\n@docs densityFunctionSignal\n@docs dnSteps\n@docs dnAs\n\n@docs diNormal\n@docs diUniform\n@docs diKde\n@docs diMixture\n\n\n### Range calculation\n\nSee the\n[Vega extent documentation](https://vega.github.io/vega/docs/transforms/extent/).\n\n@docs trExtent\n@docs trExtentAsSignal\n\n\n### Filtering\n\nSee the Vega [filter](https://vega.github.io/vega/docs/transforms/filter/) and\nand [crossfilter](https://vega.github.io/vega/docs/transforms/crossfilter/)\ndocumentation.\n\n@docs trFilter\n@docs trCrossFilter\n@docs trCrossFilterAsSignal\n@docs trResolveFilter\n\n\n### Flattening\n\n@docs trFlatten\n@docs trFlattenAs\n\n\n### Folding and Pivoting\n\nSee the Vega [fold](https://vega.github.io/vega/docs/transforms/fold/) and\n[pivot](https://vega.github.io/vega/docs/transforms/pivot/) documentation.\n\n@docs trFold\n@docs trFoldAs\n@docs trPivot\n@docs piGroupBy\n@docs piLimit\n@docs piOp\n\n\n### Deriving New Fields\n\nSee the Vega [formula](https://vega.github.io/vega/docs/transforms/formula),\n[lookup](https://vega.github.io/vega/docs/transforms/lookup/),\n[identifier](https://vega.github.io/vega/docs/transforms/identifier/),\n[project](https://vega.github.io/vega/docs/transforms/project/) and\n[window](https://vega.github.io/vega/docs/transforms/window/) documentation.\n\n@docs trFormula\n@docs trFormulaInitOnly\n\n@docs trLookup\n@docs luAs\n@docs luValues\n@docs luDefault\n\n@docs trIdentifier\n@docs trProject\n\n@docs trWindow\n@docs wnAggOperation\n@docs wnOperation\n@docs wnOperationOn\n@docs WOperation\n@docs wOperationSignal\n@docs wnSort\n@docs wnGroupBy\n@docs wnFrame\n@docs wnIgnorePeers\n\n\n### Handling Missing Values\n\nSee the\n[Vega impute documentation](https://vega.github.io/vega/docs/transforms/impute/).\n\n@docs trImpute\n@docs imKeyVals\n@docs imMethod\n@docs ImputeMethod\n@docs imGroupBy\n@docs imValue\n\n\n### Sampling\n\nSee the\n[Vega sample documentation](https://vega.github.io/vega/docs/transforms/sample/).\n\n@docs trSample\n\n\n### Data Generation\n\nSee the\n[Vega sequence documentation](https://vega.github.io/vega/docs/transforms/sequence/).\n\n@docs trSequence\n@docs trSequenceAs\n\n\n## Geographic Transforms\n\n\n### Contouring\n\nSee the\n[Vega contour documentation](https://vega.github.io/vega/docs/transforms/contour/)\n\n@docs trContour\n@docs cnValues\n@docs cnX\n@docs cnY\n@docs cnCellSize\n@docs cnBandwidth\n@docs cnSmooth\n@docs cnThresholds\n@docs cnCount\n@docs cnNice\n\n\n### GeoJSON transformation\n\nSee the Vega\n[geoJSON](https://vega.github.io/vega/docs/transforms/geojson/),\n[geoPoint](https://vega.github.io/vega/docs/transforms/geopoint/),\n[geoshape](https://vega.github.io/vega/docs/transforms/geoshape/) and\n[geopath](https://vega.github.io/vega/docs/transforms/geopath/) documentation.\n\n@docs trGeoShape\n@docs trGeoPath\n@docs gpField\n@docs gpPointRadius\n@docs gpAs\n@docs trGeoJson\n@docs gjFields\n@docs gjFeature\n@docs gjSignal\n\n@docs trGeoPoint\n@docs trGeoPointAs\n\n\n### Graticule Generation\n\nSee the\n[Vega graticule documentation](https://vega.github.io/vega/docs/transforms/graticule/).\n\n@docs trGraticule\n@docs grExtent\n@docs grExtentMajor\n@docs grExtentMinor\n@docs grStep\n@docs grStepMajor\n@docs grStepMinor\n@docs grField\n@docs grPrecision\n\n\n## Layout Transforms\n\n\n### Link Paths\n\nSee the\n[Vega link path documentation](https://vega.github.io/vega/docs/transforms/linkpath/).\n\n@docs trLinkPath\n@docs lpSourceX\n@docs lpSourceY\n@docs lpTargetX\n@docs lpTargetY\n@docs lpOrient\n@docs lpShape\n@docs lpAs\n@docs LinkShape\n@docs linkShapeSignal\n\n\n### Angular Layouts\n\nSee the\n[Vega pie documentation](https://vega.github.io/vega/docs/transforms/pie/).\n\n@docs trPie\n@docs piField\n@docs piStartAngle\n@docs piEndAngle\n@docs piSort\n@docs piAs\n\n\n### Stacked Layouts\n\nSee the\n[Vega stack documentation](https://vega.github.io/vega/docs/transforms/stack/).\n\n@docs trStack\n@docs stField\n@docs stGroupBy\n@docs stSort\n@docs stOffset\n@docs stAs\n@docs StackOffset\n@docs stackOffsetSignal\n\n\n### Force-Generated Layouts\n\nSee the\n[Vega force documentation](https://vega.github.io/vega/docs/transforms/force/).\n\n@docs trForce\n\n@docs fsStatic\n@docs fsRestart\n@docs fsIterations\n@docs fsAlpha\n@docs fsAlphaMin\n@docs fsAlphaTarget\n@docs fsVelocityDecay\n@docs fsForces\n@docs fsAs\n\n@docs foCenter\n@docs foCollide\n@docs foNBody\n@docs foLink\n@docs foX\n@docs foY\n\n@docs fpStrength\n@docs fpDistance\n@docs fpIterations\n@docs fpTheta\n@docs fpDistanceMin\n@docs fpDistanceMax\n@docs fpId\n\n\n### Voronoi Diagram\n\nSee the\n[Vega Voronoi documentation](https://vega.github.io/vega/docs/transforms/voronoi/).\n\n@docs trVoronoi\n@docs voSize\n@docs voExtent\n@docs voAs\n\n\n### Word Cloud layout\n\nSee the\n[Vega wordcloud documentation](https://vega.github.io/vega/docs/transforms/wordcloud/).\n\n@docs trWordcloud\n@docs wcFont\n@docs wcFontStyle\n@docs wcFontWeight\n@docs wcFontSize\n@docs wcFontSizeRange\n@docs wcPadding\n@docs wcRotate\n@docs wcText\n@docs wcSize\n@docs wcSpiral\n@docs Spiral\n@docs spiralSignal\n@docs wcAs\n\n\n## Hierarchy Transforms\n\nSee the Vega\n[nest](https://vega.github.io/vega/docs/transforms/nest/),\n[stratify](https://vega.github.io/vega/docs/transforms/stratify/),\n[pack](https://vega.github.io/vega/docs/transforms/pack/),\n[partition](https://vega.github.io/vega/docs/transforms/partition/),\n[tree](https://vega.github.io/vega/docs/transforms/tree/),\n[tree links](https://vega.github.io/vega/docs/transforms/treelinks/) and\n[treemap](https://vega.github.io/vega/docs/transforms/treemap/) documentation.\n\n@docs trNest\n@docs trStratify\n\n@docs trPack\n@docs paField\n@docs paSort\n@docs paSize\n@docs paRadius\n@docs paPadding\n@docs paAs\n\n@docs trPartition\n@docs ptField\n@docs ptSort\n@docs ptPadding\n@docs ptRound\n@docs ptSize\n@docs ptAs\n\n@docs trTree\n@docs teField\n@docs teSort\n@docs teMethod\n@docs TreeMethod\n@docs treeMethodSignal\n@docs teSize\n@docs teNodeSize\n@docs teAs\n\n@docs trTreeLinks\n\n@docs trTreemap\n@docs tmField\n@docs tmSort\n@docs tmMethod\n@docs TreemapMethod\n@docs treemapMethodSignal\n@docs tmPadding\n@docs tmPaddingInner\n@docs tmPaddingOuter\n@docs tmPaddingTop\n@docs tmPaddingLeft\n@docs tmPaddingBottom\n@docs tmPaddingRight\n@docs tmRatio\n@docs tmRound\n@docs tmSize\n@docs tmAs\n\n\n# Signals, Triggers and Interaction Events\n\nSee the [Vega signal documentation](https://vega.github.io/vega/docs/signals)\n\n\n## Signals\n\n@docs signals\n@docs signal\n@docs siName\n@docs siValue\n@docs siBind\n@docs siDescription\n@docs siOn\n@docs siUpdate\n@docs siReact\n@docs siPushOuter\n\n\n## User Interface Inputs\n\nSee the [Vega signal binding documentation](https://vega.github.io/vega/docs/signals/#bind).\n\n@docs iCheckbox\n@docs iText\n@docs iNumber\n@docs iDate\n@docs iDateTimeLocal\n@docs iTime\n@docs iMonth\n@docs iWeek\n@docs iRadio\n@docs iRange\n@docs iSelect\n@docs iTel\n@docs iColor\n\n@docs inDebounce\n@docs inElement\n@docs inOptions\n@docs inMin\n@docs inMax\n@docs inStep\n@docs inPlaceholder\n@docs inAutocomplete\n\n\n## Event Handling\n\nSee the Vega [event stream](https://vega.github.io/vega/docs/event-streams)\nand [event handler](https://vega.github.io/vega/docs/signals/#handlers) documentation.\n\n@docs evHandler\n@docs evUpdate\n@docs evEncode\n@docs evForce\n\n@docs esObject\n@docs esSignal\n@docs esMerge\n@docs esStream\n@docs esSelector\n@docs esSource\n@docs esType\n@docs esBetween\n@docs esConsume\n@docs esFilter\n@docs esDebounce\n@docs esMarkName\n@docs esMark\n@docs esThrottle\n\n@docs evStreamSelector\n@docs EventSource\n\n@docs esDom\n@docs EventType\n\n\n## Triggers\n\nSee the [Vega trigger documentation](https://vega.github.io/vega/docs/triggers).\n\n@docs on\n@docs trigger\n@docs tgInsert\n@docs tgRemove\n@docs tgRemoveAll\n@docs tgToggle\n@docs tgModifyValues\n\n\n# Specifying Scales\n\nSee the [Vega scale documentation](https://vega.github.io/vega/docs/scales).\n\n@docs scales\n@docs scale\n@docs scReverse\n@docs scRound\n@docs scClamp\n@docs scPadding\n@docs scNice\n@docs scZero\n@docs scExponent\n@docs scBase\n@docs scAlign\n@docs scDomainImplicit\n@docs scPaddingInner\n@docs scPaddingOuter\n@docs scRangeStep\n\n@docs ScaleNice\n@docs scaleNiceSignal\n@docs nInterval\n@docs nTickCount\n\n\n## Scale Types\n\n@docs scType\n@docs Scale\n@docs scaleSignal\n@docs scCustom\n\n\n## Scale Domains\n\nThe extent scaling input data.\n\n@docs scDomain\n@docs scDomainMax\n@docs scDomainMin\n@docs scDomainMid\n@docs scDomainRaw\n@docs doNums\n@docs doStrs\n@docs doSignal\n@docs doSignals\n@docs doData\n\n\n## Scale Ranges\n\nThe extent of scaled values after transformation.\n\n@docs scRange\n@docs ScaleRange\n@docs scaleRangeSignal\n@docs raNums\n@docs raStrs\n@docs raValues\n@docs raSignal\n@docs raScheme\n@docs raData\n@docs raStep\n@docs raCustomDefault\n\n\n## Color Scales\n\nSee the Vega [Vega color scale](https://vega.github.io/vega/docs/scales/#properties)\nand [color scheme](https://vega.github.io/vega/docs/schemes/) documentation.\n\n@docs csScheme\n@docs csCount\n@docs csExtent\n\n@docs scInterpolate\n@docs CInterpolate\n@docs cubeHelix\n@docs cubeHelixLong\n@docs hclLong\n@docs hslLong\n@docs rgb\n\n\n# Specifying Projections\n\nSee the\n[Vega map projection documentation](https://vega.github.io/vega/docs/projections).\n\n@docs projections\n@docs projection\n@docs Projection\n@docs projectionSignal\n@docs projectionValue\n@docs prCustom\n@docs prType\n@docs prClipAngle\n@docs prClipExtent\n@docs prScale\n@docs prTranslate\n@docs prCenter\n@docs prRotate\n@docs prPointRadius\n@docs prPrecision\n@docs prCoefficient\n@docs prDistance\n@docs prFraction\n@docs prLobes\n@docs prParallel\n@docs prRadius\n@docs prRatio\n@docs prSpacing\n@docs prTilt\n@docs prFit\n@docs feName\n@docs featureSignal\n@docs prExtent\n@docs prSize\n\n\n# Specifying Axes\n\nSee the [Vega axis documentation](https://vega.github.io/vega/docs/axes/).\n\n@docs axes\n@docs axis\n@docs axBandPosition\n@docs axDomain\n@docs axDomainColor\n@docs axDomainOpacity\n@docs axDomainWidth\n@docs axEncode\n@docs axFormat\n@docs axGrid\n@docs axGridColor\n@docs axGridOpacity\n@docs axGridDash\n@docs axGridScale\n@docs axGridWidth\n@docs axLabels\n@docs axLabelBound\n@docs axLabelAlign\n@docs axLabelBaseline\n@docs axLabelAngle\n@docs axLabelColor\n@docs axLabelOpacity\n@docs axLabelFont\n@docs axLabelFontSize\n@docs axLabelFontWeight\n@docs axLabelFlush\n@docs axLabelFlushOffset\n@docs axLabelLimit\n@docs axLabelPadding\n@docs axLabelOverlap\n@docs axMinExtent\n@docs axMaxExtent\n@docs axOffset\n@docs axPosition\n@docs axTicks\n@docs axTickCount\n@docs axTemporalTickCount\n@docs axTickColor\n@docs axTickOpacity\n@docs axTickExtra\n@docs axTickOffset\n@docs axTickRound\n@docs axTickWidth\n@docs axTickSize\n@docs axTitle\n@docs axTitleAlign\n@docs axTitleAngle\n@docs axTitleBaseline\n@docs axTitleColor\n@docs axTitleOpacity\n@docs axTitleFont\n@docs axTitleFontSize\n@docs axTitleFontWeight\n@docs axTitleLimit\n@docs axTitlePadding\n@docs axTitleX\n@docs axTitleY\n@docs axValues\n@docs axZIndex\n@docs AxisElement\n@docs Side\n@docs sideSignal\n@docs OverlapStrategy\n@docs overlapStrategySignal\n\n\n# Specifying Legends\n\nSee the\n[Vega legend documentation](https://vega.github.io/vega/docs/legends/)\n\n@docs legends\n@docs legend\n@docs leType\n@docs leDirection\n@docs leOrient\n@docs leFill\n@docs leOpacity\n@docs leShape\n@docs leSize\n@docs leStroke\n@docs leStrokeDash\n@docs leEncode\n@docs leFormat\n@docs leGridAlign\n@docs leClipHeight\n@docs leColumns\n@docs leColumnPadding\n@docs leRowPadding\n@docs leCornerRadius\n@docs leFillColor\n@docs leOffset\n@docs lePadding\n@docs leStrokeColor\n@docs leStrokeWidth\n@docs leGradientOpacity\n@docs leGradientLabelLimit\n@docs leGradientLabelOffset\n@docs leGradientLength\n@docs leGradientThickness\n@docs leGradientStrokeColor\n@docs leGradientStrokeWidth\n@docs leLabelAlign\n@docs leLabelBaseline\n@docs leLabelColor\n@docs leLabelFont\n@docs leLabelFontSize\n@docs leLabelFontWeight\n@docs leLabelLimit\n@docs leLabelOpacity\n@docs leLabelOffset\n@docs leLabelOverlap\n@docs leSymbolFillColor\n@docs leSymbolBaseFillColor\n@docs leSymbolBaseStrokeColor\n@docs leSymbolDirection\n@docs leSymbolOffset\n@docs leSymbolSize\n@docs leSymbolStrokeColor\n@docs leSymbolStrokeWidth\n@docs leSymbolOpacity\n@docs leSymbolType\n@docs leTickCount\n@docs leTemporalTickCount\n@docs leTitle\n@docs leTitleAlign\n@docs leTitleBaseline\n@docs leTitleColor\n@docs leTitleOpacity\n@docs leTitleFont\n@docs leTitleFontSize\n@docs leTitleFontWeight\n@docs leTitleLimit\n@docs leTitlePadding\n@docs leValues\n@docs leZIndex\n@docs LegendType\n@docs legendTypeSignal\n@docs LegendOrientation\n@docs legendOrientationSignal\n@docs enLegend\n@docs enTitle\n@docs enLabels\n@docs enSymbols\n@docs enGradient\n@docs enName\n@docs enInteractive\n\n\n# Specifying Titles\n\nSee the [Vega title documentation](https://vega.github.io/vega/docs/title/)\n\n@docs title\n@docs tiAnchor\n@docs tiAngle\n@docs Anchor\n@docs anchorSignal\n@docs tiAlign\n@docs tiBaseline\n@docs tiColor\n@docs tiEncode\n@docs tiFont\n@docs tiFontSize\n@docs tiFontWeight\n@docs tiFrame\n@docs TitleFrame\n@docs titleFrameSignal\n@docs tiInteractive\n@docs tiLimit\n@docs tiName\n@docs tiOffset\n@docs tiOrient\n@docs tiStyle\n@docs tiZIndex\n\n\n# Specifying Layout\n\nSee the [Vega layout documentation](https://vega.github.io/vega/docs/layout/).\n\n@docs layout\n@docs GridAlign\n@docs gridAlignSignal\n@docs grAlignRow\n@docs grAlignColumn\n@docs BoundsCalculation\n@docs bcSignal\n@docs loAlign\n@docs loBounds\n@docs loColumns\n@docs loPadding\n@docs loPaddingRC\n@docs loOffset\n@docs loOffsetRC\n@docs loHeaderBand\n@docs loHeaderBandRC\n@docs loFooterBand\n@docs loFooterBandRC\n@docs loTitleBand\n@docs loTitleBandRC\n\n\n# Specifying Marks\n\nSee the [Vega mark documentation](https://vega.github.io/vega/docs/marks).\n\n## Top-Level Marks\n\n@docs marks\n@docs mark\n@docs Mark\n@docs mClip\n@docs mDescription\n@docs mEncode\n@docs mFrom\n@docs mInteractive\n@docs mKey\n@docs mName\n@docs mOn\n@docs mSort\n@docs mTransform\n@docs mStyle\n@docs mGroup\n@docs mZIndex\n\n@docs clEnabled\n@docs clPath\n@docs clSphere\n@docs srData\n\n\n## Faceting\n\nSplit up a data source between group mark items.\n\n@docs srFacet\n@docs faField\n@docs faGroupBy\n@docs faAggregate\n\n\n## Lower-level Mark Properties\n\nSee the [Vega mark encoding documentation](https://vega.github.io/vega/docs/marks/#encode).\n\n@docs maX\n@docs maX2\n@docs maXC\n@docs maWidth\n@docs maY\n@docs maY2\n@docs maYC\n@docs maHeight\n@docs maOpacity\n@docs maFill\n@docs maFillOpacity\n@docs maStroke\n@docs transparent\n@docs black\n@docs white\n@docs maStrokeOpacity\n@docs maStrokeWidth\n@docs maStrokeCap\n@docs maStrokeDash\n@docs maStrokeDashOffset\n@docs maStrokeJoin\n@docs maStrokeMiterLimit\n@docs maCursor\n@docs maHRef\n@docs maTooltip\n@docs maZIndex\n@docs maAlign\n@docs maBaseline\n@docs maCornerRadius\n@docs maInterpolate\n@docs maTension\n@docs maDefined\n@docs maSize\n@docs maStartAngle\n@docs maEndAngle\n@docs maPadAngle\n@docs maInnerRadius\n@docs maOuterRadius\n@docs maOrient\n@docs maGroupClip\n@docs maUrl\n@docs maAspect\n@docs maPath\n@docs maShape\n@docs maSymbol\n@docs maAngle\n@docs maDir\n@docs maDx\n@docs maDy\n@docs maEllipsis\n@docs maFont\n@docs maFontSize\n@docs maFontWeight\n@docs maFontStyle\n@docs maLimit\n@docs maRadius\n@docs maText\n@docs maTheta\n@docs maCustom\n\n\n## Encoding\n\nSee the [Vega mark encoding documentation](https://vega.github.io/vega/docs/marks/#encode).\n\n@docs enEnter\n@docs enUpdate\n@docs enHover\n@docs enExit\n@docs enCustom\n@docs MarkInterpolation\n@docs markInterpolationValue\n@docs Orientation\n@docs orientationSignal\n@docs orientationValue\n@docs Cursor\n@docs cursorValue\n@docs HAlign\n@docs hAlignSignal\n@docs hLeft\n@docs hCenter\n@docs hRight\n@docs VAlign\n@docs vAlignSignal\n@docs vTop\n@docs vMiddle\n@docs vBottom\n@docs vAlphabetic\n@docs Symbol\n@docs symbolValue\n@docs symbolSignal\n@docs symPath\n@docs StrokeCap\n@docs strokeCapValue\n@docs strokeCapSignal\n@docs StrokeJoin\n@docs strokeJoinSignal\n@docs strokeJoinValue\n@docs textDirectionValue\n@docs TextDirection\n@docs textDirectionSignal\n\n\n# Configuring Visualization Appearance\n\nSee the\n[Vega configuration documentation](https://vega.github.io/vega/docs/config/).\n\n@docs config\n\n\n## View Configuration\n\n@docs cfAutosize\n@docs cfBackground\n@docs cfGroup\n\n\n## Event Configuration\n\n@docs cfEvents\n@docs EventFilter\n\n\n## Mark Configuration\n\n@docs cfMark\n@docs cfMarks\n\n\n## Style Configuration\n\n@docs cfStyle\n\n\n## Axis Configuration\n\n@docs cfAxis\n@docs AxisType\n\n\n## Legend Configuration\n\n@docs cfLegend\n\n\n## Title Configuration\n\n@docs cfTitle\n\n\n## Scale Range Configuration\n\n@docs cfScaleRange\n\n\n# Supplementary Properties\n\nSee the\n[Vega specification documentation](https://vega.github.io/vega/docs/specification/)\n\n@docs autosize\n@docs Autosize\n@docs autosizeSignal\n@docs height\n@docs padding\n@docs paddings\n@docs width\n@docs background\n@docs encode\n\n---\n\n\n# Type Reference\n\nTypes that are not specified directly, provided here for reference with links\nto the functions that generate them.\n\n@docs AggregateProperty\n@docs AxisProperty\n@docs Bind\n@docs BinProperty\n@docs Boo\n@docs Clip\n@docs ColorSchemeProperty\n@docs ColorValue\n@docs ConfigProperty\n@docs ContourProperty\n@docs CountPatternProperty\n@docs CrossProperty\n@docs Data\n@docs DataColumn\n@docs DataReference\n@docs DataRow\n@docs DataTable\n@docs DensityProperty\n@docs Distribution\n@docs EncodingProperty\n@docs EventHandler\n@docs EventStream\n@docs EventStreamProperty\n@docs Expr\n@docs Facet\n@docs Feature\n@docs Field\n@docs Force\n@docs ForceProperty\n@docs ForceSimulationProperty\n@docs GeoJsonProperty\n@docs GeoPathProperty\n@docs GraticuleProperty\n@docs ImputeProperty\n@docs InputProperty\n@docs JoinAggregateProperty\n@docs LayoutProperty\n@docs LegendEncoding\n@docs LegendProperty\n@docs LinkPathProperty\n@docs LookupProperty\n@docs MarkProperty\n@docs Num\n@docs PackProperty\n@docs PartitionProperty\n@docs PieProperty\n@docs PivotProperty\n@docs ProjectionProperty\n@docs ScaleDomain\n@docs ScaleProperty\n@docs SignalProperty\n@docs Source\n@docs Spec\n@docs StackProperty\n@docs Str\n@docs TitleProperty\n@docs TopMarkProperty\n@docs Transform\n@docs TreemapProperty\n@docs TreeProperty\n@docs Trigger\n@docs TriggerProperty\n@docs Value\n@docs VoronoiProperty\n@docs WindowOperation\n@docs WindowProperty\n@docs WordcloudProperty\n\n",
    "aliases": [
      {
        "name": "Data",
        "comment": " Convenience type annotation label for use with data generation functions.\nGenerated by [dataSource](#dataSource) but is also useful when creating your own\ndata generating functions. For example:\n\n    myData : Int -> Data\n    myData yr =\n        dataSource\n            [ data \"population\" [ daSource \"pop\" ]\n                |> transform [ trFilter (expr (\"datum.year == \" ++ toString yr)) ]\n            ]\n\n",
        "args": [],
        "type": "( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "DataColumn",
        "comment": " A single column of data. Generated when creating inline data with\n[dataColumn](#dataColumn).\n",
        "args": [],
        "type": "List Vega.LabelledSpec"
      },
      {
        "name": "DataRow",
        "comment": " A single row of data. Generated when creating inline data with\n[dataRow](#dataRow).\n",
        "args": [],
        "type": "Vega.Spec"
      },
      {
        "name": "DataTable",
        "comment": " A single table of data (collection of `dataColumn` specifications).\nGenerated by [data](#data), [dataFromColumns](#dataFromColumns),\n[dataFromRows](#dataFromRows), [on](#on) and [transform](#transform).\n",
        "args": [],
        "type": "List Vega.LabelledSpec"
      },
      {
        "name": "Spec",
        "comment": " A Vega specification. Specs can be (and usually are) nested.\nThey can range from a single Boolean value up to the entire Vega specification.\n",
        "args": [],
        "type": "Json.Encode.Value"
      },
      {
        "name": "Trigger",
        "comment": " Generated by [trigger](#trigger).\n",
        "args": [],
        "type": "Vega.Spec"
      }
    ],
    "types": [
      {
        "name": "AggregateProperty",
        "comment": " Generated by [agAs](#agAs),\n[agCross](#agCross), [agDrop](#agDrop), [agFields](#agFields),\n[agGroupBy](#agGroupBy), [agOps](#agOps) and [agKey](#agKey).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Anchor",
        "comment": " An anchor position, as used for example, in placing title text.\n",
        "args": [],
        "cases": [
          [
            "Start",
            []
          ],
          [
            "Middle",
            []
          ],
          [
            "End",
            []
          ]
        ]
      },
      {
        "name": "Autosize",
        "comment": " Auto-sizing characteristics of the visualization such as amount of padding,\nwhether it should fill the parent container etc.\n",
        "args": [],
        "cases": [
          [
            "AContent",
            []
          ],
          [
            "AFit",
            []
          ],
          [
            "AFitX",
            []
          ],
          [
            "AFitY",
            []
          ],
          [
            "ANone",
            []
          ],
          [
            "APad",
            []
          ],
          [
            "APadding",
            []
          ],
          [
            "AResize",
            []
          ]
        ]
      },
      {
        "name": "AxisElement",
        "comment": " Encodable axis element. Used for customising some part of an axis.\n",
        "args": [],
        "cases": [
          [
            "EAxis",
            []
          ],
          [
            "ETicks",
            []
          ],
          [
            "EGrid",
            []
          ],
          [
            "ELabels",
            []
          ],
          [
            "ETitle",
            []
          ],
          [
            "EDomain",
            []
          ]
        ]
      },
      {
        "name": "AxisProperty",
        "comment": " Generated by [axBandPosition](#axBandPosition), [axDomain](#axDomain),\n[axDomainColor](#axDomainColor), [axDomainOpacity](#axDomainOpacity),\n[axDomainWidth](#axDomainWidth), [axEncode](#axEncode), [axFormat](#axFormat),\n[axGrid](#axGrid), [axGridColor](#axGridColor), [axGridDash](#axGridDash),\n[axGridOpacity](#axGridOpacity), [axGridScale](#axGridScale), [axGridWidth](#axGridWidth),\n[axLabels](#axLabels), [axLabelAlign](#axLabelAlign), [axLabelBaseline](#axLabelBaseline),\n[axLabelBound](#axLabelBound), [axLabelColor](#axLabelColor), [axLabelFlush](#axLabelFlush),\n[axLabelFlushOffset](#axLabelFlushOffset), [axLabelFont](#axLabelFont), [axLabelFontSize](#axLabelFontSize)\n[axLabelFontWeight](#axLabelFontWeight), [axLabelLimit](#axLabelLimit), [axLabelOpacity](#axLabelOpacity)\n[axLabelOverlap](#axLabelOverlap), [axLabelPadding](#axLabelPadding), [axMaxExtent](#axMaxExtent),\n[axMinExtent](#axMinExtent), [axOffset](#axOffset), [axPosition](#axPosition),\n[axTicks](#axTicks), [axTickColor](#axTickColor), [axTickCount](#axTickCount),\n[axTemporalTickCount](#axTemporalTickCount), [axTickExtra](#axTickExtra),\n[axTickOffset](#axTickOffset), [axTickOpacity](#axTickOpacity), [axTickRound](#axTickRound),\n[axTickSize](#axTickSize), [axTickWidth](#axTickWidth), [axTitle](#axTitle),\n[axTitleAlign](#axTitleAlign), [axTitleAngle](#axTitleAngle), [axTitleBaseline](#axTitleBaseline),\n[axTitleColor](#axTitleColor),[axTitleFont](#axTitleFont), [axTitleFontSize](#axTitleFontSize),\n[axTitleFontWeight](#axTitleFontWeight), [axTitleLimit](#axTitleLimit), [axTitleOpacity](#axTitleOpacity),\n[axTitlePadding](#axTitlePadding), [axTitleX](#axTitleX), [axTitleY](#axTitleY),\n[axValues](#axValues) and [axZIndex](#axZIndex).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "AxisType",
        "comment": " Identifies the type of axis to be configured with [cfAxis](#cfAxis).\n",
        "args": [],
        "cases": [
          [
            "AxAll",
            []
          ],
          [
            "AxLeft",
            []
          ],
          [
            "AxTop",
            []
          ],
          [
            "AxRight",
            []
          ],
          [
            "AxBottom",
            []
          ],
          [
            "AxX",
            []
          ],
          [
            "AxY",
            []
          ],
          [
            "AxBand",
            []
          ]
        ]
      },
      {
        "name": "BinProperty",
        "comment": " Generated by [bnAnchor](#bnAnchor),\n[bnMaxBins](#bnMaxBins), [bnBase](#bnBase), [bnStep](#bnStep), [bnSteps](#bnSteps),\n[bnMinStep](#bnMinStep), [bnDivide](#bnDivide), [bnNice](#bnNice), [bnSignal](#bnSignal)\nand [bnAs](#bnAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Bind",
        "comment": " Generated by [iRange](#iRange), [iCheckbox](#iCheckbox), [iRadio](#iRadio),\n[iSelect](#iSelect), [iText](#iText), [iNumber](#iNumber), [iDate](#iDate),\n[iTime](#iTime), [iMonth](#iMonth), [iWeek](#iWeek), [iDateTimeLocal](#iDateTimeLocal),\n[iTel](#iTel) and [iColor](#iColor).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Boo",
        "comment": " Generated by [true](#true), [false](#false),\n[boos](#boos), [booSignal](#booSignal), [booSignals](#booSignals) and [booExpr](#booExpr)\n",
        "args": [],
        "cases": []
      },
      {
        "name": "BoundsCalculation",
        "comment": " The bounds calculation method to determine the extent of a sub-plot in a grid\nlayout. `Full` indicates the entire calculated bounds (including axes, title, and\nlegend) will be used. `Flush` indicates only the specified width and height values\nfor the group mark will be used. The flush setting can be useful when attempting\nto place sub-plots without axes or legends into a uniform grid structure.\n",
        "args": [],
        "cases": [
          [
            "Full",
            []
          ],
          [
            "Flush",
            []
          ]
        ]
      },
      {
        "name": "CInterpolate",
        "comment": " Type of color interpolation to apply when mapping a data field onto a color\nscale. Additionally, parameterised interpolation types generated by\n[cubeHelix](#cubeHelix), [cubeHelixLong](#cubeHelixLong), [hclLong](#hclLong),\n[hslLong](#hslLong) and [rgb](#rgb).\n",
        "args": [],
        "cases": [
          [
            "Hcl",
            []
          ],
          [
            "Hsl",
            []
          ],
          [
            "Lab",
            []
          ]
        ]
      },
      {
        "name": "Case",
        "comment": " Type of text case transformation. Used when pre-processing text as\npart of a count pattern transformation.\n",
        "args": [],
        "cases": [
          [
            "Lowercase",
            []
          ],
          [
            "Uppercase",
            []
          ],
          [
            "Mixedcase",
            []
          ]
        ]
      },
      {
        "name": "Clip",
        "comment": " Generated by [clEnabled](#clEnabled), [clPath](#clPath) and [clSphere](#clSphere).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ColorSchemeProperty",
        "comment": " Generated by [csScheme](#csScheme), [csCount](#csCount)\nand [csExtent](#csExtent).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ColorValue",
        "comment": " Generated by [cRGB](#cRGB), [cHSL](#cHSL), [cLAB](#cLAB) and [cHCL](#cHCL).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ConfigProperty",
        "comment": " Generated by\n[cfAutosize](#cfAutosize), [cfBackground](#cfBackground), [cfGroup](#cfGroup),\n[cfEvents](#cfEvents), [cfMark](#cfMark), [cfMarks](#cfMarks), [cfStyle](#cfStyle),\n[cfAxis](#cfAxis), [cfLegend](#cfLegend), [cfTitle](#cfTitle), and [cfScaleRange](#cfScaleRange).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ContourProperty",
        "comment": " Generated by\n[cnValues](#cnValues), [cnX](#cnX), [cnY](#cnY), [cnCellSize](#cnCellSize),\n[cnBandwidth](#cnBandWidth), [cnSmooth](#cnSmooth), [cnThresholds](#cnThresholds),\n[cnCount](#cnCount) and [cnNice](#cnNice).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "CountPatternProperty",
        "comment": " Generated by\n[cpPattern](#cpPattern), [cpCase](#cpCase), [cpStopwords](#cpStopwords) and\n[cpAs](#cprAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "CrossProperty",
        "comment": " Generated by [crFilter](#crFilter) and [crAs](#ccrAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Cursor",
        "comment": " Type of cursor to display. See the\n[CSS cursor documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Keyword%20values)\n",
        "args": [],
        "cases": [
          [
            "CAuto",
            []
          ],
          [
            "CDefault",
            []
          ],
          [
            "CNone",
            []
          ],
          [
            "CContextMenu",
            []
          ],
          [
            "CHelp",
            []
          ],
          [
            "CPointer",
            []
          ],
          [
            "CProgress",
            []
          ],
          [
            "CWait",
            []
          ],
          [
            "CCell",
            []
          ],
          [
            "CCrosshair",
            []
          ],
          [
            "CText",
            []
          ],
          [
            "CVerticalText",
            []
          ],
          [
            "CAlias",
            []
          ],
          [
            "CCopy",
            []
          ],
          [
            "CMove",
            []
          ],
          [
            "CNoDrop",
            []
          ],
          [
            "CNotAllowed",
            []
          ],
          [
            "CAllScroll",
            []
          ],
          [
            "CColResize",
            []
          ],
          [
            "CRowResize",
            []
          ],
          [
            "CNResize",
            []
          ],
          [
            "CEResize",
            []
          ],
          [
            "CSResize",
            []
          ],
          [
            "CWResize",
            []
          ],
          [
            "CNEResize",
            []
          ],
          [
            "CNWResize",
            []
          ],
          [
            "CSEResize",
            []
          ],
          [
            "CSWResize",
            []
          ],
          [
            "CEWResize",
            []
          ],
          [
            "CNSResize",
            []
          ],
          [
            "CNESWResize",
            []
          ],
          [
            "CNWSEResize",
            []
          ],
          [
            "CZoomIn",
            []
          ],
          [
            "CZoomOut",
            []
          ],
          [
            "CGrab",
            []
          ],
          [
            "CGrabbing",
            []
          ]
        ]
      },
      {
        "name": "DataProperty",
        "comment": " Data property for data loading. In addition to declaring `DaSphere` for a global\nsphere, they are more usually generated by the functions [daFormat](#daFormat),\n[daSource](#daSource), [daSources](#daSources), [daValue](#daValue),[daOn](#daOn)\nand [daUrl](#daUrl).\n",
        "args": [],
        "cases": [
          [
            "DaSphere",
            []
          ]
        ]
      },
      {
        "name": "DataReference",
        "comment": " Generated by [daDataset](#daDataset), [daField](#daField), [daFields](#daFields),\n[daSignal](#daSignal), [daValues](#daValues) [daReferences](#daReferences) and\n[daSort](#daSort).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "DataType",
        "comment": " Type of data to be parsed when reading input data. Additional parameterised\ndata type format specifications generated by [foDate](#foDate) and [foUtc](#foUtc).\n",
        "args": [],
        "cases": [
          [
            "FoNum",
            []
          ],
          [
            "FoBoo",
            []
          ]
        ]
      },
      {
        "name": "DensityFunction",
        "comment": " Probability (PDF) or cumulative (CDF) density function.\n",
        "args": [],
        "cases": [
          [
            "PDF",
            []
          ],
          [
            "CDF",
            []
          ]
        ]
      },
      {
        "name": "DensityProperty",
        "comment": " Generated by [dnExtent](#dnExtent), [dnMethod](#dnMethod),\n[dnSteps](#dnSteps) and [dnAs](#dnAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Distribution",
        "comment": " Generated by [diNormal](#diNormal),\n[diUniform](#diUniform), [diKde](#diKde) and [diMixture](#diMixture).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "EncodingProperty",
        "comment": " Generated by [enEnter](#enEnter), [enUpdate](#enUpdate),\n[enExit](#enExit), [enHover](#enHover), [enName](#enName), [enInteractive](#enInteractive)\nand [enCustom](#enCustom).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "EventFilter",
        "comment": " Filter for preventing or allowing event types being handled.\n",
        "args": [],
        "cases": [
          [
            "Prevent",
            []
          ],
          [
            "Allow",
            []
          ]
        ]
      },
      {
        "name": "EventHandler",
        "comment": " Generated by [evHandler](#evHandler),\n[evUpdate](#evUpdate), [evEncode](#evEncode) and [evForce](#evForce).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "EventSource",
        "comment": " Source for an event selector. To specify a DOM node as a source (using a\nCSS selector string), use [esDom](#esDom).\n",
        "args": [],
        "cases": [
          [
            "ESAll",
            []
          ],
          [
            "ESView",
            []
          ],
          [
            "ESScope",
            []
          ],
          [
            "ESWindow",
            []
          ]
        ]
      },
      {
        "name": "EventStream",
        "comment": " Generated by [esObject](#esObject), [esSelector](#esSelector), [esSignal](#esSignal)\nand [esMerge](#esMerge).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "EventStreamProperty",
        "comment": " Generated by [esSource](#esSource), [esType](#esType), [esBetween](#esBetween),\n[esConsume](#esConsume), [esFilter](#esFilter), [esDebounce](#esDebounce),\n[esMarkName](#esMarkName), [esMark](#esMark), [esThrottle](#esThrottle) and\n[esStream](#esStream).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "EventType",
        "comment": " Event types used when handling user interaction events. The `Timer` type will\nfire an event at a regular interval determined by the number of milliseconds provided\nto the `esThrottle` function.\n",
        "args": [],
        "cases": [
          [
            "Click",
            []
          ],
          [
            "DblClick",
            []
          ],
          [
            "DragEnter",
            []
          ],
          [
            "DragLeave",
            []
          ],
          [
            "DragOver",
            []
          ],
          [
            "KeyDown",
            []
          ],
          [
            "KeyPress",
            []
          ],
          [
            "KeyUp",
            []
          ],
          [
            "MouseDown",
            []
          ],
          [
            "MouseMove",
            []
          ],
          [
            "MouseOut",
            []
          ],
          [
            "MouseOver",
            []
          ],
          [
            "MouseUp",
            []
          ],
          [
            "MouseWheel",
            []
          ],
          [
            "TouchEnd",
            []
          ],
          [
            "TouchMove",
            []
          ],
          [
            "TouchStart",
            []
          ],
          [
            "Wheel",
            []
          ],
          [
            "Timer",
            []
          ]
        ]
      },
      {
        "name": "Expr",
        "comment": " A Vega [Expr](https://vega.github.io/vega/docs/types/#Expr) that can be either\na field lookup or a full expression that is evaluated once per datum. Generated\nby [exField](#exField) and [expr](#expr).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Facet",
        "comment": " Generated by [faAggregate](#faAggregate),\n[faField](#faField) and [faGroupBy](#faGroupBy).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Feature",
        "comment": " Generated by [featureSignal](#featureSignal) and [feName](#feName).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Field",
        "comment": " Generated by [fExpr](#fExpr),\n[fDatum](#fDatum), [fGroup](#fGroup), [field](#field), [fParent](#fParent) and\n[fSignal](#fSignal).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Force",
        "comment": " Generated by [foCollide](#foCollide), [foLink](#foLink), [foNBody](#foNBody),\n[foX](#foX) and [foY](#foY).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ForceProperty",
        "comment": " Generated by [fpDistance](#fpDistance), [fpDistanceMax](#fpDistanceMax),\n[fpDistanceMin](#fpDistanceMin), [fpId](#fpId), [fpIterations](#fpIterations),\n[fpStrength](#fpStrength) and [fpTheta](#fpTheta).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ForceSimulationProperty",
        "comment": " Generated by [fsAlpha](#fsAlpha),\n[fsAlphaMin](#fsAlphaMin), [fsAlphaTarget](#fsAlphaTarget), [fsAs](#fsAs),\n[fsForces](#fsForces), [fsIterations](#fsIterations), [fsRestart](#fsRestart),\n[fsStatic](#fsStatic) and [fsVelocityDecay](#fsVelocityDecay).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "FormatProperty",
        "comment": " Format used by a data source. `ParseAuto` can be used for performing automatic\ntype inference on data types. If more explicit control is needed then `parse` can\nbe used to specify the type for named fields.\n",
        "args": [],
        "cases": [
          [
            "JSON",
            []
          ],
          [
            "CSV",
            []
          ],
          [
            "TSV",
            []
          ],
          [
            "ParseAuto",
            []
          ]
        ]
      },
      {
        "name": "GeoJsonProperty",
        "comment": " Generated by [gjFields](#gjFields), [gjFeature](#gjFeature) and [gjSignal](#gjSignal).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "GeoPathProperty",
        "comment": " Generated by [gpField](#gpField), [gpAs](#gpAs) and [gpPointRadius](#gpPointRadius).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "GraticuleProperty",
        "comment": " Generated by\n[grField](#grField), [grExtent](#grExtent), [grExtentMajor](#grExtentMajor),\n[grExtentMinor](#grExtentMinor), [grStep](#grStep), [grStepMajor](#grStepMajor),\n[grStepMinor](#grStepMinor) and [grPrecision](#grPrecision).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "GridAlign",
        "comment": " Layout alignment to apply to grid rows and columns. `AlignNone`\nindicates a flow layout will be used, in which adjacent plots are simply placed\none after the other. `AlignEach` indicates elements will be aligned into a clean\ngrid structure, but each row or column may be of variable size. `AlignAll` indicates\nelements will be aligned and each row or column will be sized identically based\non the maximum observed size. To used different row and column layouts, use `grAlignRow`\nand `grAlignColumn`.\n",
        "args": [],
        "cases": [
          [
            "AlignAll",
            []
          ],
          [
            "AlignEach",
            []
          ],
          [
            "AlignNone",
            []
          ]
        ]
      },
      {
        "name": "HAlign",
        "comment": " Horizontal alignment of some text such as on an axis or legend.\n",
        "args": [],
        "cases": [
          [
            "AlignCenter",
            []
          ],
          [
            "AlignLeft",
            []
          ],
          [
            "AlignRight",
            []
          ]
        ]
      },
      {
        "name": "ImputeMethod",
        "comment": " Imputation method to be used when assigning values to missing data values.\n`ByValue` allows a specific value to be assigned for missing values while the other\nmethods will calculate a value based on a group of existing values.\n",
        "args": [],
        "cases": [
          [
            "ByValue",
            []
          ],
          [
            "ByMean",
            []
          ],
          [
            "ByMedian",
            []
          ],
          [
            "ByMax",
            []
          ],
          [
            "ByMin",
            []
          ]
        ]
      },
      {
        "name": "ImputeProperty",
        "comment": " Generated by\n<imKeyVals>, [imMethod](#imMethod), [imGroupBy](#imGroupBy) and\n[imValue](#imValue).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "InputProperty",
        "comment": " Generated by [inDebounce](#inDebounce), [inElement](#inElement),\n[inOptions](#inOptions), [inMin](#inMin), [inMax](#inMax), [inStep](#inStep),\n[inPlaceholder](#inPlaceholder) and [inAutocomplete](#inAutocomplete).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "JoinAggregateProperty",
        "comment": " Generated\nby [jaGroupBy](#jaGroupBy), [jaFields](#jaFields), [jaOps](#jaOps) and [jaAs](#jaAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "LayoutProperty",
        "comment": " Generated by\n[loAlign](#loAlign), [loBounds](#loBounds), [loColumns](#loColumns), [loPadding](#loPadding),\n[loPaddingRC](#loPaddingRC), [loOffset](#loOffset), [loOffsetRC](#loOffsetRC),\n[loHeaderBand](#loHeaderBand), [loHeaderBandRC](#loHeaderBandRC), [loFooterBand](#loFooterBand),\n[loFooterBandRC](#loFooterBandRC), [loTitleBand](#loTitleBand) and\n[loTitleBandRC](#loTitleBandRC).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "LegendEncoding",
        "comment": " Generated by [enLegend](#enLegend), [enTitle](#enTitle),\n[enLabels](#enLabels), [enSymbols](#enSymbols) and [enGradient](#enGradient).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "LegendOrientation",
        "comment": " Position of a legend relative to the visualization it describes.\n",
        "args": [],
        "cases": [
          [
            "Left",
            []
          ],
          [
            "TopLeft",
            []
          ],
          [
            "Top",
            []
          ],
          [
            "TopRight",
            []
          ],
          [
            "Right",
            []
          ],
          [
            "BottomRight",
            []
          ],
          [
            "Bottom",
            []
          ],
          [
            "BottomLeft",
            []
          ],
          [
            "None",
            []
          ]
        ]
      },
      {
        "name": "LegendProperty",
        "comment": " Generated by [leType](#leType), [leDirection](#leDirection), [leOrient](#leOrient),\n[leFill](#leFill), [leOpacity](#leOpacity), [leShape](#leShape), [leSize](#leSize),\n[leStroke](#leStroke), [leStrokeDash](#leStrokeDash), [leEncode](#leEncode),\n[leFormat](#leFormat), [leGridAlign](#leGridAlign), [leClipHeight](#leClipHeight),\n[leColumns](#leColumns), [leColumnPadding](#leColumnPadding), [leRowPadding](#leRowPadding),\n[leCornerRadius](#leCornerRadius), [leFillColor](#leFillColor), [leOffset](#leOffset),\n[lePadding](#lePadding), [leStrokeColor](#leStrokeColor), [leStrokeWidth](#leStrokeWidth),\n[leGradientLength](#leGradientLength), [leGradientLabelLimit](#leGradientLabelLimit),\n[leGradientLabelOffset](#leGraidentLabelOffset), [leGradientOpacity](#leGradientOpacity),\n[leGradientThickness](#leGradientThickness), [leGradientStrokeColor](#leGradientStrokeColor),\n[leGradientStrokeWidth](#leGradientStrokeWidth), [leLabelAlign](#leLabelAlign),\n[leLabelBaseline](#leLabelBaseline), [leLabelColor](#leLabelColor), [leLabelFont](#leLabelFont),\n[leLabelFontSize](#leLabelFontSize), [leLabelFontWeight](#leLabelFontWeight),\n[leLabelLimit](#leLabelLimit), [leLabelOpacity](#leLabelOpacity), [leLabelOffset](#leLabelOffset),\n[leLabelOverlap](#leLabelOverlap), [leSymbolFillColor](#leSymbolFillColor),\n[leSymbolOpacity](#leSymbolOpacity), [leSymbolOffset](#leSymbolOffset),\n[leSymbolSize](#leSymbolSize), [leSymbolStrokeColor](#leSymbolStrokeColor),\n[leSymbolStrokeWidth](#leSymbolStrokeWidth), [leSymbolType](#leSymbolType),\n[leTickCount](#leTickCount), [leTemporalTickCount](#leTemporalTickCount),\n[leTitle](#leTitle), [leTitleAlign](#leTitleAlign), [leTitleBaseline](#leTitleBaseline),\n[leTitleColor](#leTitleColor), [leTitleFont](#leTitleFont), [leTitleFontSize](#leTitleFontSize),\n[leTitleFontWeight](#leTitleFontWeight), [leTitleLimit](#leTitleLimit),\n[leTitleOpacity](#leTitleOpacity) [leTitlePadding](#leTitlePadding),\n[leValues](#leValues) and [leZIndex](#leZIndex).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "LegendType",
        "comment": " Type of legend. `LSymbol` representing legends with discrete items and `LGradient`\nfor those representing continuous data.\n",
        "args": [],
        "cases": [
          [
            "LSymbol",
            []
          ],
          [
            "LGradient",
            []
          ]
        ]
      },
      {
        "name": "LinkPathProperty",
        "comment": " Generated by [lpSourceY](#lpSourceY),\n[lpTargetX](#lpTargetX), [lpTargetY](#lpTargetY), [lpOrient](#lpOrient),\n[lpShape](#lpShape) and [lpAs](#lpAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "LinkShape",
        "comment": " Shape of a line indicating path between nodes.\n",
        "args": [],
        "cases": [
          [
            "LinkLine",
            []
          ],
          [
            "LinkArc",
            []
          ],
          [
            "LinkCurve",
            []
          ],
          [
            "LinkDiagonal",
            []
          ],
          [
            "LinkOrthogonal",
            []
          ]
        ]
      },
      {
        "name": "LookupProperty",
        "comment": " Generated by [luValues](#luValues),\n[luAs](#luAs) and [luDefault](#luDefault).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Mark",
        "comment": " Type of visual mark used to represent data in the visualization.\n",
        "args": [],
        "cases": [
          [
            "Arc",
            []
          ],
          [
            "Area",
            []
          ],
          [
            "Image",
            []
          ],
          [
            "Group",
            []
          ],
          [
            "Line",
            []
          ],
          [
            "Path",
            []
          ],
          [
            "Rect",
            []
          ],
          [
            "Rule",
            []
          ],
          [
            "Shape",
            []
          ],
          [
            "Symbol",
            []
          ],
          [
            "Text",
            []
          ],
          [
            "Trail",
            []
          ]
        ]
      },
      {
        "name": "MarkInterpolation",
        "comment": " Indicate mark interpolation style.\n",
        "args": [],
        "cases": [
          [
            "Basis",
            []
          ],
          [
            "Bundle",
            []
          ],
          [
            "Cardinal",
            []
          ],
          [
            "CatmullRom",
            []
          ],
          [
            "Linear",
            []
          ],
          [
            "Monotone",
            []
          ],
          [
            "Natural",
            []
          ],
          [
            "Stepwise",
            []
          ],
          [
            "StepAfter",
            []
          ],
          [
            "StepBefore",
            []
          ]
        ]
      },
      {
        "name": "MarkProperty",
        "comment": " Generated by [maX](#maX),\n[maX2](#maX2), [maXC](#maXC), [maWidth](#maWidth), [maY](#maY), [maY2](#maY2), [maYC](#maYC),\n[maHeight](#maHeight), [maOpacity](#maOpacity), [maFill](#maFill), [maFillOpacity](#maFillOpacity),\n[maStroke](#maStroke), [maStrokeOpacity](#maStrokeOpacity), [maStrokeWidth](#maStrokeWidth),\n[maStrokeCap](#maStrokeCap), [maStrokeDash](#maStrokeDash), [maStrokeDashOffset](#maStrokeDashOffset),\n[maStrokeJoin](#maStrokeJoin), [maStrokeMiterLimit](#maStrokeMiterLimit), [maCursor](#maCursor),\n[maHRef](#maHRef), [maTooltip](#maTooltip), [maZIndex](#maZIndex), [maAlign](#maAlign),\n[maBaseline](#maBaseline), [maCornerRadius](#maCornerRadius), [maInterpolate](#maInterpolate),\n[maTension](#maTension), [maDefined](#maDefined), [maSize](#maSize), [maStartAngle](#maStartAngle),\n[maEndAngle](#maEndAngle), [maPadAngle](#maPadAngle), [maInnerRadius](#maInnerRadius),\n[maOuterRadius](#maOuterRadius), [maOrient](#maOrient), [maGroupClip](#maGroupClip),\n[maUrl](#maUrl), [maAspect](#maAspect), [maPath](#maPath), [maShape](#maShape),\n[maSymbol](#maSymbol), [maAngle](#maAngle), [maDir](#maDir), [maDx](#maDx), [maDy](#maDy),\n[maEllipsis](#maEllipsis), [maFont](#maFont), [maFontSize](#maFontSize),\n[maFontWeight](#maFontWeight), [maFontStyle](#maFontStyle), [maLimit](#maLimit),\n[maRadius](#maRadius), [maText](#maText) and [maTheta](#maTheta).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Num",
        "comment": " Generated by [num](#num), [nums](#nums),\n[numSignal](#numSignal), [numSignals](#numSignals), [numList](#numList),\n[numExpr](#numExpr) and [numNull](#numNull)\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Operation",
        "comment": " Type of aggregation operation.\n",
        "args": [],
        "cases": [
          [
            "ArgMax",
            []
          ],
          [
            "ArgMin",
            []
          ],
          [
            "Average",
            []
          ],
          [
            "CI0",
            []
          ],
          [
            "CI1",
            []
          ],
          [
            "Count",
            []
          ],
          [
            "Distinct",
            []
          ],
          [
            "Max",
            []
          ],
          [
            "Mean",
            []
          ],
          [
            "Median",
            []
          ],
          [
            "Min",
            []
          ],
          [
            "Missing",
            []
          ],
          [
            "Q1",
            []
          ],
          [
            "Q3",
            []
          ],
          [
            "Stderr",
            []
          ],
          [
            "Stdev",
            []
          ],
          [
            "Stdevp",
            []
          ],
          [
            "Sum",
            []
          ],
          [
            "Valid",
            []
          ],
          [
            "Variance",
            []
          ],
          [
            "Variancep",
            []
          ]
        ]
      },
      {
        "name": "Order",
        "comment": " Sorting order. See the\n[Vega type comparison documentation](https://vega.github.io/vega/docs/types/#Compare).\n",
        "args": [],
        "cases": [
          [
            "Ascend",
            []
          ],
          [
            "Descend",
            []
          ]
        ]
      },
      {
        "name": "Orientation",
        "comment": " Orientation of a mark, legend or link path (e.g. horizontally or vertically\noriented bars). Note that not all can use `Radial` orientation.\n",
        "args": [],
        "cases": [
          [
            "Horizontal",
            []
          ],
          [
            "Vertical",
            []
          ],
          [
            "Radial",
            []
          ]
        ]
      },
      {
        "name": "OverlapStrategy",
        "comment": " Overlap strategy to be applied when there is not space to show all items on an axis.\n",
        "args": [],
        "cases": [
          [
            "ONone",
            []
          ],
          [
            "OParity",
            []
          ],
          [
            "OGreedy",
            []
          ]
        ]
      },
      {
        "name": "PackProperty",
        "comment": " Generated by [paField](#paField),\n[paSort](#paSort), [paSize](#paSize), [paRadius](#paRadius), [paPadding](#paPadding)\nand [paAs](#paAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "PartitionProperty",
        "comment": " Generated by [ptField](#ptField), [ptSort](#ptSort), [ptPadding](#ptPadding),\n[ptRound](#ptRound), [ptSize](#ptSize) and [ptAs](#ptAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "PieProperty",
        "comment": " Generated by [piField](#piField),\n[piStartAngle](#piStartAngle), [piEndAngle](#piEndAngle), [piSort](#piSort) and\n[piAs](#piAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "PivotProperty",
        "comment": " Generated by [piGroupBy](#piGroupBy),\n[piLimit](#piLimit) and [piOp](#piOp).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Projection",
        "comment": " Type of global map projection.\n",
        "args": [],
        "cases": [
          [
            "Albers",
            []
          ],
          [
            "AlbersUsa",
            []
          ],
          [
            "AzimuthalEqualArea",
            []
          ],
          [
            "AzimuthalEquidistant",
            []
          ],
          [
            "ConicConformal",
            []
          ],
          [
            "ConicEqualArea",
            []
          ],
          [
            "ConicEquidistant",
            []
          ],
          [
            "Equirectangular",
            []
          ],
          [
            "Gnomonic",
            []
          ],
          [
            "Mercator",
            []
          ],
          [
            "NaturalEarth1",
            []
          ],
          [
            "Orthographic",
            []
          ],
          [
            "Stereographic",
            []
          ],
          [
            "TransverseMercator",
            []
          ]
        ]
      },
      {
        "name": "ProjectionProperty",
        "comment": " Generated by\n[prType](#prType), [prClipAngle](#prClipAngle), [prClipExtent](#prClipExtent),\n[prScale](#prScale), [prTranslate](#prTranslate), [prCenter](#prCenter), [prRotate](#prRotate),\n[prPointRadius](#prPointRadius), [prPrecision](#prPrecision), [prFit](#prFit),\n[prExtent](#prExtent), [prSize](#prSize), [prCoefficient](#prCoefficient),\n[prDistance](#prDistance), [prFraction](#prFraction), [prLobes](#prLobes),\n[prParallel](#prParallel), [prRadius](#prRadius), [prRatio](#prRatio), [prSpacing](#prSpacing),\nand [prTilt](#prTilt).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Scale",
        "comment": " Type of scale transformation to apply.\n",
        "args": [],
        "cases": [
          [
            "ScLinear",
            []
          ],
          [
            "ScPow",
            []
          ],
          [
            "ScSqrt",
            []
          ],
          [
            "ScLog",
            []
          ],
          [
            "ScTime",
            []
          ],
          [
            "ScUtc",
            []
          ],
          [
            "ScSequential",
            []
          ],
          [
            "ScOrdinal",
            []
          ],
          [
            "ScBand",
            []
          ],
          [
            "ScPoint",
            []
          ],
          [
            "ScQuantile",
            []
          ],
          [
            "ScQuantize",
            []
          ],
          [
            "ScBinLinear",
            []
          ],
          [
            "ScBinOrdinal",
            []
          ]
        ]
      },
      {
        "name": "ScaleDomain",
        "comment": " Generated by [doNums](#doNums),\n[doStrs](#doStrs) and [doData](#doData).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ScaleNice",
        "comment": " 'nice' number-scaling options.\n",
        "args": [],
        "cases": [
          [
            "NMillisecond",
            []
          ],
          [
            "NSecond",
            []
          ],
          [
            "NMinute",
            []
          ],
          [
            "NHour",
            []
          ],
          [
            "NDay",
            []
          ],
          [
            "NWeek",
            []
          ],
          [
            "NMonth",
            []
          ],
          [
            "NYear",
            []
          ],
          [
            "NTrue",
            []
          ],
          [
            "NFalse",
            []
          ]
        ]
      },
      {
        "name": "ScaleProperty",
        "comment": " Generated by [scType](#scType), [scDomain](#scDomain),\n[scDomainMax](#scDomainMax), [scDomainMin](#scDomainMin), [scDomainMid](#scDomainMid),\n[scDomainRaw](#scDomainRaw), [scRange](#scRange), [scReverse](#scReverse),\n[scRound](#scRound), [scClamp](#scClamp), [scInterpolate](#scInterpolate),\n[scPadding](#scPadding), [scNice](#scNice), [scZero](#scZero), [scExponent](#scExponent),\n[scBase](#scBase), [scAlign](#scAlign), [scDomainImplicit](#scDomainImplicit),\n[scPaddingInner](#scPaddingInner), [scPaddingOuter](#scPaddingOuter) and\n[scRangeStep](#scRangeStep).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ScaleRange",
        "comment": " Describes a scale range of scale output values. In addition to the preset default\noptions (`RaWidth`, `RaHeight` etc.), scale ranges can be generated by [raNums](#raNums),\n[raStrs](#raStrs), [raValues](#raValues), [raSignal](#raSignal), [raScheme](#raScheme),\n[raData](#raData), [raStep](#raStep) and [raCustomDefault](#raCustomDefault).\n",
        "args": [],
        "cases": [
          [
            "RaWidth",
            []
          ],
          [
            "RaHeight",
            []
          ],
          [
            "RaSymbol",
            []
          ],
          [
            "RaCategory",
            []
          ],
          [
            "RaDiverging",
            []
          ],
          [
            "RaOrdinal",
            []
          ],
          [
            "RaRamp",
            []
          ],
          [
            "RaHeatmap",
            []
          ]
        ]
      },
      {
        "name": "Side",
        "comment": " Rectangular side. Can be used to specify an axis position.\n",
        "args": [],
        "cases": [
          [
            "SLeft",
            []
          ],
          [
            "SRight",
            []
          ],
          [
            "STop",
            []
          ],
          [
            "SBottom",
            []
          ]
        ]
      },
      {
        "name": "SignalProperty",
        "comment": " Generated by [siName](#siName), [siBind](#siBind),\n[siDescription](#siDescription), [siOn](#siOn), [siUpdate](#siUpdate),\n[siReact](#siReact), [siValue](#siValue) and [siPushOuter](#siPushOuter).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "SortProperty",
        "comment": " Sorting type.\n",
        "args": [],
        "cases": [
          [
            "Ascending",
            []
          ],
          [
            "Descending",
            []
          ]
        ]
      },
      {
        "name": "Source",
        "comment": " Generated by [srData](#srData) and [srFacet](#srFacet).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Spiral",
        "comment": " Spiraling type for sequential positioning of words in a wordcloud.\n",
        "args": [],
        "cases": [
          [
            "Archimedean",
            []
          ],
          [
            "Rectangular",
            []
          ]
        ]
      },
      {
        "name": "StackOffset",
        "comment": " Type of offsetting to apply when stacking. `OfZero` uses a baseline at the foot\nof a stack, `OfCenter` uses a central baseline with stacking both above and below\nit. `OfNormalize` rescales the stack to a common height while preserving the\nrelative size of stacked quantities.\n",
        "args": [],
        "cases": [
          [
            "OfZero",
            []
          ],
          [
            "OfCenter",
            []
          ],
          [
            "OfNormalize",
            []
          ]
        ]
      },
      {
        "name": "StackProperty",
        "comment": " Generated by [stField](#stField),\n[stGroupBy](#stGroupBy), [stSort](#stSort), [stOffset](#stOffset) and\n[stAs](#stAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Str",
        "comment": " Generated by [str](#str), [strs](#strs), [strList](#strList), [strSignal](#strSignal),\n[strSignals](#strSignals), [strExpr](#strExpr) and [strNull](#strNull).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "StrokeCap",
        "comment": " Type of stroke cap.\n",
        "args": [],
        "cases": [
          [
            "CButt",
            []
          ],
          [
            "CRound",
            []
          ],
          [
            "CSquare",
            []
          ]
        ]
      },
      {
        "name": "StrokeJoin",
        "comment": " Type of stroke join.\n",
        "args": [],
        "cases": [
          [
            "JMiter",
            []
          ],
          [
            "JRound",
            []
          ],
          [
            "JBevel",
            []
          ]
        ]
      },
      {
        "name": "Symbol",
        "comment": " Symbol type.\n",
        "args": [],
        "cases": [
          [
            "SymCircle",
            []
          ],
          [
            "SymSquare",
            []
          ],
          [
            "SymCross",
            []
          ],
          [
            "SymDiamond",
            []
          ],
          [
            "SymTriangleUp",
            []
          ],
          [
            "SymTriangleDown",
            []
          ],
          [
            "SymTriangleLeft",
            []
          ],
          [
            "SymTriangleRight",
            []
          ]
        ]
      },
      {
        "name": "TextDirection",
        "comment": " Text render direction. This determines which end of a text string is\ntruncated if it cannot be displayed within a restricted space.\n",
        "args": [],
        "cases": [
          [
            "LeftToRight",
            []
          ],
          [
            "RightToLeft",
            []
          ]
        ]
      },
      {
        "name": "TimeUnit",
        "comment": " Unit of time. Useful for encoding and transformations.\n",
        "args": [],
        "cases": [
          [
            "Year",
            []
          ],
          [
            "Month",
            []
          ],
          [
            "Week",
            []
          ],
          [
            "Day",
            []
          ],
          [
            "Hour",
            []
          ],
          [
            "Minute",
            []
          ],
          [
            "Second",
            []
          ],
          [
            "Millisecond",
            []
          ]
        ]
      },
      {
        "name": "TitleFrame",
        "comment": " Title anchor position calculation. `FrBounds` implies text anchor is relative\nto the full bounding box; `FrGroup` implies it is relative to the group width/height.\n",
        "args": [],
        "cases": [
          [
            "FrBounds",
            []
          ],
          [
            "FrGroup",
            []
          ]
        ]
      },
      {
        "name": "TitleProperty",
        "comment": " Generated by [tiOrient](#tiOrient),\n[tiAnchor](#tiAnchor), [tiAngle](#tiAngle), [tiAlign](#tiAlign), [tiBaseline](#tiBaseline),\n[tiColor](#tiColor), [tiEncode](#tiEncode), [tiFont](#tiFont), [tiFontSize](#tiFontSize),\n[tiFontWeight](#tiFontWeight), [tiFrame](#tiFrame), [tiInteractive](#tiInteractive),\n[tiLimit](#tiLimit), [tiName](#tiName), [tiStyle](#tiStyle), [tiOffset](#tiOffset) and\n[tiZIndex](#tiZIndex).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "TopMarkProperty",
        "comment": " Generated by [mType](#mType),\n[mClip](#mClip), [mDescription](#mDescription), [mEncode](#mEncode), [mFrom](#mFrom),\n[mInteractive](#mInteractive), [mKey](#mKey), [mName](#mName), [mOn](#mOn),\n[mSort](#mSort), [mTransform](#mTransform), [mRole](#mRole), [mStyle](#mStyle),\n[mGroup](#mGroup) and [mZIndex](#mZIndex).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Transform",
        "comment": " Generated by [trAggregate](#trAggregate), [trBin](#trBin), [trCollect](#trCollect),\n[trContour](#trContour), [trCountPattern](#trCountPattern), [trCross](#trCross),\n[trCrossFilter](#trCrossFilter), [trCrossFilterAsSignal](#trCrossFilterAsSignal),\n[trDensity](#trDensity), [trExtent](#trExtent), [trExtentAsSignal](#trExtentAsSignal),\n[trFilter](#trFilter), [trFlatten](#trFlatten), [trFlattenAs](#trFlattenAs),\n[trFold](#trFold), [trFoldAs](#trFoldAs), [trForce](#trForce), [trFormula](#trFormula),\n[trFormulaInitOnly](#trFormulaInitOnly), [trGeoJson](#trGeoJson), [trGeoPath](#trGeoPath),\n[trGeoPoint](#trGeoPoint), [trGeoPointAs](#trGeoPointAs), [trGeoShape](#trGeoShape),\n[trGraticule](#trGraticule), [trIdentifier](#trIdentifier), [trImpute](#trImpute),\n[trJoinAggregate](#trJoinAggregate), [trLinkPath](#trLinkPath), [trLookup](#trLookup),\n[trNest](#trNest), [trPack](#trPack), [trPartition](#trPartition), [trPie](#trPie),\n[trPivot](#trPivot), [trProject](#trProject), [trResolveFilter](#trResolveFilter),\n[trSample](#trSample), [trSequence](#trSequence), [trStack](#trStack),\n[trStratify](#trStratify), [trTree](#trTree), [trTreeLinks](#trTreeLinks),\n[trTreemap](#trTreemap), [trVoronoi](#trVoronoi), [trWindow](#trWindow) and\n[trWordCloud](#trWordCloud).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "TreeMethod",
        "comment": " A tree layout method used in a tree transform.\n",
        "args": [],
        "cases": [
          [
            "Tidy",
            []
          ],
          [
            "Cluster",
            []
          ]
        ]
      },
      {
        "name": "TreeProperty",
        "comment": " Generated by [teField](#teField), [teSort](#teSort), [teMethod](#teMethod),\n[teSize](#teSize), [teNodeSize](#teNodeSize) and [teAs](#teAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "TreemapMethod",
        "comment": " A treemap layout method used in a treemap transform.\n",
        "args": [],
        "cases": [
          [
            "Squarify",
            []
          ],
          [
            "Resquarify",
            []
          ],
          [
            "Binary",
            []
          ],
          [
            "Dice",
            []
          ],
          [
            "Slice",
            []
          ],
          [
            "SliceDice",
            []
          ]
        ]
      },
      {
        "name": "TreemapProperty",
        "comment": " Generated by [tmField](#tmField), [tmSort](#tmSort), [tmMethod](#tmMethod),\n[tmPadding](#tmPadding), [tmPaddingInner](#tmPaddingInner), [tmPaddingOuter](#tmPaddingOuter),\n[tmPaddingTop](#tmPaddingTop), [tmPaddingRight](#tmPaddingRight), [tmPaddingBottom](#tmPaddingBottom),\n[tmPaddingLeft](#tmPaddingLeft), [tmRatio](#tmRatio), [tmRound](#tmRound), [tmSize](#tmSize)\nand [tmAs](#tmAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "TriggerProperty",
        "comment": " Generated by [tgInsert](#tgInsert), [tgRemove](#tgRemove), [tgRemoveAll](#tgRemoveAll),\n[tgToggle](#tgToggle) and [tgModifyValues](#tgModifyValues).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "VAlign",
        "comment": " Vertical alignment of some text or an image mark. Note that the `Alphabetic`\ntype constructor applies only to text marks.\n",
        "args": [],
        "cases": [
          [
            "AlignTop",
            []
          ],
          [
            "AlignMiddle",
            []
          ],
          [
            "AlignBottom",
            []
          ],
          [
            "Alphabetic",
            []
          ]
        ]
      },
      {
        "name": "VProperty",
        "comment": " Top-level Vega properties (see the\n[specification documentation](https://vega.github.io/vega/docs/specification/)).\n\n**Data properties** specify the input data to be visualized. Generated by\n[`dataSource`](#dataSource) that can collect together data tables such as those\nread from a URL or generated inline.\n\n**Signal properties** specify dynamic variables that respond reactively to other\nsignals or interactions. Generated by [`signals`](#signals).\n\n**Scale properties** map data values to visual channels such as position, or color.\nGenerated by [`scales`](#scales).\n\n**Projection properties** specify how geospatial data referenced with\nlongitude, latitude coordinates are projected onto a plane for visualization.\nGenerated by [`projections`](#projections).\n\n**Axis properties** specify how spatial scale mappings are visualized, such as with\ntick marks, grid lines and labels. Generated by [`axes`](#axes).\n\n**Legend properties** specify how visual scale mappings such as color, shape and\nsize are visualized. Generated by [`legends`](#legends).\n\n**Title properties** specify how a visualization title should appear. Generated\nby [`title`](#title).\n\n** Layout properties** specify how a group of visual marks are organised within\na grid. This allows visualizations to be composed of other visualizations, for\nexample in a dashboard or collection of small multiples. Generated by [`layout`](#layout).\n\n**Mark properties** specify how to visually encode data with graphical primitives\nsuch as points, lines and other symbols. Generated by [`marks`](#marks).\n\n**Top-level group encodings** specify the appearance of the chart's data rectangle.\nFor example setting the background color of the plotting area. Generated by\n[`encode`](#encode).\n\n**Config properties** specify default settings of a specification. Allows consistent\nand easily modifiable styles to be applied to a visualization. Generated by\n[`config`](#config).\n\n**Supplementary properties** add metadata and some styling to one or more visualizations.\nGenerated by [`width`](#width), [`height`](#height), [`padding`](#padding),\n[`paddings`](#paddings), [`autosize`](#autosize), [`background`](#background)\nand [`description`](#description).\n\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Value",
        "comment": " Generated by [vStr](#vStr), [vStrs](#vStrs), [vNum](#vNum),\n[vNums](#vNums), [vTrue](#vTrue), [vFalse](#vFalse), [vBoos](#vBoos),\n[vObject](#vObject), [vKeyValue](#vKeyValue), [vValues](#vValues), [vSignal](#vSignal),\n[vColor](#vColor), [vField](#vField), [vScale](#vScale), [vScaleField](#vScaleField),\n[vBand](#vBand), [vExponent](#vExponent), [vMultiply](#vMultiply), [vOffset](#vOffset),\n[vRound](#vRound), [vNull](#vNull) and [ifElse](#ifElse).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "VoronoiProperty",
        "comment": " Generated by [voExtent](#voExtent), [voSize](#voSize) and [voAs](#voAs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "WOperation",
        "comment": " Operations that may be applied during a window transformation.\n",
        "args": [],
        "cases": [
          [
            "RowNumber",
            []
          ],
          [
            "Rank",
            []
          ],
          [
            "DenseRank",
            []
          ],
          [
            "PercentRank",
            []
          ],
          [
            "CumeDist",
            []
          ],
          [
            "Ntile",
            []
          ],
          [
            "Lag",
            []
          ],
          [
            "Lead",
            []
          ],
          [
            "FirstValue",
            []
          ],
          [
            "LastValue",
            []
          ],
          [
            "NthValue",
            []
          ]
        ]
      },
      {
        "name": "WindowOperation",
        "comment": " Generated by [wnOperation](#wnOperation), [wnOperationOn](#wnOperationOn) and\n[wnAggOperation](#wnAggOperation).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "WindowProperty",
        "comment": " Generated by [wnSort](#wnSort), [wnGroupBy](#wnGroupBy), [wnFrame](#wnFrame)\nand [wnIgnorePeers](#wnIgnorePeers).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "WordcloudProperty",
        "comment": " Generated by\n[wcFont](#wcFont), [wcFontStyle](#wcFontStyle), [wcFontWeight](#wcFontWeight),\n[wcFontSize](#wcFontSize), [wcFontSizeRange](#wcFontSizeRange), [wcPadding](#wcPadding),\n[wcRotate](#wcRotate), [wcText](#wcText), [wcSize](#wcSize), [wcSprial](#wcSpiral)\nand [wcAs](#wcAs).\n",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "agAs",
        "comment": " The output field names generated when performing an aggregation transformation.\nThe list of field names should align with the fields operations provided by `agFields`\nand `agOps`. If not provided, automatic names are generated by appending `_field`\nto the operation name.\n",
        "type": "List String -> Vega.AggregateProperty"
      },
      {
        "name": "agCross",
        "comment": " Whether or not the full cross-product of all `groupby` values should\nbe included in the output of an aggregation transformation.\n",
        "type": "Vega.Boo -> Vega.AggregateProperty"
      },
      {
        "name": "agDrop",
        "comment": " Whether or not empty (zero count) groups should be dropped when in an\naggregation transformation.\n",
        "type": "Vega.Boo -> Vega.AggregateProperty"
      },
      {
        "name": "agFields",
        "comment": " Data fields to compute aggregate functions when performing an\naggregation transformation. The list of fields should align with the operations\nand field names provided by `agOps` and `agAs`. If no fields and operations are\nspecified, a count aggregation will be used by default.\n",
        "type": "List Vega.Field -> Vega.AggregateProperty"
      },
      {
        "name": "agGroupBy",
        "comment": " Data fields to group by when performing an aggregation transformation.\nIf not specified, a single group containing all data objects will be used.\n",
        "type": "List Vega.Field -> Vega.AggregateProperty"
      },
      {
        "name": "agKey",
        "comment": " Field to act as a unique key when performing an [agGroupBy](#agGroupBy)\naggregation. This can speed up the aggregation but should only be used when there\nis redundancy in the list of groupBy fields (as there is when binning for example).\n\n    transform\n        [ trBin (field \"examScore\") (nums [ 0, 100 ]) []\n        , trAggregate\n            [ agKey (field \"bin0\")\n            , agGroupBy [ field \"bin0\", field \"bin1\" ]\n            , agOps [ Count ]\n            , agAs [ \"count\" ]\n            ]\n        ]\n\n",
        "type": "Vega.Field -> Vega.AggregateProperty"
      },
      {
        "name": "agOps",
        "comment": " Aggregation operations to apply to the fields when performing an\naggregation transformation. The list of operations should align with the fields\noutput field names provided by `agFields` and `agAs`.\n",
        "type": "List Vega.Operation -> Vega.AggregateProperty"
      },
      {
        "name": "anchorSignal",
        "comment": " Indicate that an anchor position is to be determined by a named signal.\nThe signal should generate one of `start`, `middle` or `end`.\n",
        "type": "String -> Vega.Anchor"
      },
      {
        "name": "autosize",
        "comment": " Indicate how the view is sized.\n",
        "type": "List Vega.Autosize -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "autosizeSignal",
        "comment": " Indicate that an auto-sizing rule is to be determined by a named signal.\n",
        "type": "String -> Vega.Autosize"
      },
      {
        "name": "axBandPosition",
        "comment": " Interpolation fraction indicating where, for band scales, axis ticks\nshould be positioned. A value of 0 places ticks at the left edge of their bands.\nA value of 0.5 places ticks in the middle of their bands.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axDomain",
        "comment": " Whether or not the domain (the axis baseline) should be included as part of\nan axis.\n",
        "type": "Vega.Boo -> Vega.AxisProperty"
      },
      {
        "name": "axDomainColor",
        "comment": " Color of an axis domain line.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axDomainOpacity",
        "comment": " Opacity of an axis domain line.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axDomainWidth",
        "comment": " Width in pixels of an axis domain line.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axEncode",
        "comment": " Mark encodings for custom axis styling.\n",
        "type": "List ( Vega.AxisElement, List Vega.EncodingProperty ) -> Vega.AxisProperty"
      },
      {
        "name": "axFormat",
        "comment": " The format specifier pattern for axis labels. For numerical values, must be\na legal [d3-format specifier](https://github.com/d3/d3-format#locale_format).\nFor date-time values, must be a legal\n[d3-time-format](https://github.com/d3/d3-time-format#locale_format) specifier.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axGrid",
        "comment": " Whether or not grid lines should be included as part of an axis.\n",
        "type": "Vega.Boo -> Vega.AxisProperty"
      },
      {
        "name": "axGridColor",
        "comment": " Color of an axis's grid lines.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axGridDash",
        "comment": " Stroke dash of an axis's grid lines as a list of dash-gap lengths.\n",
        "type": "List Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axGridOpacity",
        "comment": " Opacity of an axis's grid lines.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axGridScale",
        "comment": " Name of the scale to use for including grid lines. By default grid lines are\ndriven by the same scale as the ticks and labels.\n",
        "type": "String -> Vega.AxisProperty"
      },
      {
        "name": "axGridWidth",
        "comment": " Width of an axis's grid lines in pixel units.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabelAlign",
        "comment": " Horizontal alignment of axis tick labels.\n",
        "type": "Vega.HAlign -> Vega.AxisProperty"
      },
      {
        "name": "axLabelAngle",
        "comment": " Angle of text for an axis.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabelBaseline",
        "comment": " Vertical alignment of axis tick labels.\n",
        "type": "Vega.VAlign -> Vega.AxisProperty"
      },
      {
        "name": "axLabelBound",
        "comment": " Indicate how or if labels should be hidden if they exceed the axis range. If the\nparameter is `NumNull`, no check for label size is made. A number specifies\nthe permitted overflow in pixels that can be tolerated.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabelColor",
        "comment": " Color of an axis label.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axLabelFlush",
        "comment": " Indicate how labels at the beginning or end of an axis should be aligned\nwith the scale range. The parameter represents a pixel distance threshold. Labels\nwith anchor coordinates within this threshold distance for an axis end-point will be\nflush-adjusted. If `NumNull`, no flush alignment will be applied.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabelFlushOffset",
        "comment": " Number of pixels by which to offset flush-adjusted labels.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabelFont",
        "comment": " Font name of an axis label.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axLabelFontSize",
        "comment": " Font size of an axis label.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabelFontWeight",
        "comment": " Font weight of an axis label. This can be a number (e.g. `vNum 300`)\nor text (e.g. `vStr \"bold\"`).\n",
        "type": "Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axLabelLimit",
        "comment": " Maximum length in pixels of axis tick labels.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabelOpacity",
        "comment": " Opacity of an axis label.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabelOverlap",
        "comment": " Strategy to use for resolving overlap of axis labels.\n",
        "type": "Vega.OverlapStrategy -> Vega.AxisProperty"
      },
      {
        "name": "axLabelPadding",
        "comment": " Padding in pixels between labels and ticks.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axLabels",
        "comment": " Whether or not if labels should be included as part of an axis.\n",
        "type": "Vega.Boo -> Vega.AxisProperty"
      },
      {
        "name": "axMaxExtent",
        "comment": " Maximum extent in pixels that axis ticks and labels should use.\n",
        "type": "Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axMinExtent",
        "comment": " The minimum extent in pixels that axis ticks and labels should use. This\ndetermines a minimum offset value for axis titles.\n",
        "type": "Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axOffset",
        "comment": " Orthogonal offset in pixels by which to displace the axis from its position\nalong the edge of the chart.\n",
        "type": "Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axPosition",
        "comment": " The anchor position of the axis in pixels. For x-axes with top or bottom\norientation, this sets the axis group x coordinate. For y-axes with left or right\norientation, this sets the axis group y coordinate.\n",
        "type": "Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axTemporalTickCount",
        "comment": " Tick interval for a temporal axis. The first parameter is the type of temporal\ninterval to use and the second the number of steps of that interval between ticks.\ne.g. to specify a tick is requested at 3 month intervals (January, April, July, October):\n\n    ax =\n        axes\n            << axis \"xScale\" SBottom [ axTemporalTickCount Month (num 3) ]\n\nIf the second parameter is not a positive value, the number of ticks will be\nauto-generated for the given interval type.\n\n",
        "type": "Vega.TimeUnit -> Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTickColor",
        "comment": " Color of an axis's ticks.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axTickCount",
        "comment": " Desired number of ticks, for axes visualizing quantitative scales. The\nresulting number may be different so that values are “nice” (multiples of 2, 5, 10)\nand lie within the underlying scale’s range.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTickExtra",
        "comment": " Whether or not an extra axis tick should be added for the initial\nposition of an axis. This is useful for styling axes for band scales such that\nticks are placed on band boundaries rather in the middle of a band.\n",
        "type": "Vega.Boo -> Vega.AxisProperty"
      },
      {
        "name": "axTickOffset",
        "comment": " Offset in pixels of an axis's ticks, labels and gridlines.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTickOpacity",
        "comment": " Opacity of an axis's ticks.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTickRound",
        "comment": " Whether or not pixel position values for an axis's ticks should be\nrounded to the nearest integer.\n",
        "type": "Vega.Boo -> Vega.AxisProperty"
      },
      {
        "name": "axTickSize",
        "comment": " Size in pixels of axis ticks.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTickWidth",
        "comment": " Width in pixels of an axis's ticks.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTicks",
        "comment": " Whether or not ticks should be included as part of an axis.\n",
        "type": "Vega.Boo -> Vega.AxisProperty"
      },
      {
        "name": "axTitle",
        "comment": " A title for an axis.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axTitleAlign",
        "comment": " Horizontal alignment of an axis's title.\n",
        "type": "Vega.HAlign -> Vega.AxisProperty"
      },
      {
        "name": "axTitleAngle",
        "comment": " Angle of an axis's title text.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTitleBaseline",
        "comment": " Vertical alignment of an axis's title.\n",
        "type": "Vega.VAlign -> Vega.AxisProperty"
      },
      {
        "name": "axTitleColor",
        "comment": " Color of an axis's title.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axTitleFont",
        "comment": " Font to be used for an axis's title.\n",
        "type": "Vega.Str -> Vega.AxisProperty"
      },
      {
        "name": "axTitleFontSize",
        "comment": " Size of font in pixels for an axis's title.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTitleFontWeight",
        "comment": " Font weight of an axis's title. This can be a number (e.g. `vNum 300`)\nor text (e.g. `vStr \"bold\"`).\n",
        "type": "Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axTitleLimit",
        "comment": " Maximum allowed length of an axis's title.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTitleOpacity",
        "comment": " Opacity of an axis's title.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTitlePadding",
        "comment": " Offset in pixels between an axis's labels and title.\n",
        "type": "Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axTitleX",
        "comment": " X position of an axis title relative to the axis group, overriding\nthe standard layout.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axTitleY",
        "comment": " Y position of an axis title relative to the axis group, overriding\nthe standard layout.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axValues",
        "comment": " Explicitly set an axis tick and label values.\n",
        "type": "Vega.Value -> Vega.AxisProperty"
      },
      {
        "name": "axZIndex",
        "comment": " The z-index indicating the layering of an axis group relative to other axis,\nmark and legend groups. The default value is 0 and axes and grid lines are drawn\nbehind any marks defined in the same specification level. Higher values (1) will\ncause axes and grid lines to be drawn on top of marks.\n",
        "type": "Vega.Num -> Vega.AxisProperty"
      },
      {
        "name": "axes",
        "comment": " Create the axes used to visualize spatial scale mappings.\n\n    ax =\n        axes\n            << axis \"myXScale\" SBottom [ axTitle (str \"Population\") ]\n            << axis \"myYScale\" SLeft [ axTickCount (num 5) ]\n\n",
        "type": "List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "axis",
        "comment": " Create an axis used to visualize a spatial scale mapping. The first\nparameter is the name of the scale backing this axis, the second the position of\nthe axis relative to the data rectangle and the third a list of optional axis\nproperties. For example,\n\n    axes\n        << axis \"xScale\" SBottom [ axTitle \"Population\", axZIndex (num 1) ]\n\n",
        "type": "String -> Vega.Side -> List Vega.AxisProperty -> List Vega.Spec -> List Vega.Spec"
      },
      {
        "name": "background",
        "comment": " The fill background color of a visualization. This should be specified as a\n[color string](https://vega.github.io/vega/docs/types/#Color).\n",
        "type": "Vega.Str -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "bcSignal",
        "comment": " Indicate that the bounds calculation type is to be determined by a named signal.\n",
        "type": "String -> Vega.BoundsCalculation"
      },
      {
        "name": "black",
        "comment": " Convenience function for specifying a black color setting for marks that can\nbe colored (e.g. with [maStroke](#maStroke))\n",
        "type": "Vega.Value"
      },
      {
        "name": "bnAnchor",
        "comment": " Value in the binned domain at which to anchor the bins of a bin\ntransform, shifting the bin boundaries if necessary to ensure that a boundary aligns\nwith the anchor value. If not specified, the minimum bin extent value serves as\nthe anchor.\n",
        "type": "Vega.Num -> Vega.BinProperty"
      },
      {
        "name": "bnAs",
        "comment": " Output field names to contain the extent of a binning transform (start and end\nbin values). If not specified these can be retrieved as `bin0` and `bin1`.\n",
        "type": "String -> String -> Vega.BinProperty"
      },
      {
        "name": "bnBase",
        "comment": " Number base to use for automatic bin determination in a bin transform (default\nis base 100).\n",
        "type": "Vega.Num -> Vega.BinProperty"
      },
      {
        "name": "bnDivide",
        "comment": " Allowable bin step sub-divisions when performing a binning transformation.\nThe parameter should evaluate to a list of numeric values. If not specified, the\ndefault of [5, 2] is used, which indicates that for base 10 numbers automatic bin\ndetermination can consider dividing bin step sizes by 5 and/or 2.\n",
        "type": "Vega.Num -> Vega.BinProperty"
      },
      {
        "name": "bnMaxBins",
        "comment": " Maximum number of bins to create with a bin transform.\n",
        "type": "Vega.Num -> Vega.BinProperty"
      },
      {
        "name": "bnMinStep",
        "comment": " Minimum allowable bin step size between bins when performing a bin transform.\n",
        "type": "Vega.Num -> Vega.BinProperty"
      },
      {
        "name": "bnNice",
        "comment": " Whether or not the bin boundaries in a binning transform will use human-friendly\nvalues such as multiples of ten.\n",
        "type": "Vega.Boo -> Vega.BinProperty"
      },
      {
        "name": "bnSignal",
        "comment": " Bind the specification of a binning transform (its start, step and stop properties)\nto a signal with the given name.\n",
        "type": "String -> Vega.BinProperty"
      },
      {
        "name": "bnStep",
        "comment": " Step size to use between bins in a bin transform.\n",
        "type": "Vega.Num -> Vega.BinProperty"
      },
      {
        "name": "bnSteps",
        "comment": " Allowable step sizes between bins to choose from when performing a bin transform.\n",
        "type": "Vega.Num -> Vega.BinProperty"
      },
      {
        "name": "booExpr",
        "comment": " Eexpression that when evaluated, will be a Boolean value.\n",
        "type": "Vega.Expr -> Vega.Boo"
      },
      {
        "name": "booSignal",
        "comment": " Name of a signal that will generate a Boolean value.\n",
        "type": "String -> Vega.Boo"
      },
      {
        "name": "booSignals",
        "comment": " List of signals that will generate Boolean values.\n",
        "type": "List String -> Vega.Boo"
      },
      {
        "name": "boos",
        "comment": " List of Boolean literals.\n",
        "type": "List Bool -> Vega.Boo"
      },
      {
        "name": "cHCL",
        "comment": " Define a color in HCL space (parameters in H - C - L order).\n",
        "type": "List Vega.Value -> List Vega.Value -> List Vega.Value -> Vega.ColorValue"
      },
      {
        "name": "cHSL",
        "comment": " Define a color in HSL space (parameters in H - S - L order).\n",
        "type": "List Vega.Value -> List Vega.Value -> List Vega.Value -> Vega.ColorValue"
      },
      {
        "name": "cLAB",
        "comment": " Define a color in CIELab space (parameters in L - A - B order).\n",
        "type": "List Vega.Value -> List Vega.Value -> List Vega.Value -> Vega.ColorValue"
      },
      {
        "name": "cRGB",
        "comment": " Color in RGB space.\n",
        "type": "List Vega.Value -> List Vega.Value -> List Vega.Value -> Vega.ColorValue"
      },
      {
        "name": "cfAutosize",
        "comment": " Default autosizing properties of view.\n",
        "type": "List Vega.Autosize -> Vega.ConfigProperty"
      },
      {
        "name": "cfAxis",
        "comment": " Default properties of axes.\n",
        "type": "Vega.AxisType -> List Vega.AxisProperty -> Vega.ConfigProperty"
      },
      {
        "name": "cfBackground",
        "comment": " Default background of the view.\n",
        "type": "Vega.Str -> Vega.ConfigProperty"
      },
      {
        "name": "cfEvents",
        "comment": " Default filtering of events. This can specified in the first parameter\nas either a 'whitelist' (`Allow`) or 'blacklist' (`Prevent`) comprised the event types\nto be considered in the second parameter. If that list is empty, all event types\nwill be placed in the black/white list.\n",
        "type": "Vega.EventFilter -> List Vega.EventType -> Vega.ConfigProperty"
      },
      {
        "name": "cfGroup",
        "comment": " Default properties of the top-level group mark representing the\ndata rectangle of a chart.\n",
        "type": "List Vega.MarkProperty -> Vega.ConfigProperty"
      },
      {
        "name": "cfLegend",
        "comment": " Default properties of legends.\n",
        "type": "List Vega.LegendProperty -> Vega.ConfigProperty"
      },
      {
        "name": "cfMark",
        "comment": " Default properties of a given mark type.\n",
        "type": "Vega.Mark -> List Vega.MarkProperty -> Vega.ConfigProperty"
      },
      {
        "name": "cfMarks",
        "comment": " Default properties of all marks.\n",
        "type": "List Vega.MarkProperty -> Vega.ConfigProperty"
      },
      {
        "name": "cfScaleRange",
        "comment": " Create a named range to be used as part of a scale specification.\nThe first parameter is the named range label (e.g. `RaOrdinal`, `RaCategory`, etc.).\nThe second is the new range of values to be associated with this range.\n\n    cf =\n        config [ cfScaleRange RaHeatmap (raScheme (str \"greenblue\") []) ]\n\n",
        "type": "Vega.ScaleRange -> Vega.ScaleRange -> Vega.ConfigProperty"
      },
      {
        "name": "cfStyle",
        "comment": " Create a named style. The first parameter is the name to give the style, the\nsecond its mark properties.\n",
        "type": "String -> List Vega.MarkProperty -> Vega.ConfigProperty"
      },
      {
        "name": "cfTitle",
        "comment": " Default properties of a title.\n",
        "type": "List Vega.TitleProperty -> Vega.ConfigProperty"
      },
      {
        "name": "clEnabled",
        "comment": " Whether or not clipping should be applied to a set of marks within a group mark.\n",
        "type": "Vega.Boo -> Vega.Clip"
      },
      {
        "name": "clPath",
        "comment": " Clipping path to be applied to a set of marks within a region. Should be a valid\n[SVG path string](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).\n",
        "type": "Vega.Str -> Vega.Clip"
      },
      {
        "name": "clSphere",
        "comment": " Clip a spherical outline subject to a given map projection name. This is useful\nin conjunction with map projections that include content such as graticule lines\noutside the bounds of the globe.\n",
        "type": "Vega.Str -> Vega.Clip"
      },
      {
        "name": "cnBandwidth",
        "comment": " Kernel density estimation bandwidth used in a contour transformation.\n",
        "type": "Vega.Num -> Vega.ContourProperty"
      },
      {
        "name": "cnCellSize",
        "comment": " Size of cells used for density estimation in a contour transformation.\n",
        "type": "Vega.Num -> Vega.ContourProperty"
      },
      {
        "name": "cnCount",
        "comment": " Desired number of contours used in a contour transformation. Ignored if `cnThresholds`\nsetting explicit contour values are provided.\n",
        "type": "Vega.Num -> Vega.ContourProperty"
      },
      {
        "name": "cnNice",
        "comment": " Whether or not contour threshold values should be automatically aligned to\n'nice', human-friendly values when performing a contour transformation.\n",
        "type": "Vega.Boo -> Vega.ContourProperty"
      },
      {
        "name": "cnSmooth",
        "comment": " Whether or not contour polygons should be smoothed in a contour transformation.\nIgnored if kernel density estimation is used.\n",
        "type": "Vega.Boo -> Vega.ContourProperty"
      },
      {
        "name": "cnThresholds",
        "comment": " Explicit contour values to be generated by a contour transformation.\n",
        "type": "Vega.Num -> Vega.ContourProperty"
      },
      {
        "name": "cnValues",
        "comment": " Grid of values over which to compute contours. If not provided, [trContour](#trContour)\nwill compute contours of the kernel density estimate of input data instead.\n",
        "type": "Vega.Num -> Vega.ContourProperty"
      },
      {
        "name": "cnX",
        "comment": " X-coordinate field used for density estimation in a contour transformation.\n",
        "type": "Vega.Field -> Vega.ContourProperty"
      },
      {
        "name": "cnY",
        "comment": " Y-coordinate field used for density estimation in a contour transformation.\n",
        "type": "Vega.Field -> Vega.ContourProperty"
      },
      {
        "name": "combineSpecs",
        "comment": " Combine a list of labelled specifications into a single specification that\nmay be passed to JavaScript for rendering. Useful for creating a single page with\nmultiple visualizations.\n\n    combineSpecs\n        [ ( \"vis1\", myFirstVis )\n        , ( \"vis2\", mySecondVis )\n        , ( \"vis3\", myOtherVis )\n        ]\n\n",
        "type": "List Vega.LabelledSpec -> Vega.Spec"
      },
      {
        "name": "config",
        "comment": " Create a collection of configuration settings. This allows default stylings\nto be defined for a collection of visualizations or visualization components.\n\n    cf =\n        config\n            [ cfMark Text [ maFont [ vStr \"Roboto Condensed, sans-serif\" ] ]\n            , cfTitle\n                [ tiFont (str \"Roboto Condensed, sans-serif\")\n                , tiFontWeight (vNum 500)\n                , tiFontSize (num 17)\n                ]\n            , cfAxis AxAll\n                [ axLabelFont (str \"Roboto Condensed, sans-serif\")\n                , axLabelFontSize (num 12)\n                ]\n            ]\n\n",
        "type": "List Vega.ConfigProperty -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "cpAs",
        "comment": " Names the two output fields generated by a count pattern transformation.\nBy default they are named `text` and `count`.\n",
        "type": "String -> String -> Vega.CountPatternProperty"
      },
      {
        "name": "cpCase",
        "comment": " Text case transformation to apply before performing a count pattern transformation.\nThe default of `Mixedcase` will leave text untransformed.\n",
        "type": "Vega.Case -> Vega.CountPatternProperty"
      },
      {
        "name": "cpPattern",
        "comment": " Define a match in a count pattern transformation with a regular expression\n(escaping backslashes):\n\n    transform [ trCountPattern (field \"data\") [ cpPattern (str \"[\\\\w']{3,}\") ] ]\n\n",
        "type": "Vega.Str -> Vega.CountPatternProperty"
      },
      {
        "name": "cpStopwords",
        "comment": " Define text to ignore in a count pattern transformation with a regular\nexpression (escaping backslashes).\n",
        "type": "Vega.Str -> Vega.CountPatternProperty"
      },
      {
        "name": "crAs",
        "comment": " Name the two output fields of a cross-product transform.\n",
        "type": "String -> String -> Vega.CrossProperty"
      },
      {
        "name": "crFilter",
        "comment": " Filter for limiting the results of a cross-product transform.\n",
        "type": "Vega.Expr -> Vega.CrossProperty"
      },
      {
        "name": "csCount",
        "comment": " Number of colors to use in a color scheme.\n",
        "type": "Vega.Num -> Vega.ColorSchemeProperty"
      },
      {
        "name": "csExtent",
        "comment": " Extent of the color range to use in sequential and diverging color\nschemes. The parameter should evaluate to a two-element list representing the min\nand max values of the extent. For example [0.2, 1] will rescale the color scheme\nsuch that color values in the range [0, 0.2] are excluded from the scheme.\n",
        "type": "Vega.Num -> Vega.ColorSchemeProperty"
      },
      {
        "name": "csScheme",
        "comment": " Name a color scheme to use.\n",
        "type": "Vega.Str -> Vega.ColorSchemeProperty"
      },
      {
        "name": "cubeHelix",
        "comment": " Cube helix color interpolation using the given gamma value (anchored at 1).\n",
        "type": "Float -> Vega.CInterpolate"
      },
      {
        "name": "cubeHelixLong",
        "comment": " A long path cube-helix color interpolation using the given gamma value (anchored at 1).\n",
        "type": "Float -> Vega.CInterpolate"
      },
      {
        "name": "cursorValue",
        "comment": " A convenience function for generating a text value representing a given cursor\ntype.\n",
        "type": "Vega.Cursor -> Vega.Value"
      },
      {
        "name": "daDataset",
        "comment": " Reference a dataset with the given name.\n",
        "type": "String -> Vega.DataReference"
      },
      {
        "name": "daField",
        "comment": " Reference a data field with the given value.\n",
        "type": "Vega.Field -> Vega.DataReference"
      },
      {
        "name": "daFields",
        "comment": " Reference a collection of data fields with the given values.\n",
        "type": "List Vega.Field -> Vega.DataReference"
      },
      {
        "name": "daFormat",
        "comment": " Data format to use when loading or generating a dataset.\n",
        "type": "List Vega.FormatProperty -> Vega.DataProperty"
      },
      {
        "name": "daOn",
        "comment": " Updates to insert, remove, and toggle data values, or clear the data in a\ndataset when trigger conditions are met.\n",
        "type": "List Vega.Trigger -> Vega.DataProperty"
      },
      {
        "name": "daReferences",
        "comment": " Reference a collection of nested data references.\n",
        "type": "List (List Vega.DataReference) -> Vega.DataReference"
      },
      {
        "name": "daSignal",
        "comment": " Make a data reference with a signal.\n",
        "type": "String -> Vega.DataReference"
      },
      {
        "name": "daSort",
        "comment": " Sort a data reference.\n",
        "type": "List Vega.SortProperty -> Vega.DataReference"
      },
      {
        "name": "daSource",
        "comment": " Name a data source when generating a dataset.\n",
        "type": "String -> Vega.DataProperty"
      },
      {
        "name": "daSources",
        "comment": " Name a collection of data sources when generating a dataset.\n",
        "type": "List String -> Vega.DataProperty"
      },
      {
        "name": "daUrl",
        "comment": " Data file to be loaded when generating a dataset.\n",
        "type": "Vega.Str -> Vega.DataProperty"
      },
      {
        "name": "daValue",
        "comment": " Data value(s) for generating a dataset inline.\n",
        "type": "Vega.Value -> Vega.DataProperty"
      },
      {
        "name": "daValues",
        "comment": " Create a data reference from a list of literals. Useful when combining with\ndata references from existing data streams. For example\n\n    scale \"myScale\"\n      [ scDomain\n          (doData\n              [ daReferences\n                  [ [ daValues (vNums [ 2, 4 ]) ]\n                  , [ daDataset \"myData\", daField (field \"myField\") ]\n                  ]\n              ]\n          )\n      ]\n\n",
        "type": "Vega.Value -> Vega.DataReference"
      },
      {
        "name": "data",
        "comment": " Declare a named dataset. Depending on the properties provided this may be\nfrom an external file, from a named data source or inline literal values.\n",
        "type": "String -> List Vega.DataProperty -> Vega.DataTable"
      },
      {
        "name": "dataColumn",
        "comment": " Create a column of data. A column has a name and a list of values. The final\nparameter is the list of any other columns to which this is added.\n",
        "type": "String -> Vega.Value -> List Vega.DataColumn -> List Vega.DataColumn"
      },
      {
        "name": "dataFromColumns",
        "comment": " Declare a data table from a list of column values. Each column contains values\nof the same type, but types may vary between columns. Columns should all contain\nthe same number of items; if not the dataset will be truncated to the length of\nthe shortest.\n\nThe first parameter should be the name given to the data table for later reference.\nField formatting specifications can be provided in the second parameter or as an\nempty list to use the default formatting. The columns are most easily generated\nwith `dataColumn`.\n\n",
        "type": "String -> List Vega.FormatProperty -> List Vega.DataColumn -> Vega.DataTable"
      },
      {
        "name": "dataFromRows",
        "comment": " Declare a data table from a list of row values. Each row is specified with a\nlist of tuples where the first value is the column name, and the second the column\nvalue for that row. Each column can have a value of a different type but you must\nensure that when multiple rows are added, they match the types of other values in\nthe same column. Field formatting specifications can be provided in the first\nparameter or as an empty list to use the default formatting.\n\nRows are most easily generated with `dataRow`. If you are creating data inline\n(as opposed to reading from a file), generally, adding data by column is more\nefficient and less error-prone.\n\n",
        "type": "String -> List Vega.FormatProperty -> List Vega.DataRow -> Vega.DataTable"
      },
      {
        "name": "dataRow",
        "comment": " Create a row of data. A row comprises a list of (_columnName_, _value_) pairs.\nThe final parameter is the list of any other rows to which this is added.\n",
        "type": "List ( String, Vega.Value ) -> List Vega.DataRow -> List Vega.DataRow"
      },
      {
        "name": "dataSource",
        "comment": " Data source to be used by a visualization. A data source is a collection of\ndata tables which themselves may be generated inline, loaded from a URL or the\nresult of a transformation.\n",
        "type": "List Vega.DataTable -> Vega.Data"
      },
      {
        "name": "densityFunctionSignal",
        "comment": " Density function referenced by the value in the named signal.\n",
        "type": "String -> Vega.DensityFunction"
      },
      {
        "name": "diKde",
        "comment": " Kernel density estimate (smoothed probability distribution) for a set of\nnumerical values. The first parameter is the dataset containing\nthe source data, the second the name of the field containing the numerical values\nand the third the kernel bandwidth. If the bandwidth is 0, it will be estimated\nfrom the input data.\n",
        "type": "String -> Vega.Field -> Vega.Num -> Vega.Distribution"
      },
      {
        "name": "diMixture",
        "comment": " Weighted mixture of probability distributions. The parameter should be a list\nof tuples representing the component distributions and their corresponding weights.\n",
        "type": "List ( Vega.Distribution, Vega.Num ) -> Vega.Distribution"
      },
      {
        "name": "diNormal",
        "comment": " Normal (Gaussian) probability distribution with a given mean (first parameter)\nand standard deviation (second parameter).\n",
        "type": "Vega.Num -> Vega.Num -> Vega.Distribution"
      },
      {
        "name": "diUniform",
        "comment": " Uniform probability distribution with given minimum (first parameter) and\nmaximum (second parameter) bounds.\n",
        "type": "Vega.Num -> Vega.Num -> Vega.Distribution"
      },
      {
        "name": "dnAs",
        "comment": " Fields to contain a density transform's values (assigned to a new field named\nin the first parameter) and probabilities (field named in the second parameter).\nIf not specified, the output will allocated to fields named `value` and `probability`.\n",
        "type": "String -> String -> Vega.DensityProperty"
      },
      {
        "name": "dnExtent",
        "comment": " A [min, max] domain from which to sample a distribution in a density transform.\n",
        "type": "Vega.Num -> Vega.DensityProperty"
      },
      {
        "name": "dnMethod",
        "comment": " Type of distribution to generate in a density transform.\n",
        "type": "Vega.DensityFunction -> Vega.DensityProperty"
      },
      {
        "name": "dnSteps",
        "comment": " Number of uniformly spaced steps to take along an extent domain in a density transform.\n",
        "type": "Vega.Num -> Vega.DensityProperty"
      },
      {
        "name": "doData",
        "comment": " Data reference object specifying field values in one or more datasets to\ndefine a scale domain.\n",
        "type": "List Vega.DataReference -> Vega.ScaleDomain"
      },
      {
        "name": "doNums",
        "comment": " List of numeric values (`Nums`) representing a scale domain.\n",
        "type": "Vega.Num -> Vega.ScaleDomain"
      },
      {
        "name": "doSignal",
        "comment": " Scale domain referenced by the value in the named signal.\n",
        "type": "String -> Vega.ScaleDomain"
      },
      {
        "name": "doSignals",
        "comment": " Scale domains referenced by the values in the named signals.\n",
        "type": "List String -> Vega.ScaleDomain"
      },
      {
        "name": "doStrs",
        "comment": " List of strings (`Strs`) representing a scale domain.\n",
        "type": "Vega.Str -> Vega.ScaleDomain"
      },
      {
        "name": "dsv",
        "comment": " DSV (delimited separated value) format with a custom delimiter.\n",
        "type": "Vega.Str -> Vega.FormatProperty"
      },
      {
        "name": "enCustom",
        "comment": " Named custom encoding set. Also requires a signal event handler with an\n`encode` directive.\n",
        "type": "String -> List Vega.MarkProperty -> Vega.EncodingProperty"
      },
      {
        "name": "enEnter",
        "comment": " Properties to be encoded when a mark item is first instantiated or resized.\n",
        "type": "List Vega.MarkProperty -> Vega.EncodingProperty"
      },
      {
        "name": "enExit",
        "comment": " Properties to be encoded when the data backing a mark item is removed.\n",
        "type": "List Vega.MarkProperty -> Vega.EncodingProperty"
      },
      {
        "name": "enGradient",
        "comment": " Custom encoding for gradient (continuous) legends.\n",
        "type": "List Vega.EncodingProperty -> Vega.LegendEncoding"
      },
      {
        "name": "enHover",
        "comment": " Properties to be encoded when a pointer hovers over a mark item.\n",
        "type": "List Vega.MarkProperty -> Vega.EncodingProperty"
      },
      {
        "name": "enInteractive",
        "comment": " Whether or not a custom legend encoding set is to be interactive.\n",
        "type": "Vega.Boo -> Vega.EncodingProperty"
      },
      {
        "name": "enLabels",
        "comment": " Custom encoding for legend labels.\n",
        "type": "List Vega.EncodingProperty -> Vega.LegendEncoding"
      },
      {
        "name": "enLegend",
        "comment": " Custom encoding for a legend group mark.\n",
        "type": "List Vega.EncodingProperty -> Vega.LegendEncoding"
      },
      {
        "name": "enName",
        "comment": " Name for a custom legend encoding set.\n",
        "type": "String -> Vega.EncodingProperty"
      },
      {
        "name": "enSymbols",
        "comment": " Custom encoding for symbol (discrete) legends.\n",
        "type": "List Vega.EncodingProperty -> Vega.LegendEncoding"
      },
      {
        "name": "enTitle",
        "comment": " Custom ecoding for a legend title.\n",
        "type": "List Vega.EncodingProperty -> Vega.LegendEncoding"
      },
      {
        "name": "enUpdate",
        "comment": " Properties to be encoded when a mark item is updated such as in response to\na signal change.\n",
        "type": "List Vega.MarkProperty -> Vega.EncodingProperty"
      },
      {
        "name": "encode",
        "comment": " Encoding directives for the visual properties of the top-level group mark\nrepresenting a chart’s data rectangle. For example, this can be used to set a\nbackground fill color for the plotting area, rather than the entire view.\n",
        "type": "List Vega.EncodingProperty -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "esBetween",
        "comment": " Event stream filter that lets only events that occur between the two given event\nstreams from being handled. Useful for capturing pointer dragging as it is a pointer\nmovement event stream that occurs between `MouseDown` and `MouseUp` events.\n\n    << signal \"myDrag\"\n        [ siValue (vNums [ 200, 200 ])\n        , siOn\n            [ evHandler\n                [esObject\n                    [ esBetween [ esMark Rect, esType MouseDown ] [ esSource ESView, esType MouseUp ]\n                    , esSource ESView\n                    , esType MouseMove\n                    ]\n                ]\n                [ evUpdate \"xy()\" ]\n            ]\n        ]\n\nThis is equivalent to the more compact, but more error-prone event stream selector:\n\n    esSelector (str \"[rect:mousedown, view:mouseup] > view:mousemove\")\n\n",
        "type": "List Vega.EventStreamProperty -> List Vega.EventStreamProperty -> Vega.EventStreamProperty"
      },
      {
        "name": "esConsume",
        "comment": " Whether or not an event stream is consumed once it has been captured. If false,\nthe event is made available for subsequent event handling.\n",
        "type": "Vega.Boo -> Vega.EventStreamProperty"
      },
      {
        "name": "esDebounce",
        "comment": " Minimum time to wait between event occurrence and processing. If a new event\narrives during a debouncing window, the timer will restart and only the new event\nwill be captured.\n",
        "type": "Vega.Num -> Vega.EventStreamProperty"
      },
      {
        "name": "esDom",
        "comment": " DOM node to be the source for an event selector. Referenced with a standard\n[CSS selector](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors).\n",
        "type": "String -> Vega.EventSource"
      },
      {
        "name": "esFilter",
        "comment": " Predicate expressions that must all evaluate to `True` for an event to be captured.\n",
        "type": "List String -> Vega.EventStreamProperty"
      },
      {
        "name": "esMark",
        "comment": " Mark type to be the source for an event stream.\n",
        "type": "Vega.Mark -> Vega.EventStreamProperty"
      },
      {
        "name": "esMarkName",
        "comment": " Named mark to be the source for an event stream. The name given here\nmust correspond to that provided via `mName`.\n",
        "type": "String -> Vega.EventStreamProperty"
      },
      {
        "name": "esMerge",
        "comment": " Merge a list of event streams into a single stream.\n",
        "type": "List Vega.EventStream -> Vega.EventStream"
      },
      {
        "name": "esObject",
        "comment": " Event stream for modelling user input. The parameter represents a stream object\nwhich provides a more self-explanatory and robust form of specification than using\na selector string.\n",
        "type": "List Vega.EventStreamProperty -> Vega.EventStream"
      },
      {
        "name": "esSelector",
        "comment": " Compact representation of an event stream for modelling user input (alternative\nto [esObject](#esObject)).\n",
        "type": "Vega.Str -> Vega.EventStream"
      },
      {
        "name": "esSignal",
        "comment": " Signal that triggers an event stream. Allows an update to be triggered whenever\nthe given signal changes.\n",
        "type": "String -> Vega.EventStream"
      },
      {
        "name": "esSource",
        "comment": " Source for an event selector.\n",
        "type": "Vega.EventSource -> Vega.EventStreamProperty"
      },
      {
        "name": "esStream",
        "comment": " Event stream to be used as input into a derived event stream. Useful if several\nevent streams have a common element:\n\n    si =\n        let\n            esStart =\n                esMerge\n                    [ esObject [ esType MouseDown ]\n                    , esObject [ esType TouchStart ]\n                    ]\n\n            esEnd =\n                esObject [ esType TouchEnd ]\n        in\n        signals\n            << signal \"down\"\n                [ siValue vNull\n                , siOn\n                    [ evHandler [ esEnd ] [ evUpdate \"null\" ]\n                    , evHandler [ esStart ] [ evUpdate \"xy()\" ]\n                    ]\n                ]\n            << signal \"xCur\"\n                [ siValue vNull\n                , siOn\n                    [ evHandler [ esObject [ esStream esStart, esType TouchEnd ] ]\n                        [ evUpdate \"slice(xDom)\" ]\n                    ]\n                ]\n\n",
        "type": "Vega.EventStream -> Vega.EventStreamProperty"
      },
      {
        "name": "esThrottle",
        "comment": " Minimum time in milliseconds between captured events. New events that arrive\nwithin the throttling window will be ignored. For timer events, this determines\nthe interval between timer ticks.\n",
        "type": "Vega.Num -> Vega.EventStreamProperty"
      },
      {
        "name": "esType",
        "comment": " Type of event stream for handling user interaction events.\n",
        "type": "Vega.EventType -> Vega.EventStreamProperty"
      },
      {
        "name": "evEncode",
        "comment": " Name of a mark property encoding set to re-evaluate for the mark that is the\nsource of an input event. This is required if `evUpdate` is not specified.\n",
        "type": "String -> Vega.EventHandler"
      },
      {
        "name": "evForce",
        "comment": " Whether or not updates that do not change a signal value should propagate.\ne.g., if true and an input stream update sets the signal to its current value,\ndownstream signals will be notified of an update.\n",
        "type": "Vega.Boo -> Vega.EventHandler"
      },
      {
        "name": "evHandler",
        "comment": " Event handler. The first parameter is the stream(s) of events to\nrespond to. The second, a list of handlers that respond to the event stream.\n\n    signal \"tooltip\"\n        [ siValue (vObject [])\n        , siOn\n            [ evHandler [esObject [esMark Rect, esType MouseOver] ] [ evUpdate \"datum\" ]\n            , evHandler [esObject [esMark Rect, esType MouseOut] ] [ evUpdate \"\" ]\n            ]\n        ]\n\n",
        "type": "List Vega.EventStream -> List Vega.EventHandler -> List Vega.EventHandler"
      },
      {
        "name": "evStreamSelector",
        "comment": " Event selector used to generate an event stream.\n",
        "type": "Vega.Str -> Vega.EventStream"
      },
      {
        "name": "evUpdate",
        "comment": " Expression to be evaluated when an event occurs, the result of which becomes\nthe new signal value.\n",
        "type": "String -> Vega.EventHandler"
      },
      {
        "name": "exField",
        "comment": " Field lookup that forms a Vega [Expr](https://vega.github.io/vega/docs/types/#Expr).\nIn contrast to an expression generated by `expr`, a field lookup is applied once\nto an entire field rather than evaluated once per datum.\n",
        "type": "String -> Vega.Expr"
      },
      {
        "name": "expr",
        "comment": " Expression to enable custom calculations specified in the [Vega expression\nlanguage](https://vega.github.io/vega/docs/expressions). In contrast to a field\nreference or signal, the expression is evaluated once per datum behaving like an\nanonymous (lambda) function.\n",
        "type": "String -> Vega.Expr"
      },
      {
        "name": "fDatum",
        "comment": " Perform a lookup on the current data object using the given field.\nOnce evaluated this is similar to simply providing a string value.\n",
        "type": "Vega.Field -> Vega.Field"
      },
      {
        "name": "fExpr",
        "comment": " Expression that references a field but can perform calculations on each datum\nin the field.\n\n    fExpr \"scale('xScale', datum.Horsepower)\"\n\n",
        "type": "String -> Vega.Field"
      },
      {
        "name": "fGroup",
        "comment": " Property of the enclosing group mark instance as a field value.\n",
        "type": "Vega.Field -> Vega.Field"
      },
      {
        "name": "fParent",
        "comment": " Field of the enclosing group mark’s data object as a field.\n",
        "type": "Vega.Field -> Vega.Field"
      },
      {
        "name": "fSignal",
        "comment": " Field referenced by the value in the named signal.\n",
        "type": "String -> Vega.Field"
      },
      {
        "name": "faAggregate",
        "comment": " For data-driven facets, a list aggregate transform properties for the\naggregate data values generated for each facet group item.\n",
        "type": "List Vega.AggregateProperty -> Vega.Facet"
      },
      {
        "name": "faField",
        "comment": " For pre-faceted data, the name of the data field containing a list of data\nvalues to use as the local partition. This is required if using pre-faceted data.\n",
        "type": "Vega.Field -> Vega.Facet"
      },
      {
        "name": "faGroupBy",
        "comment": " For data-driven facets, specify a list of field names by which to partition\nthe data. This is required if using pre-faceted data.\n",
        "type": "List Vega.Field -> Vega.Facet"
      },
      {
        "name": "false",
        "comment": " A Boolean false value.\n",
        "type": "Vega.Boo"
      },
      {
        "name": "feName",
        "comment": " Name of a geoJSON feature. Can be used with [prFit](#prFit) to fit a map\nprojection scaling and centre to a given geoJSON feature or feature collection.\n\n    pr =\n        projections\n            << projection \"myProjection\"\n                [ prType Orthographic\n                , prSize (numSignal \"[width,height]\")\n                , prFit (feName \"mapData\")\n                ]\n\n",
        "type": "String -> Vega.Feature"
      },
      {
        "name": "featureSignal",
        "comment": " geoJSON feature referenced by the value in the named signal. Can be used with\n[prFit](#prFit) to fit a map projection scaling and centre to a given geoJSON\nfeature or feature collection.\n\n    ds =\n        dataSource\n            [ data \"myLongLatData\" []\n                |> transform\n                    [ trGeoJson\n                        [ gjFields (field \"longitude\") (field \"latitude\")\n                        , gjSignal \"feature\"\n                        ]\n                    ]\n            ]\n\n    pr =\n        projections\n            << projection \"myProjection\"\n                [ prType Orthographic\n                , prSize (numSignal \"[width,height]\")\n                , prFit (featureSignal \"feature\")\n                ]\n\n",
        "type": "String -> Vega.Feature"
      },
      {
        "name": "field",
        "comment": " Name of a field to reference.\n",
        "type": "String -> Vega.Field"
      },
      {
        "name": "foCenter",
        "comment": " Force that pulls all nodes towards a shared centre point in a force\nsimulation. The two parameters specify the x and y coordinates of the centre point.\n",
        "type": "Vega.Num -> Vega.Num -> Vega.Force"
      },
      {
        "name": "foCollide",
        "comment": " Collision detection force that pushes apart nodes whose circular radii overlap\nin a force simulation. The first parameter specifies the radius of\nthe node to which it applies. The second enables the strength and number of\niterations to be specified.\n",
        "type": "Vega.Num -> List Vega.ForceProperty -> Vega.Force"
      },
      {
        "name": "foDate",
        "comment": " Date format for parsing data using\n[D3's formatting specifiers](https://github.com/d3/d3-time-format#locale_format).\n",
        "type": "String -> Vega.DataType"
      },
      {
        "name": "foLink",
        "comment": " Link constraints that cause nodes to be pushed apart towards a target separation\ndistance in a force simulation. The first parameter is the name of the dataset\ncontaining the link objects, each of which should contain `source` and `target`\nfields. The second enables the id, distance, strength and number\nof iterations to be specified. If an id field parameter is provided, it is used\nto relate link objects and node objects. Otherwise, the source and target fields\nshould provide indices into the array of node objects.\n",
        "type": "Vega.Str -> List Vega.ForceProperty -> Vega.Force"
      },
      {
        "name": "foNBody",
        "comment": " n-body force that causes nodes to either attract or repel each other\nin a force simulation. The parameter enables the strength, theta value, and min/max\ndistances over which the force acts to be specified.\n",
        "type": "List Vega.ForceProperty -> Vega.Force"
      },
      {
        "name": "foUtc",
        "comment": " UTC date format for parsing data using\n[D3's formatting specifiers](https://github.com/d3/d3-time-format#locale_format).\n",
        "type": "String -> Vega.DataType"
      },
      {
        "name": "foX",
        "comment": " Force attraction towards a particular x-coordinate (first parameter), with a\ngiven strength (second parameter) on a per-node basis.\n",
        "type": "Vega.Field -> List Vega.ForceProperty -> Vega.Force"
      },
      {
        "name": "foY",
        "comment": " Force attraction towards a particular y-coordinate (first parameter), with a\ngiven strength (second parameter) on a per-node basis.\n",
        "type": "Vega.Field -> List Vega.ForceProperty -> Vega.Force"
      },
      {
        "name": "formatPropertySignal",
        "comment": " Format referenced by the value in the named signal (e.g. `csv`, `tsv`, `json`).\nUseful when dynamic loading of data with different formats is required.\n",
        "type": "String -> Vega.FormatProperty"
      },
      {
        "name": "fpDistance",
        "comment": " Distance in pixels by which the link constraint should separate\nnodes (default 30).\n",
        "type": "Vega.Num -> Vega.ForceProperty"
      },
      {
        "name": "fpDistanceMax",
        "comment": " Maximum distance over which an n-body force acts. If two nodes\nexceed this value, they will not exert forces on each other.\n",
        "type": "Vega.Num -> Vega.ForceProperty"
      },
      {
        "name": "fpDistanceMin",
        "comment": " Minimum distance over which an n-body force acts. If two nodes\nare closer than this value, the exerted forces will be as if they are distanceMin\napart (default 1).\n",
        "type": "Vega.Num -> Vega.ForceProperty"
      },
      {
        "name": "fpId",
        "comment": " Data field for a node’s unique identifier. If provided, the source and target\nfields of each link should use these values to indicate nodes.\n",
        "type": "Vega.Field -> Vega.ForceProperty"
      },
      {
        "name": "fpIterations",
        "comment": " Number of iterations to run collision detection or link constraints (default 1)\nin a force directed simulation.\n",
        "type": "Vega.Num -> Vega.ForceProperty"
      },
      {
        "name": "fpStrength",
        "comment": " Relative strength of a force or link constraint in a force simulation.\n",
        "type": "Vega.Num -> Vega.ForceProperty"
      },
      {
        "name": "fpTheta",
        "comment": " Approximation parameter for aggregating more distance forces in a force-directed\nsimulation (default 0.9).\n",
        "type": "Vega.Num -> Vega.ForceProperty"
      },
      {
        "name": "fsAlpha",
        "comment": " Energy level or “temperature” of a simulation under a force transform. Alpha\nvalues lie in the range [0, 1]. Internally, the simulation will decrease the alpha\nvalue over time, causing the magnitude of updates to diminish.\n",
        "type": "Vega.Num -> Vega.ForceSimulationProperty"
      },
      {
        "name": "fsAlphaMin",
        "comment": " Minimum amount by which to lower the alpha value on each simulation iteration\nunder a force transform.\n",
        "type": "Vega.Num -> Vega.ForceSimulationProperty"
      },
      {
        "name": "fsAlphaTarget",
        "comment": " Target alpha value to which a simulation converges under a force transformation.\n",
        "type": "Vega.Num -> Vega.ForceSimulationProperty"
      },
      {
        "name": "fsAs",
        "comment": " Names of the output fields to which node positions and velocities are written\nafter a force transformation. The default is [\"x\", \"y\", \"vx\", \"vy\"] corresponding\nto the order of parameter names.\n",
        "type": "String -> String -> String -> String -> Vega.ForceSimulationProperty"
      },
      {
        "name": "fsForces",
        "comment": " Forces to include in a force-directed simulation resulting from a force transform.\n",
        "type": "List Vega.Force -> Vega.ForceSimulationProperty"
      },
      {
        "name": "fsIterations",
        "comment": " Number of iterations in a force transformation when in static mode (default 300).\n",
        "type": "Vega.Num -> Vega.ForceSimulationProperty"
      },
      {
        "name": "fsRestart",
        "comment": " Whether a simulation in a force transformation should restart when node object\nfields are modified.\n",
        "type": "Vega.Boo -> Vega.ForceSimulationProperty"
      },
      {
        "name": "fsStatic",
        "comment": " Whether a simulation in a force transformation should be computed in batch to\nproduce a static layout (true) or should be animated (false).\n",
        "type": "Vega.Boo -> Vega.ForceSimulationProperty"
      },
      {
        "name": "fsVelocityDecay",
        "comment": " Friction to be applied to a simulation in a force transformation. This is applied\nafter the application of any forces during an iteration.\n",
        "type": "Vega.Num -> Vega.ForceSimulationProperty"
      },
      {
        "name": "gjFeature",
        "comment": " Field containing the GeoJSON objects to be consolidated into a feature collection\nby a geoJSON transform.\n",
        "type": "Vega.Field -> Vega.GeoJsonProperty"
      },
      {
        "name": "gjFields",
        "comment": " Fields containing longitude (first parameter) and latitude (second parameter)\nto be consolidated into a feature collection by a geoJSON transform.\n",
        "type": "Vega.Field -> Vega.Field -> Vega.GeoJsonProperty"
      },
      {
        "name": "gjSignal",
        "comment": " Name of the a new signal to capture the output of generated by a geoJSON transform.\n",
        "type": "String -> Vega.GeoJsonProperty"
      },
      {
        "name": "gpAs",
        "comment": " Output field in which to write a generated shape instance following a geoShape\nor geoPath transformation.\n",
        "type": "String -> Vega.GeoPathProperty"
      },
      {
        "name": "gpField",
        "comment": " Data field containing GeoJSON data when applying a geoShape or geoPath transformation.\nIf unspecified, the full input data object will be used.\n",
        "type": "Vega.Field -> Vega.GeoPathProperty"
      },
      {
        "name": "gpPointRadius",
        "comment": " Default radius (in pixels) to use when drawing GeoJSON Point and MultiPoint\ngeometries. An expression value may be used to set the point radius as a function\nof properties of the input GeoJSON.\n",
        "type": "Vega.Num -> Vega.GeoPathProperty"
      },
      {
        "name": "grAlignColumn",
        "comment": " Layout alignment to apply to grid columns. Used in cases when alignment rules\nare different for rows and columns.\n",
        "type": "Vega.GridAlign -> Vega.GridAlign"
      },
      {
        "name": "grAlignRow",
        "comment": " Layout alignment to apply to grid rows. Used in cases when alignment rules\nare different for rows and columns.\n",
        "type": "Vega.GridAlign -> Vega.GridAlign"
      },
      {
        "name": "grExtent",
        "comment": " Major and minor extents of a graticule to be the same values. Parameter should\nevaluate to a two-element list representing longitude and latitude extents.\n",
        "type": "Vega.Num -> Vega.GraticuleProperty"
      },
      {
        "name": "grExtentMajor",
        "comment": " Major extent of a graticule. Parameter should evaluate to a two-element list\nrepresenting longitude and latitude extents.\n",
        "type": "Vega.Num -> Vega.GraticuleProperty"
      },
      {
        "name": "grExtentMinor",
        "comment": " Minor extent of a graticule. Parameter should evaluate to a two-element list\nrepresenting longitude and latitude extents.\n",
        "type": "Vega.Num -> Vega.GraticuleProperty"
      },
      {
        "name": "grField",
        "comment": " Field used to bin when generating a graticule.\n",
        "type": "Vega.Field -> Vega.GraticuleProperty"
      },
      {
        "name": "grPrecision",
        "comment": " Precision in degrees with which graticule arcs are generated. The default value\nis 2.5 degrees.\n",
        "type": "Vega.Num -> Vega.GraticuleProperty"
      },
      {
        "name": "grStep",
        "comment": " Major and minor step angles of a graticule to be the same values. Parameter\nshould be a two-element list representing longitude and latitude spacing.\n",
        "type": "Vega.Num -> Vega.GraticuleProperty"
      },
      {
        "name": "grStepMajor",
        "comment": " Major step angles of a graticule. Parameter should be a two-element list\nrepresenting longitude and latitude spacing.\n",
        "type": "Vega.Num -> Vega.GraticuleProperty"
      },
      {
        "name": "grStepMinor",
        "comment": " Minor step angles of a graticule. Parameter should be a two-element list\nrepresenting longitude and latitude spacing.\n",
        "type": "Vega.Num -> Vega.GraticuleProperty"
      },
      {
        "name": "gridAlignSignal",
        "comment": " Layout alignment referenced by the value in the named signal.\n",
        "type": "String -> Vega.GridAlign"
      },
      {
        "name": "hAlignSignal",
        "comment": " Horizontal text alignment referenced by the value in the named signal.\n",
        "type": "String -> Vega.HAlign"
      },
      {
        "name": "hCenter",
        "comment": " Convenience function for indicating a central horizontal alignment.\n",
        "type": "Vega.Value"
      },
      {
        "name": "hLeft",
        "comment": " Convenience function for indicating a left horizontal alignment.\n",
        "type": "Vega.Value"
      },
      {
        "name": "hRight",
        "comment": " Convenience function for indicating a right horizontal alignment.\n",
        "type": "Vega.Value"
      },
      {
        "name": "hclLong",
        "comment": " A long-path hue-chroma-luminance color interpolation.\n",
        "type": "Vega.CInterpolate"
      },
      {
        "name": "height",
        "comment": " Override the default height of the visualization. If not specified the height\nwill be calculated based on the content of the visualization.\n",
        "type": "Float -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "hslLong",
        "comment": " A long-path hue-saturation-lightness color interpolation.\n",
        "type": "Vega.CInterpolate"
      },
      {
        "name": "iCheckbox",
        "comment": " A checkbox input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iColor",
        "comment": " A color selector input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iDate",
        "comment": " A date selector input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iDateTimeLocal",
        "comment": " A local data time selector input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iMonth",
        "comment": " A month selector input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iNumber",
        "comment": " A numeric input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iRadio",
        "comment": " A radio buttons input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iRange",
        "comment": " A slider input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iSelect",
        "comment": " A drop-down list input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iTel",
        "comment": " A telephone number input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iText",
        "comment": " A free text input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iTime",
        "comment": " A time selector input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "iWeek",
        "comment": " A week selector input element.\n",
        "type": "List Vega.InputProperty -> Vega.Bind"
      },
      {
        "name": "ifElse",
        "comment": " Values conditional on whether an expression (first parameter) evaluates as true.\nThe second and third parameters represent the 'then' and 'else' branches of the test.\n\nTo include nested conditions, subsequent `ifElse` calls should be placed in the\n'else' branch.\n\n    maFontWeight\n        [ ifElse \"indata('selected', 'source', datum.id)\"\n            [ vStr \"bold\" ]\n            [ ifElse \"indata('selected', 'target', datum.id)\"\n                [ vStr \"bold\" ]\n                [ vNull ]\n            ]\n        ]\n\n",
        "type": "String -> List Vega.Value -> List Vega.Value -> Vega.Value"
      },
      {
        "name": "imGroupBy",
        "comment": " List of fields by which to group values in an impute transform. Imputation is\nthen performed on a per-group basis, such as a within group mean rather than global\nmean.\n",
        "type": "List Vega.Field -> Vega.ImputeProperty"
      },
      {
        "name": "imKeyVals",
        "comment": " Additional collection of key values that should be considered for imputation ]\nas part of an impute transform.\n",
        "type": "Vega.Value -> Vega.ImputeProperty"
      },
      {
        "name": "imMethod",
        "comment": " Imputation method to be used as part of an impute transform. If not specified\nthe default `ByMean` method will be used.\n",
        "type": "Vega.ImputeMethod -> Vega.ImputeProperty"
      },
      {
        "name": "imValue",
        "comment": " Vvalue to use when an imputation method is set to `ByValue` in an impute transform.\n",
        "type": "Vega.Value -> Vega.ImputeProperty"
      },
      {
        "name": "inAutocomplete",
        "comment": " Whether autocomplete should be turned on or off for input elements that\nsupport it.\n",
        "type": "Bool -> Vega.InputProperty"
      },
      {
        "name": "inDebounce",
        "comment": " Delay event handling until the given milliseconds have elapsed since the last\nevent was fired. Helps to limit event broadcasting.\n",
        "type": "Float -> Vega.InputProperty"
      },
      {
        "name": "inElement",
        "comment": " A CSS selector string indicating the parent element to which the input element\nshould be added. This allows the option of the input element to be outside the\nvisualization container, which could be used for linking separate visualizations.\n",
        "type": "String -> Vega.InputProperty"
      },
      {
        "name": "inMax",
        "comment": " Maximum value for a range slider input element.\n",
        "type": "Float -> Vega.InputProperty"
      },
      {
        "name": "inMin",
        "comment": " Minimum value for a range slider input element.\n",
        "type": "Float -> Vega.InputProperty"
      },
      {
        "name": "inOptions",
        "comment": " Options to be selected from a Radio or Select input element.\n",
        "type": "Vega.Value -> Vega.InputProperty"
      },
      {
        "name": "inPlaceholder",
        "comment": " Place-holding text for input elements before any value has been entered.\n",
        "type": "String -> Vega.InputProperty"
      },
      {
        "name": "inStep",
        "comment": " Step value (increment between adjacent selectable values) for a range slider\ninput element.\n",
        "type": "Float -> Vega.InputProperty"
      },
      {
        "name": "jaAs",
        "comment": " Output fields to be generated by a join aggregate transform.\n",
        "type": "List String -> Vega.JoinAggregateProperty"
      },
      {
        "name": "jaFields",
        "comment": " Fields to aggregate in join aggregate transform.\n",
        "type": "List Vega.Field -> Vega.JoinAggregateProperty"
      },
      {
        "name": "jaGroupBy",
        "comment": " Fields to group by in a join aggregate transform.\n",
        "type": "List Vega.Field -> Vega.JoinAggregateProperty"
      },
      {
        "name": "jaOps",
        "comment": " Operations in a join aggregate transform.\n",
        "type": "List Vega.Operation -> Vega.JoinAggregateProperty"
      },
      {
        "name": "jsonProperty",
        "comment": " Property to be extracted from some JSON when it has some surrounding structure\nor meta-data. e.g., specifying the property `values.features` is equivalent to\nretrieving `json.values.features` from the loaded JSON object with a custom delimiter.\n",
        "type": "Vega.Str -> Vega.FormatProperty"
      },
      {
        "name": "keyValue",
        "comment": " Custom key-value pair to be stored in an object generated by [vObject](#vObject).\n",
        "type": "String -> Vega.Value -> Vega.Value"
      },
      {
        "name": "layout",
        "comment": " Create a layout used in the visualization. For example the following creates\na three-column layout with 20 pixel padding between columns:\n\n    lo =\n        layout [ loColumns (num 3), loPadding (num 20) ]\n\n",
        "type": "List Vega.LayoutProperty -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "leClipHeight",
        "comment": " Height in pixels to clip a symbol legend entries and limit its size.\nBy default no clipping is performed.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leColumnPadding",
        "comment": " Horizontal padding between entries in a symbol legend.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leColumns",
        "comment": " Number of columns in which to arrange symbol legend entries. A\nvalue of 0 or lower indicates a single row with one column per entry. The default\nis 0 for horizontal symbol legends and 1 for vertical symbol legends.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leCornerRadius",
        "comment": " Corner radius for an enclosing legend rectangle.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leDirection",
        "comment": " Direction of a legend.\n",
        "type": "Vega.Orientation -> Vega.LegendProperty"
      },
      {
        "name": "leEncode",
        "comment": " Mark encodings for custom legend styling. For example, to create a horizontal\ndash symbol (using a simple SVG path) for each legend item:\n\n    legend\n        [ leEncode [ enSymbols [ enEnter [ maShape [ vStr \"M-0.5,0H1\" ] ] ] ]\n        , leStroke \"myColourScale\"\n        ]\n\n",
        "type": "List Vega.LegendEncoding -> Vega.LegendProperty"
      },
      {
        "name": "leFill",
        "comment": " Name of the scale that maps to the legend symbols' fill colors.\n",
        "type": "String -> Vega.LegendProperty"
      },
      {
        "name": "leFillColor",
        "comment": " Bbackground color of an enclosing legend rectangle.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leFormat",
        "comment": " Format pattern for legend labels. Text should be either a\n[d3-format specifier](https://github.com/d3/d3-format#locale_format) or a\n[d3-time-format specifier](https://github.com/d3/d3-time-format#locale_format).\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leGradientLabelLimit",
        "comment": " Maximum allowed length of gradient labels in a legend.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leGradientLabelOffset",
        "comment": " Vertical offset in pixels for gradient labels in a legend.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leGradientLength",
        "comment": " Length in pixels of the primary axis of a color gradient in a\nlegend. This value corresponds to the height of a vertical gradient or the width\nof a horizontal gradient.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leGradientOpacity",
        "comment": " Opacity of a color gradient in a legend.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leGradientStrokeColor",
        "comment": " Color of a legend's color gradient border.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leGradientStrokeWidth",
        "comment": " Width of a legend's color gradient border.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leGradientThickness",
        "comment": " Thickness in pixels of the color gradient in a legend. This value\ncorresponds to the width of a vertical gradient or the height of a horizontal\ngradient.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leGridAlign",
        "comment": " Alignment to apply to symbol legends rows and columns.\n",
        "type": "Vega.GridAlign -> Vega.LegendProperty"
      },
      {
        "name": "leLabelAlign",
        "comment": " Horizontal text alignment for a legend label.\n",
        "type": "Vega.HAlign -> Vega.LegendProperty"
      },
      {
        "name": "leLabelBaseline",
        "comment": " Vertical text alignment for a legend label.\n",
        "type": "Vega.VAlign -> Vega.LegendProperty"
      },
      {
        "name": "leLabelColor",
        "comment": " Text color for legend labels.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leLabelFont",
        "comment": " Font for legend labels.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leLabelFontSize",
        "comment": " Font size in pixels for legend labels.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leLabelFontWeight",
        "comment": " Font weight for legend labels.\n",
        "type": "Vega.Value -> Vega.LegendProperty"
      },
      {
        "name": "leLabelLimit",
        "comment": " Maximum allowed length in pixels of a legend label.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leLabelOffset",
        "comment": " Horizontal pixel offset for a legend's symbols.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leLabelOpacity",
        "comment": " Opacity for a legend's labels.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leLabelOverlap",
        "comment": " Strategy to use for resolving overlap of labels in gradient legends.\n",
        "type": "Vega.OverlapStrategy -> Vega.LegendProperty"
      },
      {
        "name": "leOffset",
        "comment": " Offset in pixels by which to displace the legend from the data rectangle and axes.\n",
        "type": "Vega.Value -> Vega.LegendProperty"
      },
      {
        "name": "leOpacity",
        "comment": " Name of the scale that maps to the legend symbols' opacities.\n",
        "type": "String -> Vega.LegendProperty"
      },
      {
        "name": "leOrient",
        "comment": " Orientation of the legend, determining where the legend is placed\nrelative to a chart’s data rectangle.\n",
        "type": "Vega.LegendOrientation -> Vega.LegendProperty"
      },
      {
        "name": "lePadding",
        "comment": " Padding between the border and content of the legend group.\n",
        "type": "Vega.Value -> Vega.LegendProperty"
      },
      {
        "name": "leRowPadding",
        "comment": " Vertical padding between entries in a symbol legend.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leShape",
        "comment": " Name of the scale that maps to the legend symbols' shapes.\n",
        "type": "String -> Vega.LegendProperty"
      },
      {
        "name": "leSize",
        "comment": " Name of the scale that maps to the legend symbols' sizes.\n",
        "type": "String -> Vega.LegendProperty"
      },
      {
        "name": "leStroke",
        "comment": " Name of the scale that maps to the legend symbols' strokes.\n",
        "type": "String -> Vega.LegendProperty"
      },
      {
        "name": "leStrokeColor",
        "comment": " Border color of an enclosing legend rectangle.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leStrokeDash",
        "comment": " Name of the scale that maps to the legend symbols' stroke dashing.\n",
        "type": "String -> Vega.LegendProperty"
      },
      {
        "name": "leStrokeWidth",
        "comment": " Stroke width of the color of a legend's gradient border.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolBaseFillColor",
        "comment": " Default fill color for legend symbols. This is only applied if there\nis no fill scale color encoding for the legend.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolBaseStrokeColor",
        "comment": " Default stroke color for legend symbols. This is only applied if\nthere is no stroke scale color encoding for the legend.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolDirection",
        "comment": " Default direction for legend symbols.\n",
        "type": "Vega.Orientation -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolFillColor",
        "comment": " Fill color for legend symbols.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolOffset",
        "comment": " Offset in pixels between legend labels their corresponding symbol or gradient.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolOpacity",
        "comment": " Opacity for a legend's symbols.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolSize",
        "comment": " Default symbol area size in square pixel units.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolStrokeColor",
        "comment": " Border color for legend symbols.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolStrokeWidth",
        "comment": " Default symbol border width used in a legend.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leSymbolType",
        "comment": " Default symbol shape used in a legend.\n",
        "type": "Vega.Symbol -> Vega.LegendProperty"
      },
      {
        "name": "leTemporalTickCount",
        "comment": " Ddesired number of ticks for a temporal legend. The first parameter\nis the type of temporal interval to use and the second the number of steps of that\ninterval between ticks. For example to specify a tick is requested at six-month\nintervals (e.g. January, July):\n\n    lg =\n        legends\n            << legend\n                [ leFill \"cScale\"\n                , leType LGradient\n                , leFormat (str \"%b %Y\")\n                , leTemporalTickCount Month (num 6)\n                ]\n\nIf the second parameter is not a positive value, the number of ticks will be\nauto-generated for the given interval type.\n\n",
        "type": "Vega.TimeUnit -> Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leTickCount",
        "comment": " Desired number of tick values for quantitative legends.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leTitle",
        "comment": " Title for the legend (none by default).\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leTitleAlign",
        "comment": " Horizontal alignment for a legend title.\n",
        "type": "Vega.HAlign -> Vega.LegendProperty"
      },
      {
        "name": "leTitleBaseline",
        "comment": " Vertical alignment for a legend title.\n",
        "type": "Vega.VAlign -> Vega.LegendProperty"
      },
      {
        "name": "leTitleColor",
        "comment": " Text color for a legend title.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leTitleFont",
        "comment": " Font for a legend title.\n",
        "type": "Vega.Str -> Vega.LegendProperty"
      },
      {
        "name": "leTitleFontSize",
        "comment": " Font size in pixel units for a legend title.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leTitleFontWeight",
        "comment": " Font weight for a legend title.\n",
        "type": "Vega.Value -> Vega.LegendProperty"
      },
      {
        "name": "leTitleLimit",
        "comment": " Maximum allowed length in pixels of a legend title.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leTitleOpacity",
        "comment": " Opacity for a legend's title.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "leTitlePadding",
        "comment": " Padding between the legend title and entries.\n",
        "type": "Vega.Value -> Vega.LegendProperty"
      },
      {
        "name": "leType",
        "comment": " Type of legend.\n",
        "type": "Vega.LegendType -> Vega.LegendProperty"
      },
      {
        "name": "leValues",
        "comment": " Explicitly set visible legend values.\n",
        "type": "List Vega.Value -> Vega.LegendProperty"
      },
      {
        "name": "leZIndex",
        "comment": " z-index indicating the layering of the legend group relative to other axis,\nmark and legend groups. The default value is 0.\n",
        "type": "Vega.Num -> Vega.LegendProperty"
      },
      {
        "name": "legend",
        "comment": " Create a legend used to visualize a color, size or shape mapping.\n",
        "type": "List Vega.LegendProperty -> List Vega.Spec -> List Vega.Spec"
      },
      {
        "name": "legendOrientationSignal",
        "comment": " Legend position referenced by the value in the named signal.\n",
        "type": "String -> Vega.LegendOrientation"
      },
      {
        "name": "legendTypeSignal",
        "comment": " Legend type (`symbol` or `gradient`) referenced by the value in the named signal.\n",
        "type": "String -> Vega.LegendType"
      },
      {
        "name": "legends",
        "comment": " Create legends used to visualize color, size and shape mappings. Commonly the\nfunctional composition operator (`<<`) is used to combine multiple legend\nspecifications. For example,\n\n    lg =\n        legends\n            << legend\n                [ leTitle (str \"Income\")\n                , leOrient BottomRight\n                , leType LSymbol\n                , leSize \"mySizeScale\"\n                ]\n            << legend\n                [ leTitle (str \"Nationality\")\n                , leOrient TopRight\n                , leType LSymbol\n                , leFill \"myColorScale\"\n                ]\n\n",
        "type": "List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "linkShapeSignal",
        "comment": " Line shape between nodes referenced by the value in the named signal.\n",
        "type": "String -> Vega.LinkShape"
      },
      {
        "name": "loAlign",
        "comment": " Alignment to apply to grid rows and columns in a grid layout.\n",
        "type": "Vega.GridAlign -> Vega.LayoutProperty"
      },
      {
        "name": "loBounds",
        "comment": " Bounds calculation method to use for determining the extent of a\nsub-plot in a grid layout.\n",
        "type": "Vega.BoundsCalculation -> Vega.LayoutProperty"
      },
      {
        "name": "loColumns",
        "comment": " Number of columns to include in a grid layout. If unspecified, a\nsingle row with unlimited columns will be assumed.\n",
        "type": "Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loFooterBand",
        "comment": " Band positioning in the interval [0,1] indicating where in a cell\na footer should be placed in a grid layout.\n",
        "type": "Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loFooterBandRC",
        "comment": " Similar to [loFooterBand](#loFooterBand) but allowing row and column settings\nto be specified separately.\n",
        "type": "Vega.Num -> Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loHeaderBand",
        "comment": " Band positioning in the interval [0,1] indicating where in a cell a header\nshould be placed in a grid layout. For a column header, 0 maps to the left edge\nof the header cell and 1 to right edge. For a row footer, the range maps from\ntop to bottom.\n",
        "type": "Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loHeaderBandRC",
        "comment": " Similar to [loFHeaderBand](#loHeaderBand) but allowing row and column settings\nto be specified separately.\n",
        "type": "Vega.Num -> Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loOffset",
        "comment": " Orthogonal offset in pixels by which to displace grid header, footer\nand title cells from their position along the edge of a grid layout.\n",
        "type": "Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loOffsetRC",
        "comment": " Similar to [loOffset](#loOffset) but allowing row and column settings to be\nspecified separately.\n",
        "type": "Vega.Num -> Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loPadding",
        "comment": " Padding in pixels to add between elements within rows and columns\nof a grid layout.\n",
        "type": "Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loPaddingRC",
        "comment": " Similar to [loPadding](#loPadding) but allowing row and column settings to be\nspecified separately.\n",
        "type": "Vega.Num -> Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loTitleBand",
        "comment": " Title placement in a grid layout. For a column title, 0 maps to the left edge\nof the title cell and 1 to right edge. The default value is 0.5, indicating a\ncentred position.\n",
        "type": "Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "loTitleBandRC",
        "comment": " Similar to [loTitleBand](#loTitleBand) but allowing row and column settings\nto be specified separately.\n",
        "type": "Vega.Num -> Vega.Num -> Vega.LayoutProperty"
      },
      {
        "name": "lpAs",
        "comment": " Name for the output field of a link path in a linkPath transformation.\nIf not specified, the default is \"path\".\n",
        "type": "String -> Vega.LinkPathProperty"
      },
      {
        "name": "lpOrient",
        "comment": " Orientation of a link path in a linkPath transformation. If a radial\norientation is specified, x and y coordinate parameters will be interpreted as an\nangle (in radians) and radius, respectively.\n",
        "type": "Vega.Orientation -> Vega.LinkPathProperty"
      },
      {
        "name": "lpShape",
        "comment": " Shape of a link path in a linkPath transformation.\n",
        "type": "Vega.LinkShape -> Vega.LinkPathProperty"
      },
      {
        "name": "lpSourceX",
        "comment": " Field for the source x-coordinate in a linkPath transformation.\nThe default is `source.x`.\n",
        "type": "Vega.Field -> Vega.LinkPathProperty"
      },
      {
        "name": "lpSourceY",
        "comment": " Field for the source y-coordinate in a linkPath transformation.\nThe default is `source.y`.\n",
        "type": "Vega.Field -> Vega.LinkPathProperty"
      },
      {
        "name": "lpTargetX",
        "comment": " Field for the target x-coordinate in a linkPath transformation.\nThe default is `target.x`.\n",
        "type": "Vega.Field -> Vega.LinkPathProperty"
      },
      {
        "name": "lpTargetY",
        "comment": " Field for the target y-coordinate in a linkPath transformation.\nThe default is `target.y`.\n",
        "type": "Vega.Field -> Vega.LinkPathProperty"
      },
      {
        "name": "luAs",
        "comment": " Output fields in which to write data found in the secondary stream of a lookup.\n",
        "type": "List String -> Vega.LookupProperty"
      },
      {
        "name": "luDefault",
        "comment": " Default value to assign if lookup fails in a lookup transformation.\n",
        "type": "Vega.Value -> Vega.LookupProperty"
      },
      {
        "name": "luValues",
        "comment": " Fields to copy from the secondary stream to the primary\nstream in a lookup transformation. If not specified, a reference to the full data\nrecord is copied.\n",
        "type": "List Vega.Field -> Vega.LookupProperty"
      },
      {
        "name": "mClip",
        "comment": " Indicate whether or how marks should be clipped to a specified shape. For a\nsimple case of clipping to the retangular 'data rectangle':\n\n    mClip (clEnabled true)\n\nTo clip by some abritrary simple polygon use [clPath](#clPath) either to specify\nan SVG path string explicitly in pixel coordinates, or more usefully for geographic\ncoordinates use the output of [trGeoPath](#trGeoPath):\n\n    ds =\n        dataSource\n            [ data \"myClippingPoly\"\n                [ daUrl (str \"myPolyFile.json\")\n                , daFormat [ topojsonFeature \"idOfClippingPoly\" ]\n                ]\n                |> transform [ trGeoPath \"myProjection\" [] ]\n            ...\n\n    mk =\n        marks\n              << mark Path\n                  [ mFrom [ srData (str \"myMapSource\") ]\n                  , mClip (clPath (strSignal \"data('myClippingPoly')[0]['path']\"))\n                  ...\n\n",
        "type": "Vega.Clip -> Vega.TopMarkProperty"
      },
      {
        "name": "mDescription",
        "comment": " Description of a mark, useful for inline comments.\n",
        "type": "String -> Vega.TopMarkProperty"
      },
      {
        "name": "mEncode",
        "comment": " The visual encoding rules for a mark.\n",
        "type": "List Vega.EncodingProperty -> Vega.TopMarkProperty"
      },
      {
        "name": "mFrom",
        "comment": " Data source to be visualized by a mark. If not specified, a single\nelement dataset containing an empty object is assumed. The source can either be\na dataset to use or a faceting directive to subdivide a dataset across a set\nof group marks.\n",
        "type": "List Vega.Source -> Vega.TopMarkProperty"
      },
      {
        "name": "mGroup",
        "comment": " Assemble a group of top-level marks. Used to create nested groups\nof marks within a `Group` mark (including further nested group specifications) by\nsuppyling the specification as a series of properties. For example,\n\n    marks\n        << mark Group\n            [ mFrom [ srData (str \"myData\") ]\n            , mGroup [ mkGroup1 [], mkGroup2 [] ]\n            ]\n\n",
        "type": "List ( Vega.VProperty, Vega.Spec ) -> Vega.TopMarkProperty"
      },
      {
        "name": "mInteractive",
        "comment": " Whether a mark can serve as an input event source. If false, no\nmouse or touch events corresponding to the mark will be generated.\n",
        "type": "Vega.Boo -> Vega.TopMarkProperty"
      },
      {
        "name": "mKey",
        "comment": " Field to use as a unique key for data binding. When a\nvisualization’s data is updated, the key value will be used to match data elements\nto existing mark instances. Use a key field to enable object constancy for\ntransitions over dynamic data.\n",
        "type": "Vega.Field -> Vega.TopMarkProperty"
      },
      {
        "name": "mName",
        "comment": " Unique name to be given to a mark. This name can be used to refer to the mark\nin another mark or within an event stream definition. SVG renderers will add this\nname value as a CSS class name on the enclosing SVG group (g) element containing\nthe mark instances.\n",
        "type": "String -> Vega.TopMarkProperty"
      },
      {
        "name": "mOn",
        "comment": " Triggers for modifying a mark's properties in response to signal changes.\n",
        "type": "List Vega.Trigger -> Vega.TopMarkProperty"
      },
      {
        "name": "mSort",
        "comment": " Fields and sort order for sorting mark items. The sort order will\ndetermine the default rendering order. This is defined over generated scenegraph\nitems and sorting is performed after encodings are computed, allowing items to be\nsorted by size or position. To sort by underlying data properties in addition to\nmark item properties, append the prefix `datum` to a field name.\n\n    mSort [ ( field \"datum.y\", Ascend ) ]\n\n",
        "type": "List ( Vega.Field, Vega.Order ) -> Vega.TopMarkProperty"
      },
      {
        "name": "mStyle",
        "comment": " Names of custom styles to apply to a mark. A style is a named\ncollection of mark property defaults defined within the configuration. These\nproperties will be applied to the mark’s enter encoding set, with later styles\noverriding earlier styles. Any properties explicitly defined within the mark’s\n`encode` block will override a style default.\n",
        "type": "List String -> Vega.TopMarkProperty"
      },
      {
        "name": "mTransform",
        "comment": " Post-encoding transforms to be applied after any encode\nblocks, that operate directly on mark scenegraph items (not backing data objects).\nThese can be useful for performing layout with transforms that can set x, y,\nwidth, height, etc. properties. Only data transforms that do not generate or\nfilter data objects should be used.\n",
        "type": "List Vega.Transform -> Vega.TopMarkProperty"
      },
      {
        "name": "mZIndex",
        "comment": " z-index (draw order) of a mark. Marks with higher values are drawn\n'on top' of marks with lower numbers. Useful when drawing node-link diagrams and\nthe node symbol should sit on top of connected edge lines.\n",
        "type": "Vega.Num -> Vega.TopMarkProperty"
      },
      {
        "name": "maAlign",
        "comment": " Horizontal alignment of a text or image mark. To guarantee valid\nalignment type names, use `hCenter`, `hLeft` etc. For example:\n\n    << mark Text\n        [ mEncode\n            [ enEnter [ maAlign [ hCenter ] ] ]\n        ]\n\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maAngle",
        "comment": " Rotation angle of the text in degrees in a text mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maAspect",
        "comment": " Whether or not image aspect ratio should be preserved in an image mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maBaseline",
        "comment": " Vertical baseline of a text or image mark. To guarantee valid\nalignment type names, use `vTop`, `vMiddle` etc. For example:\n\n    << mark Text\n        [ mEncode\n            [ enEnter [ maBaseline [ vTop ] ] ]\n        ]\n\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maCornerRadius",
        "comment": " Corner radius in pixels of an arc or rect mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maCursor",
        "comment": " Cursor to be displayed over a mark. To guarantee valid cursor type\nnames, use [cursorValue](#cursorValue).\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maCustom",
        "comment": " Create a custom mark property. For example:\n\n    mEncode\n        [ enEnter\n            [ maFill [ vScale \"cScale\", vField (field \"group\") ]\n            , maCustom \"myName\" [ vScale \"xScale\", vField (field \"group\") ]\n            ]\n        ]\n\nSee the\n[Vega Beeswarm plot example](https://vega.github.io/vega/examples/beeswarm-plot/).\n\n",
        "type": "String -> List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maDefined",
        "comment": " Indicate if the current data point in a linear mark is defined. If false, the\ncorresponding line/trail segment will be omitted, creating a “break”.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maDir",
        "comment": " Direction text is rendered in a text mark. This determines which side is\ntruncated in response to the text size exceeding the value of the limit parameter.\nTo guarantee valid direction type names, use [textDirectionValue](#textDirectionValue).\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maDx",
        "comment": " Horizontal offset in pixels (before rotation), between the text and anchor\npoint of a text mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maDy",
        "comment": " Vertical offset in pixels (before rotation), between the text and anchor\npoint of a text mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maEllipsis",
        "comment": " Ellipsis string for text truncated in response to the limit parameter of\na text mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maEndAngle",
        "comment": " End angle in radians clockwise from north for an arc mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maFill",
        "comment": " Fill color of a mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maFillOpacity",
        "comment": " The fill opacity of a mark in the range 0 to 1.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maFont",
        "comment": " Typeface used by a text mark. This can be a generic font description such\nas `sans-serif`, `monospace` or any specific font name made accessible via a css\nfont definition.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maFontSize",
        "comment": " The font size in pixels used by a text mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maFontStyle",
        "comment": " The font style, such as `normal` or `italic` used by a text mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maFontWeight",
        "comment": " The font weight, such as `normal` or `bold` used by a text mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maGroupClip",
        "comment": " Indicate if the visible group content should be clipped to the group’s\nspecified width and height.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maHRef",
        "comment": " URL to load upon mouse click. If defined, the mark acts as a hyperlink.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maHeight",
        "comment": " Height of a mark in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maInnerRadius",
        "comment": " The inner radius in pixel units of an arc mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maInterpolate",
        "comment": " Interpolation style of a linear mark. To guarantee valid\ninterpolation type names, use [markInterpolationValue](#markInterpolationValue).\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maLimit",
        "comment": " The maximum length of a text mark in pixels (default 0, indicating no limit).\nThe text value will be automatically truncated if the rendered size exceeds this\nlimit.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maOpacity",
        "comment": " The opacity of a mark in the range 0 to 1.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maOrient",
        "comment": " The orientation of an area mark. With a vertical orientation, an area mark is\ndefined by the x, y, and (y2 or height) properties; with a horizontal orientation,\nthe y, x and (x2 or width) properties must be specified instead.\nTo guarantee valid orientation type names, use [orientationValue](#orientationValue).\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maOuterRadius",
        "comment": " The outer radius in pixel units of an arc mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maPadAngle",
        "comment": " The padding angle in radians clockwise from north for an arc mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maPath",
        "comment": " The [SVG path string](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths)\ndescribing the geometry of a path mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maRadius",
        "comment": " Polar coordinate radial offset in pixels, relative to the origin determined\nby the x and y properties of a text mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maShape",
        "comment": " A shape instance that provides a drawing method to invoke within the renderer.\nShape instances cannot be specified directly, instead they must be generated by\na data transform such as symbol generation or a geoshape:\n\n    shapeEncoding =\n        [ maShape [ symbolValue SymSquare ]\n        , maStroke [ black ]\n        ]\n\n    lg =\n        legends\n            << legend\n                [ leFill \"cScale\"\n                , leOrient BottomRight\n                , leEncode [ enSymbols [ enUpdate shapeEncoding ] ]\n                ]\n\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maSize",
        "comment": " Area in pixels of the bounding box of point-based mark such as a symbol.\nNote that this value sets the area of the mark; the side lengths will increase with\nthe square root of this value.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStartAngle",
        "comment": " Start angle in radians clockwise from north for an arc mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStroke",
        "comment": " Stroke color of a mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStrokeCap",
        "comment": " Stroke cap ending style for a mark.To guarantee valid stroke cap\nnames, use [strokeCapValue](#strokeCapValue).\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStrokeDash",
        "comment": " Stroke dash style of a mark. The list should consist\nof alternating dash-gap lengths in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStrokeDashOffset",
        "comment": " A mark's offset of the first stroke dash in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStrokeJoin",
        "comment": " Stroke join method for a mark. To guarantee valid stroke join\nnames, use [strokeJoinValue](#strokeJoinValue).\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStrokeMiterLimit",
        "comment": " Miter limit at which to bevel a line join for a mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStrokeOpacity",
        "comment": " Stroke opacity of a mark in the range 0 to 1.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maStrokeWidth",
        "comment": " Stroke width of a mark in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maSymbol",
        "comment": " A symbol shape that describes a symbol mark. For preset shapes, use\n[symbolValue](#symbolValue). For correct sizing of custom shape paths, define\ncoordinates within a square ranging from -1 to 1 along both the x and y dimensions.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maTension",
        "comment": " The interpolation tension in the range 0 to 1 of a linear mark. Applies only\nto cardinal and catmull-rom interpolators.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maText",
        "comment": " The text to display in a text mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maTheta",
        "comment": " Polar coordinate angle in radians, relative to the origin determined by the\nx and y properties of a text mark.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maTooltip",
        "comment": " The tooltip text to show upon mouse hover over a mark. This may be specified\ndirectly, via a field, a signal or any other text-generating value.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maUrl",
        "comment": " The URL of an image file to be displayed as an image mark. This may be specified\ndirectly, via a field, a signal or any other text-generating value.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maWidth",
        "comment": " The width of a mark in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maX",
        "comment": " The primary x-coordinate of a mark in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maX2",
        "comment": " The secondary x-coordinate of a mark in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maXC",
        "comment": " The centre x-coordinate of a mark in pixels. This is an alternative to `maX`\nor `maX2`, not an addition.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maY",
        "comment": " The primary y-coordinate of a mark in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maY2",
        "comment": " The secondary y-coordinate of a mark in pixels.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maYC",
        "comment": " The centre y-coordinate of a mark in pixels. This is an alternative to `maY`\nor `maY2`, not an addition.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "maZIndex",
        "comment": " An integer z-index indicating the layering order of sibling mark items. The\ndefault value is 0. Higher values (1) will cause marks to be drawn on top of those\nwith lower z-index values. Setting the z-index as an encoding property only affects\nordering among sibling mark items; it will not change the layering relative to other\nmark definitions.\n",
        "type": "List Vega.Value -> Vega.MarkProperty"
      },
      {
        "name": "mark",
        "comment": " A mark definition. Marks form the visible components of a visualization.\nEach mark specification can include a list of mark properties (second parameter)\nthat customise the appearance of the mark and relate its appearance to data streams\nor signals.\n",
        "type": "Vega.Mark -> List Vega.TopMarkProperty -> List Vega.Spec -> List Vega.Spec"
      },
      {
        "name": "markInterpolationValue",
        "comment": " A convenience function for generating a value representing a given mark\ninterpolation type. Used instead of specifying an interpolation type\nas a literal string to avoid problems of mistyping the interpolation name.\n\n    signals\n       << signal \"interp\" [ siValue (markInterpolationValue Linear) ]\n\n",
        "type": "Vega.MarkInterpolation -> Vega.Value"
      },
      {
        "name": "marks",
        "comment": " Create the marks used in the visualization. Multiple mark specifications are\ncommonly combined using the functional composition operator (`<<`). For example,\n\n      mk =\n          marks\n              << mark Line\n                  [ mFrom [ srData (str \"myData\") ]\n                  , mEncode\n                      [ enEnter\n                          [ maX [ vScale \"xScale\", vField (field \"distance\") ]\n                          , maY [ vScale \"yScale\", vField (field \"energy\") ]\n                          , maStroke [ black ]\n                          ]\n                      ]\n                  ]\n              << mark Symbol\n                  [ mFrom [ srData (str \"myData\") ]\n                  , mEncode\n                      [ enEnter\n                          [ maX [ vScale \"xScale\", vField (field \"distance\") ]\n                          , maY [ vScale \"yScale\", vField (field \"energy\") ]\n                          , maFill [ white ]\n                          , maStroke [ black ]\n                          ]\n                      ]\n                  ]\n\n",
        "type": "List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "nInterval",
        "comment": " Desired 'nice' temporal interval between labelled tick points.\n",
        "type": "Vega.TimeUnit -> Int -> Vega.ScaleNice"
      },
      {
        "name": "nTickCount",
        "comment": " Desired tick count for a human-friendly 'nice' scale range.\n",
        "type": "Int -> Vega.ScaleNice"
      },
      {
        "name": "num",
        "comment": " A numeric literal.\n",
        "type": "Float -> Vega.Num"
      },
      {
        "name": "numExpr",
        "comment": " An expression that evaluates to a numeric value.\n",
        "type": "Vega.Expr -> Vega.Num"
      },
      {
        "name": "numList",
        "comment": " List of potentially mixed numeric types. Useful when a domain is\nspecified as being bounded by 0 and some signal:\n\n    scDomain (doNums (numList [ num 0, numSignal \"mySignal\" ] ) )\n\n",
        "type": "List Vega.Num -> Vega.Num"
      },
      {
        "name": "numNull",
        "comment": " An absence of a numeric value.\n",
        "type": "Vega.Num"
      },
      {
        "name": "numSignal",
        "comment": " Numeric value referenced by the value in the named signal.\n",
        "type": "String -> Vega.Num"
      },
      {
        "name": "numSignals",
        "comment": " List of numeric values referenced by the values in the named signals.\n",
        "type": "List String -> Vega.Num"
      },
      {
        "name": "nums",
        "comment": " A list of numeric literals. For lists that contain a mixture of numeric\nliterals and signals use [numList](#numList) instead.\n",
        "type": "List Float -> Vega.Num"
      },
      {
        "name": "on",
        "comment": " Add a list of triggers to the given data table.\n",
        "type": "List Vega.Trigger -> Vega.DataTable -> Vega.DataTable"
      },
      {
        "name": "operationSignal",
        "comment": " Aggregation operation referenced by the value in the named signal.\n",
        "type": "String -> Vega.Operation"
      },
      {
        "name": "orderSignal",
        "comment": " Sorting order referenced by the value in the named signal.\n",
        "type": "String -> Vega.Order"
      },
      {
        "name": "orientationSignal",
        "comment": " Orientation referenced by the value in the named signal.\n",
        "type": "String -> Vega.Orientation"
      },
      {
        "name": "orientationValue",
        "comment": " A convenience function for generating a value representing a given mark\norientation type. Used instead of specifying an orientation type as\na literal string to avoid problems of mistyping its name.\n\n     maOrient [ orientationValue Horizontal ]\n\n",
        "type": "Vega.Orientation -> Vega.Value"
      },
      {
        "name": "overlapStrategySignal",
        "comment": " Overlap strategy referenced by the value in the named signal.\n",
        "type": "String -> Vega.OverlapStrategy"
      },
      {
        "name": "paAs",
        "comment": " The names to give the output fields of a packing transform. The default is\n[\"x\", \"y\", \"r\", \"depth\", \"children\"], where x and y are the layout coordinates,\nr is the node radius, depth is the tree depth, and children is the count of a\nnode’s children in the tree.\n",
        "type": "String -> String -> String -> String -> String -> Vega.PackProperty"
      },
      {
        "name": "paField",
        "comment": " The data field corresponding to a numeric value for the node in a packing\ntransform. The sum of values for a node and all its descendants is available on\nthe node object as the value property. If radius is null, this field determines\nthe node size.\n",
        "type": "Vega.Field -> Vega.PackProperty"
      },
      {
        "name": "paPadding",
        "comment": " The approximate padding to include between packed circles.\n",
        "type": "Vega.Num -> Vega.PackProperty"
      },
      {
        "name": "paRadius",
        "comment": " Node radius to use in a packing transform. If `Nothing` (the\ndefault), the radius of each leaf circle is derived from the field value.\n",
        "type": "Maybe.Maybe Vega.Field -> Vega.PackProperty"
      },
      {
        "name": "paSize",
        "comment": " The size of a packing layout, provided as a two-element list in [width, height]\norder (or a signal that generates such a list).\n",
        "type": "Vega.Num -> Vega.PackProperty"
      },
      {
        "name": "paSort",
        "comment": " Packing transform sorting properties. The inputs to subject to sorting are\ntree node objects, not input data objects.\n",
        "type": "List ( Vega.Field, Vega.Order ) -> Vega.PackProperty"
      },
      {
        "name": "padding",
        "comment": " Padding around the visualization in pixel units. The way padding is\ninterpreted will depend on the `autosize` properties.\n",
        "type": "Float -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "paddings",
        "comment": " Padding around the visualization in pixel units in _left_, _top_,\n_right_, _bottom_ order.\n",
        "type": "Float -> Float -> Float -> Float -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "parse",
        "comment": " Data parsing rules as a list of tuples where each corresponds to a\nfield name paired with its desired data type. This is only necessary if there is\nsome ambiguity that could prevent correct type inference, such as time text:\n\n    dataSource\n        [ data \"timeData\"\n            [ daUrl (str \"data/timeSeries.json\")\n            , daFormat [ parse [ ( \"timestamp\", foDate \"%d/%m/%y %H:%M\" ) ] ]\n            ]\n        ]\n\n",
        "type": "List ( String, Vega.DataType ) -> Vega.FormatProperty"
      },
      {
        "name": "piAs",
        "comment": " Output fields for the computed start and end angles for each arc in a pie\ntransform.\n",
        "type": "String -> String -> Vega.PieProperty"
      },
      {
        "name": "piEndAngle",
        "comment": " End angle in radians in a pie chart transform. The default is 2 PI\nindicating the final slice ends 'north'.\n",
        "type": "Vega.Num -> Vega.PieProperty"
      },
      {
        "name": "piField",
        "comment": " The field to encode with angular spans in a pie chart transform.\n",
        "type": "Vega.Field -> Vega.PieProperty"
      },
      {
        "name": "piGroupBy",
        "comment": " Fields to group by when performing a pivot transform. If not specified,\na single group containing all data objects will be used.\n",
        "type": "List Vega.Field -> Vega.PivotProperty"
      },
      {
        "name": "piLimit",
        "comment": " Maximum number of fields to generate when performing a pivot transform\nor 0 for no limit.\n",
        "type": "Vega.Num -> Vega.PivotProperty"
      },
      {
        "name": "piOp",
        "comment": " Aggregation operation to use by when performing a pivot transform.\nIf not specified, fields will be aggregated by their sum.\n",
        "type": "Vega.Operation -> Vega.PivotProperty"
      },
      {
        "name": "piSort",
        "comment": " Indicate whether or not pie slices should be stored in angular size order.\n",
        "type": "Vega.Boo -> Vega.PieProperty"
      },
      {
        "name": "piStartAngle",
        "comment": " The starting angle in radians in a pie chart transform. The default is 0\nindicating that the first slice starts 'north'.\n",
        "type": "Vega.Num -> Vega.PieProperty"
      },
      {
        "name": "prCenter",
        "comment": " Map projection’s centre as a two-element list of longitude and latitude\nin degrees.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prClipAngle",
        "comment": " Map projection’s clipping circle radius to the specified angle in degrees.\nA value of zero indicates antimeridian cutting should be applied rather than\nsmall-circle clipping.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prClipExtent",
        "comment": " Map projection’s viewport clip extent to the specified bounds in pixels.\nThe extent bounds should be specified as a list of four numbers in [x0, y0, x1, y1]\norder where x0 is the left-side of the viewport, y0 is the top, x1 is the right\nand y1 is the bottom.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prCoefficient",
        "comment": " 'Hammer' map projection's coefficient (defaults to 2).\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prCustom",
        "comment": " Custom map projection. Custom names need to be registered with the Vega runtime.\n",
        "type": "Vega.Str -> Vega.Projection"
      },
      {
        "name": "prDistance",
        "comment": " 'Satellite' map projection's distance value. Values are expressed as a\nproportion of the Earth's radius (defaults to 2).\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prExtent",
        "comment": " Display region into which the projection should be automatically fit.\nUsed in conjunction with [prFit](#prFit). The region bounds should be specified\nin [x0, y0, x1, y1] order where x0 is the left-side, y0 is the top, x1 is the\nright and y1 is the bottom.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prFit",
        "comment": " GeoJSON data to which a projection should attempt to automatically fit by setting\nits translate and scale values.\n\n    ds =\n        dataSource [ data \"mapData\" [ daUrl (str \"myGeoJson.json\") ] ]\n\n    pr =\n        projections\n            << projection \"myProjection\"\n                [ prType Orthographic\n                , prSize (numSignal \"[width,height]\")\n                , prFit (feName \"mapData\")\n                ]\n\n",
        "type": "Vega.Feature -> Vega.ProjectionProperty"
      },
      {
        "name": "prFraction",
        "comment": " 'Bottomley' map projection's fraction parameter (defaults to 0.5).\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prLobes",
        "comment": " Number of lobes in radial map projections such as the Berghaus Star.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prParallel",
        "comment": " Parallel used for map projections such as the Armadillo (defaults\nto 20 degrees N).\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prPointRadius",
        "comment": " Default radius (in pixels) to use when drawing projected GeoJSON\nPoint and MultiPoint geometries. The default value is 4.5.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prPrecision",
        "comment": " Threshold for the projection’s adaptive resampling in pixels. This\ncorresponds to the Douglas–Peucker distance. If precision is not specified, the\nprojection’s current resampling precision which defaults to √0.5 ≅ 0.70710 is used.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prRadius",
        "comment": " Radius for the 'Gingery' map projection. Defaults to 30 degrees.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prRatio",
        "comment": " 'Hill' map projection's ratio allowing it to vary continuously between\nMaurer 73 (0) and Eckert IV projections (infinity). Defaults to 1.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prRotate",
        "comment": " Map projection’s three-axis rotation angle. This should be a two- or\nthree-element list of numbers [lambda, phi, gamma] specifying the rotation angles\nin degrees about each spherical axis.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prScale",
        "comment": " Map projection’s scale factor. The default scale is projection-specific. It\ncorresponds linearly to the distance between projected points; however, scale\nfactor values are not equivalent across projections.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prSize",
        "comment": " Width and height of the display region into which the projection should be\nautomatically fit. Used in conjunction with [prFit](#prFit) this is equivalent\nto calling [prExtent](#prExtent) with the top-left position set to (0,0). The region\nsize should be specified in [width, height] order (or a signal that generates such\na list).\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prSpacing",
        "comment": " Spacing for a Lagrange conformal map projection (defaults to 0.5).\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prTilt",
        "comment": " Tilt angle for a Satellite map projection (defaults to 0 degrees).\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prTranslate",
        "comment": " Translation offset to the specified two-element list [tx, ty]. If\nnot specified as a two-element list, returns the current translation offset which\ndefaults to [480, 250]. The translation offset determines the pixel coordinates\nof the projection’s centre. The default translation offset places (0°,0°) at the\ncentre of a 960×500 area.\n",
        "type": "Vega.Num -> Vega.ProjectionProperty"
      },
      {
        "name": "prType",
        "comment": " Type of map projection to use in a projection transformation.\n",
        "type": "Vega.Projection -> Vega.ProjectionProperty"
      },
      {
        "name": "projection",
        "comment": " Map projection for transforming geo data onto a plane.\n",
        "type": "String -> List Vega.ProjectionProperty -> List Vega.Spec -> List Vega.Spec"
      },
      {
        "name": "projectionSignal",
        "comment": " Map projection referenced by the value in the named signal.\n",
        "type": "String -> Vega.Projection"
      },
      {
        "name": "projectionValue",
        "comment": " Convenience function for generating a value representing a given projection\ntype. Useful when generating signals representing projection types.\n",
        "type": "Vega.Projection -> Vega.Value"
      },
      {
        "name": "projections",
        "comment": " Create the projections used to map geographic data onto a plane.\n\n    pr =\n        projections\n            << projection \"myProj\" [ prType Orthographic ]\n            << projection \"myProj2\" [ prType Albers, prRotate (nums [ -20, 15 ]) ]\n\n",
        "type": "List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "ptAs",
        "comment": " Output field names for the output of a partition layout transform.\nThe parameters correspond to the (default name) fields `x0`, `y0`, `x1`, `y1`,\n`depth` and `children`.\n",
        "type": "String -> String -> String -> String -> String -> String -> Vega.PartitionProperty"
      },
      {
        "name": "ptField",
        "comment": " Data field corresponding to a numeric value for a partition node.\nThe sum of values for a node and all its descendants is available on the node object\nas the `value` property. This field determines the size of a node.\n",
        "type": "Vega.Field -> Vega.PartitionProperty"
      },
      {
        "name": "ptPadding",
        "comment": " Padding between adjacent nodes for a partition layout transform.\n",
        "type": "Vega.Num -> Vega.PartitionProperty"
      },
      {
        "name": "ptRound",
        "comment": " Whether or not node layout values should be rounded in a partition transform.\nThe default is false.\n",
        "type": "Vega.Boo -> Vega.PartitionProperty"
      },
      {
        "name": "ptSize",
        "comment": " Size of a partition layout as two-element list corresponding to\n[width, height] (or a signal that generates such a list).\n",
        "type": "Vega.Num -> Vega.PartitionProperty"
      },
      {
        "name": "ptSort",
        "comment": " Sorting properties of sibling nodes during a partition layout transform.\n",
        "type": "List ( Vega.Field, Vega.Order ) -> Vega.PartitionProperty"
      },
      {
        "name": "raCustomDefault",
        "comment": " Custom range default scheme. Used when a new named default has been\ncreated as part of a config setting is required.\n",
        "type": "String -> Vega.ScaleRange"
      },
      {
        "name": "raData",
        "comment": " Scale range as a data reference object. This is used for specifying\nordinal scale ranges as a series of distinct field values.\n\n    scale \"myScale\"\n        [ scType ScOrdinal\n        , scDomain (doData [ daDataset \"clusters\", daField (field \"id\") ])\n        , scRange (raData [ daDataset \"clusters\", daField (field \"name\") ])\n        ]\n\n",
        "type": "List Vega.DataReference -> Vega.ScaleRange"
      },
      {
        "name": "raNums",
        "comment": " Scale range as a list of numbers.\n",
        "type": "List Float -> Vega.ScaleRange"
      },
      {
        "name": "raScheme",
        "comment": " Scale range as a list of color schemes. The first parameter is\nthe name of the colour scheme to use, the second any customising properties.\n",
        "type": "Vega.Str -> List Vega.ColorSchemeProperty -> Vega.ScaleRange"
      },
      {
        "name": "raSignal",
        "comment": " Scale range referenced by the value in the named signal.\n",
        "type": "String -> Vega.ScaleRange"
      },
      {
        "name": "raStep",
        "comment": " Step size for a band scale range.\n",
        "type": "Vega.Value -> Vega.ScaleRange"
      },
      {
        "name": "raStrs",
        "comment": " Scale range as a list of strings.\n",
        "type": "List String -> Vega.ScaleRange"
      },
      {
        "name": "raValues",
        "comment": " Scale range as a list of values.\n",
        "type": "List Vega.Value -> Vega.ScaleRange"
      },
      {
        "name": "rgb",
        "comment": " RGB color interpolation. The parameter is a gamma value to control the\nbrightness of the color trajectory.\n",
        "type": "Float -> Vega.CInterpolate"
      },
      {
        "name": "scAlign",
        "comment": " Alignment of elements within each step of a band scale, as a\nfraction of the step size. Should be in the range [0,1].\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scBase",
        "comment": " Base of the logorithm used in a logarithmic scale.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scClamp",
        "comment": " Whether output values should be clamped to when using a quantitative\nscale range (default false). If clamping is disabled and the scale is passed a\nvalue outside the domain, the scale may return a value outside the range through\nextrapolation. If clamping is enabled, the output value of the scale is always\nwithin the scale’s range.\n",
        "type": "Vega.Boo -> Vega.ScaleProperty"
      },
      {
        "name": "scCustom",
        "comment": " Custom named scale.\n",
        "type": "String -> Vega.Scale"
      },
      {
        "name": "scDomain",
        "comment": " Domain of input data values for a scale.\n",
        "type": "Vega.ScaleDomain -> Vega.ScaleProperty"
      },
      {
        "name": "scDomainImplicit",
        "comment": " Whether or not ordinal domains should be implicitly extended with new\nvalues. If false, a scale will return `undefined` for values not included in the\ndomain; if true, new values will be appended to the domain and an updated range\nvalue will be returned.\n",
        "type": "Vega.Boo -> Vega.ScaleProperty"
      },
      {
        "name": "scDomainMax",
        "comment": " Maximum value of a scale domain, overriding a `scDomain` setting. Only intended\nfor scales with continuous domains.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scDomainMid",
        "comment": " Insert a single mid-point value into a two-element scale domain. The mid-point\nvalue must lie between the domain minimum and maximum values. Useful for setting\na midpoint for diverging color scales. Only used with scales having continuous,\npiecewise domains.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scDomainMin",
        "comment": " Minimum value of a scale domain, overriding a `scDomain` setting.\nThis is only used with scales having continuous domains.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scDomainRaw",
        "comment": " List value that directly overrides the domain of a scale. Useful for\nsupporting interactions such as panning or zooming a scale. The scale may be\ninitially determined using a data-driven domain, then modified in response to user\ninput.\n\n    scales\n        << scale \"xDetail\"\n            [ scType ScTime\n            , scRange RaWidth\n            , scDomain (doData [ daDataset \"sp500\", daField (field \"date\") ])\n            , scDomainRaw (vSignal \"detailDomain\")\n            ]\n\n",
        "type": "Vega.Value -> Vega.ScaleProperty"
      },
      {
        "name": "scExponent",
        "comment": " Exponent to be used in power scale.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scInterpolate",
        "comment": " Interpolation method for a quantitative scale.\n",
        "type": "Vega.CInterpolate -> Vega.ScaleProperty"
      },
      {
        "name": "scNice",
        "comment": " Extend the range of a scale domain so it starts and ends on 'nice' round\nvalues.\n",
        "type": "Vega.ScaleNice -> Vega.ScaleProperty"
      },
      {
        "name": "scPadding",
        "comment": " Expand a scale domain to accommodate the specified number of pixels on each\nend of a quantitative scale range or the padding between bands in a band scale.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scPaddingInner",
        "comment": " Expand a scale domain to accommodate the specified number of pixels\nbetween inner bands in a band scale.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scPaddingOuter",
        "comment": " Expand a scale domain to accommodate the specified number of pixels\noutside the outer bands in a band scale.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scRange",
        "comment": " Range of a scale representing the set of visual values.\n",
        "type": "Vega.ScaleRange -> Vega.ScaleProperty"
      },
      {
        "name": "scRangeStep",
        "comment": " Step size for band and point scales.\n",
        "type": "Vega.Num -> Vega.ScaleProperty"
      },
      {
        "name": "scReverse",
        "comment": " Reverse the order of a scale range.\n",
        "type": "Vega.Boo -> Vega.ScaleProperty"
      },
      {
        "name": "scRound",
        "comment": " Whether to round numeric output values to integers. Helpful for\nsnapping to the pixel grid.\n",
        "type": "Vega.Boo -> Vega.ScaleProperty"
      },
      {
        "name": "scType",
        "comment": " Type of a named scale.\n",
        "type": "Vega.Scale -> Vega.ScaleProperty"
      },
      {
        "name": "scZero",
        "comment": " Whether or not a scale domain should include zero. The default is\ntrue for linear, sqrt and power scales and false for all others.\n",
        "type": "Vega.Boo -> Vega.ScaleProperty"
      },
      {
        "name": "scale",
        "comment": " Scale to be used to map data values to visual properties.\n",
        "type": "String -> List Vega.ScaleProperty -> List Vega.Spec -> List Vega.Spec"
      },
      {
        "name": "scaleNiceSignal",
        "comment": " 'nice' number-scaling type referenced by the value in the named signal.\n",
        "type": "String -> Vega.ScaleNice"
      },
      {
        "name": "scaleRangeSignal",
        "comment": " Default range scaling referenced by the value in the named signal.\n",
        "type": "String -> Vega.ScaleRange"
      },
      {
        "name": "scaleSignal",
        "comment": " Scaling referenced by the value in the named signal.\n",
        "type": "String -> Vega.Scale"
      },
      {
        "name": "scales",
        "comment": " Create the scales used to map data values to visual properties.\n\n    sc =\n        scales\n            << scale \"xScale\"\n                [ scType ScLinear\n                , scDomain (doData [ daDataset \"myData\", daField (field \"x\") ])\n                , scRange RaWidth\n                ]\n            << scale \"yScale\"\n                [ scType ScLinear\n                , scDomain (doData [ daDataset \"myData\", daField (field \"y\") ])\n                , scRange RaHeight\n                ]\n\n",
        "type": "List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "siBind",
        "comment": " Bind a signal to an external input element such as a slider, selection list\nor radio button group.\n",
        "type": "Vega.Bind -> Vega.SignalProperty"
      },
      {
        "name": "siDescription",
        "comment": " Text description of a signal, useful for inline documentation.\n",
        "type": "String -> Vega.SignalProperty"
      },
      {
        "name": "siName",
        "comment": " A unique name to be given to a signal. Signal names should be contain only\nalphanumeric characters (or “$”, or “_”) and may not start with a digit. Reserved\nkeywords that may not be used as signal names are \"datum\", \"event\", \"item\", and\n\"parent\".\n",
        "type": "String -> Vega.SignalProperty"
      },
      {
        "name": "siOn",
        "comment": " Event stream handlers for updating a signal value in response to input events.\n",
        "type": "List (List Vega.EventHandler) -> Vega.SignalProperty"
      },
      {
        "name": "siPushOuter",
        "comment": " Make signal updates target a signal in an enclosing scope. Used when creating\nnested signals in a group mark.\n",
        "type": "Vega.SignalProperty"
      },
      {
        "name": "siReact",
        "comment": " Whether a signal update expression should be automatically re-evaluated\nwhen any upstream signal dependencies update. If false, the update expression will\nonly be run upon initialization.\n",
        "type": "Vega.Boo -> Vega.SignalProperty"
      },
      {
        "name": "siUpdate",
        "comment": " Update expression for a signal which may include other signals,\nin which case the signal will automatically update in response to upstream signal\nchanges, so long as its react property is not false.\n",
        "type": "String -> Vega.SignalProperty"
      },
      {
        "name": "siValue",
        "comment": " Initial value of a signal.\n",
        "type": "Vega.Value -> Vega.SignalProperty"
      },
      {
        "name": "sideSignal",
        "comment": " Rectangular side referenced by the value in the named signal.\n",
        "type": "String -> Vega.Side"
      },
      {
        "name": "signal",
        "comment": " Signal to be used to add a dynamic component to a visualization.\n",
        "type": "String -> List Vega.SignalProperty -> List Vega.Spec -> List Vega.Spec"
      },
      {
        "name": "signals",
        "comment": " Create the signals used to add dynamism to the visualization.\n\n    si =\n        signals\n            << signal \"chartSize\" [ siValue (vNum 120) ]\n            << signal \"chartPad\" [ siValue (vNum 15) ]\n            << signal \"chartStep\" [ siUpdate \"chartSize + chartPad\" ]\n            << signal \"width\" [ siUpdate \"chartStep * 4\" ]\n\n",
        "type": "List Vega.Spec -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "soByField",
        "comment": " Field to be used when sorting.\n",
        "type": "Vega.Str -> Vega.SortProperty"
      },
      {
        "name": "soOp",
        "comment": " Sorting operation.\n",
        "type": "Vega.Operation -> Vega.SortProperty"
      },
      {
        "name": "sortPropertySignal",
        "comment": " Sorting type referenced by the value in the named signal.\n",
        "type": "String -> Vega.SortProperty"
      },
      {
        "name": "spiralSignal",
        "comment": " Word cloud spiral type (`archimedean` or `rectangular`) referenced by the\nvalue in the named signal.\n",
        "type": "String -> Vega.Spiral"
      },
      {
        "name": "srData",
        "comment": " Name of the source for a set of marks.\n",
        "type": "Vega.Str -> Vega.Source"
      },
      {
        "name": "srFacet",
        "comment": " Create a facet directive for a set of marks. The first parameter is the name\nof the source dataset from which the facet partitions are to be generated. The\nsecond is the name to be given to the generated facet source. Marks defined with\nthe faceted `group` mark can reference this data source name to visualize the\nlocal data partition.\n\n    mark Group\n        [ mFrom [ srFacet (str \"table\") \"facet\" [ faGroupBy [ field \"category\" ] ] ]\n        , mEncode [ enEnter [ maY [ vScale \"yScale\", vField (field \"category\") ] ] ]\n        , mGroup [ nestedMk [] ]\n        ]\n\n    nestedMk =\n        marks\n            << mark Rect\n                [ mName \"bars\"\n                , mFrom [ srData (str \"facet\") ]\n                , mEncode\n                    [ enEnter\n                        [ maY [ vScale \"pos\", vField (field \"position\") ]\n                        , maHeight [ vScale \"pos\", vBand (num 1) ]\n                        , maX [ vScale \"xScale\", vField (field \"value\") ]\n                        , maX2 [ vScale \"xScale\", vBand (num 0) ]\n                        , maFill [ vScale \"cScale\", vField (field \"position\") ]\n                        ]\n                    ]\n                ]\n\n",
        "type": "Vega.Str -> String -> List Vega.Facet -> Vega.Source"
      },
      {
        "name": "stAs",
        "comment": " Names of the output fields for the computed start and end stack\nvalues of a stack transform.\n",
        "type": "String -> String -> Vega.StackProperty"
      },
      {
        "name": "stField",
        "comment": " Field that determines the stack heights in a stack transform.\n",
        "type": "Vega.Field -> Vega.StackProperty"
      },
      {
        "name": "stGroupBy",
        "comment": " Grouping of fields with which to partition data into separate stacks\nin a stack transform.\n",
        "type": "List Vega.Field -> Vega.StackProperty"
      },
      {
        "name": "stOffset",
        "comment": " Baseline offset used in a stack transform.\n",
        "type": "Vega.StackOffset -> Vega.StackProperty"
      },
      {
        "name": "stSort",
        "comment": " Criteria for sorting values in a stack transform.\n",
        "type": "List ( Vega.Field, Vega.Order ) -> Vega.StackProperty"
      },
      {
        "name": "stackOffsetSignal",
        "comment": " Stacking offset referenced by the value in the named signal.\n",
        "type": "String -> Vega.StackOffset"
      },
      {
        "name": "str",
        "comment": " A string literal.\n",
        "type": "String -> Vega.Str"
      },
      {
        "name": "strExpr",
        "comment": " Expression that when evaluated, is a string.\n",
        "type": "Vega.Expr -> Vega.Str"
      },
      {
        "name": "strNull",
        "comment": " An absence of a string value.\n",
        "type": "Vega.Str"
      },
      {
        "name": "strSignal",
        "comment": " String value referenced by the value in the named signal.\n",
        "type": "String -> Vega.Str"
      },
      {
        "name": "strSignals",
        "comment": " String values referenced by the values in the named signals.\n",
        "type": "List String -> Vega.Str"
      },
      {
        "name": "strokeCapSignal",
        "comment": " Stroke cap (`butt`, `round` and `square`) referenced by the value in the\nnamed signal.\n",
        "type": "String -> Vega.StrokeCap"
      },
      {
        "name": "strokeCapValue",
        "comment": " Convenience function for generating a value representing a given stroke cap type.\n",
        "type": "Vega.StrokeCap -> Vega.Value"
      },
      {
        "name": "strokeJoinSignal",
        "comment": " Stroke join (`miter`, `round` or `bevel`) referenced by the value in the\nnamed signal.\n",
        "type": "String -> Vega.StrokeJoin"
      },
      {
        "name": "strokeJoinValue",
        "comment": " Convenience function for generating a text string representing a given\nstroke join type. Used instead of specifying an stroke join type\nas a literal string to avoid problems of mistyping its name.\n",
        "type": "Vega.StrokeJoin -> Vega.Value"
      },
      {
        "name": "strs",
        "comment": " A list of string literals.\n",
        "type": "List String -> Vega.Str"
      },
      {
        "name": "symPath",
        "comment": " [SVG path description](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths)\nto define a custom symbol shape.\n",
        "type": "String -> Vega.Symbol"
      },
      {
        "name": "symbolSignal",
        "comment": " Symbol type referenced by the value in the named signal.\n",
        "type": "String -> Vega.Symbol"
      },
      {
        "name": "symbolValue",
        "comment": " Convenience function for generating a value representing a given symbol type.\n",
        "type": "Vega.Symbol -> Vega.Value"
      },
      {
        "name": "teAs",
        "comment": " Output field names within which to write the results of a tree\nlayout transform. The parameters represent the names to replace the defaults in\nthe following order: `x`, `y`, `depth` and `children`.\n",
        "type": "String -> String -> String -> String -> Vega.TreeProperty"
      },
      {
        "name": "teField",
        "comment": " Data corresponding to a numeric value to be associated with nodes\nin a tree transform.\n",
        "type": "Vega.Field -> Vega.TreeProperty"
      },
      {
        "name": "teMethod",
        "comment": " Layout method used in a tree transform.\n",
        "type": "Vega.TreeMethod -> Vega.TreeProperty"
      },
      {
        "name": "teNodeSize",
        "comment": " Size of each node in a tree layout as a two-element [width,height]\nlist (or a signal that generates such a list).\n",
        "type": "Vega.Num -> Vega.TreeProperty"
      },
      {
        "name": "teSize",
        "comment": " Size of of a tree layout as a two-element [width,height] list\n(or a signal that generates such a list).\n",
        "type": "Vega.Num -> Vega.TreeProperty"
      },
      {
        "name": "teSort",
        "comment": " Sorting properties of sibling nodes in a tree layout transform.\n",
        "type": "List ( Vega.Field, Vega.Order ) -> Vega.TreeProperty"
      },
      {
        "name": "textDirectionSignal",
        "comment": " Text direction (`ltr` or `rtl`) referenced by the value in the named signal.\n",
        "type": "String -> Vega.TextDirection"
      },
      {
        "name": "textDirectionValue",
        "comment": " Create a text direction value.\n",
        "type": "Vega.TextDirection -> Vega.Value"
      },
      {
        "name": "tgInsert",
        "comment": " Expression that evaluates to data objects to insert as triggers. Insert\noperations are only applicable to datasets, not marks.\n",
        "type": "String -> Vega.TriggerProperty"
      },
      {
        "name": "tgModifyValues",
        "comment": " Data or mark modification trigger. The first parameter is an\nexpression that evaluates to data objects to modify and the second an expression\nthat evaluates to an object of name-value pairs, indicating the field values that\nshould be updated.\n\n    mark Symbol\n        [ mFrom [ srData (str \"countries\") ]\n        , mOn\n            [ trigger \"myDragSignal\"\n                [ tgModifyValues \"dragged\" \"{fx: x(), fy: y()}\" ]\n            ]\n\nwould set the `fx` and `fy` properties on mark items referenced by `myDragSignal`\nto the current mouse pointer position.\n\n",
        "type": "String -> String -> Vega.TriggerProperty"
      },
      {
        "name": "tgRemove",
        "comment": " Expression that evaluates to data objects to remove. Remove operations are only\napplicable to datasets, not marks.\n",
        "type": "String -> Vega.TriggerProperty"
      },
      {
        "name": "tgRemoveAll",
        "comment": " Remove all data object triggers.\n",
        "type": "Vega.TriggerProperty"
      },
      {
        "name": "tgToggle",
        "comment": " Expression that evaluates to data objects to toggle. Toggled\nobjects are inserted or removed depending on whether they are already in the\ndataset. Applicable only to datasets, not marks.\n",
        "type": "String -> Vega.TriggerProperty"
      },
      {
        "name": "tiAlign",
        "comment": " Horizontal alignment of a title. If specified this will override\nthe [tiAnchor](#tiAnchor) setting (useful when aligning rotated title text).\n",
        "type": "Vega.HAlign -> Vega.TitleProperty"
      },
      {
        "name": "tiAnchor",
        "comment": " Anchor positioning of a title. Used for aligning title text.\n",
        "type": "Vega.Anchor -> Vega.TitleProperty"
      },
      {
        "name": "tiAngle",
        "comment": " Angle in degrees of a title.\n",
        "type": "Vega.Num -> Vega.TitleProperty"
      },
      {
        "name": "tiBaseline",
        "comment": " Vertical title text baseline.\n",
        "type": "Vega.VAlign -> Vega.TitleProperty"
      },
      {
        "name": "tiColor",
        "comment": " Color of a title.\n",
        "type": "Vega.Str -> Vega.TitleProperty"
      },
      {
        "name": "tiEncode",
        "comment": " Mark encodings for custom title styling. This is a standard\nencoding for text marks and may contain `enEnter`, `enUpdate`, `enExit` and\n`enHover` specifications.\n",
        "type": "List Vega.EncodingProperty -> Vega.TitleProperty"
      },
      {
        "name": "tiFont",
        "comment": " Font name of a title.\n",
        "type": "Vega.Str -> Vega.TitleProperty"
      },
      {
        "name": "tiFontSize",
        "comment": " Font size of a title.\n",
        "type": "Vega.Num -> Vega.TitleProperty"
      },
      {
        "name": "tiFontWeight",
        "comment": " Font weight of a title (can be a number such as `vnum 300` or text\nsuch as `vStr \"bold\"`).\n",
        "type": "Vega.Value -> Vega.TitleProperty"
      },
      {
        "name": "tiFrame",
        "comment": " Reference frame for the anchor position of a title.\n",
        "type": "Vega.TitleFrame -> Vega.TitleProperty"
      },
      {
        "name": "tiInteractive",
        "comment": " Whether or not a title's properties should respond to input events\nsuch as mouse hover.\n",
        "type": "Vega.Boo -> Vega.TitleProperty"
      },
      {
        "name": "tiLimit",
        "comment": " Maximim allowed length of a title in pixels.\n",
        "type": "Vega.Num -> Vega.TitleProperty"
      },
      {
        "name": "tiName",
        "comment": " Mark name to apply to a title text mark. This name can be used to\nrefer to the title mark with an\n[event stream definition](https://vega.github.io/vega/docs/event-streams/).\n",
        "type": "String -> Vega.TitleProperty"
      },
      {
        "name": "tiOffset",
        "comment": " Orthogonal offset in pixels by which to displace the title from\nits position along the edge of the chart.\n",
        "type": "Vega.Num -> Vega.TitleProperty"
      },
      {
        "name": "tiOrient",
        "comment": " Position a title relative to the chart.\n",
        "type": "Vega.Side -> Vega.TitleProperty"
      },
      {
        "name": "tiStyle",
        "comment": " Mark style property to apply to the title text mark. If not\nspecified the default style of `group-title` is used.\n",
        "type": "Vega.Str -> Vega.TitleProperty"
      },
      {
        "name": "tiZIndex",
        "comment": " z-index indicating the layering of the title group relative to\nother axis, mark and legend groups.\n",
        "type": "Vega.Num -> Vega.TitleProperty"
      },
      {
        "name": "timeUnitSignal",
        "comment": " Time unit referenced by the value in the named signal.\n",
        "type": "String -> Vega.TimeUnit"
      },
      {
        "name": "title",
        "comment": " Top-level title to be displayed as part of a visualization.\nThe first paramter is the text of the title to display, the second any optional\nproperties for customising the title's appearance.\n",
        "type": "Vega.Str -> List Vega.TitleProperty -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "titleFrameSignal",
        "comment": " Title anchor calcuation type (`bounds` or `group`) referenced by the value in\nthe named signal.\n",
        "type": "String -> Vega.TitleFrame"
      },
      {
        "name": "tmAs",
        "comment": " Output field names for the output of a treemap layout transform.\nThe parameters correspond to the (default name) fields `x0`, `y0`, `x1`, `y1`,\n`depth` and `children`.\n",
        "type": "String -> String -> String -> String -> String -> String -> Vega.TreemapProperty"
      },
      {
        "name": "tmField",
        "comment": " Field corresponding to a numeric value for a treemap node.\nThe sum of values for a node and all its descendants is available on the node object\nas the `value` property. This field determines the size of a node.\n",
        "type": "Vega.Field -> Vega.TreemapProperty"
      },
      {
        "name": "tmMethod",
        "comment": " Layout method to use in a treemap transform.\n",
        "type": "Vega.TreemapMethod -> Vega.TreemapProperty"
      },
      {
        "name": "tmPadding",
        "comment": " Inner and outer padding values for a treemap layout transform.\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmPaddingBottom",
        "comment": " Padding between the bottom edge of a node and its children in a treemap\nlayout transform.\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmPaddingInner",
        "comment": " Inner padding values for a treemap layout transform.\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmPaddingLeft",
        "comment": " Padding between the left edge of a node and its children in a treemap\nlayout transform.\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmPaddingOuter",
        "comment": " Outer padding values for a treemap layout transform.\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmPaddingRight",
        "comment": " Padding between the right edge of a node and its children in a treemap\nlayout transform.\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmPaddingTop",
        "comment": " Padding between the top edge of a node and its children in a treemap\nlayout transform.\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmRatio",
        "comment": " Target aspect ratio for the `Squarify` or `Resquarify` treemap layout\ntrqnsformations. The default is the golden ratio, φ = (1 + sqrt(5)) / 2.\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmRound",
        "comment": " Whether or not node layout values should be rounded in a treemap transform.\nThe default is false.\n",
        "type": "Vega.Boo -> Vega.TreemapProperty"
      },
      {
        "name": "tmSize",
        "comment": " Size of a treemap layout as two-element list (or signal) corresponding\nto [width, height].\n",
        "type": "Vega.Num -> Vega.TreemapProperty"
      },
      {
        "name": "tmSort",
        "comment": " Sorting properties of sibling nodes is in a treemap layout transform.\n",
        "type": "List ( Vega.Field, Vega.Order ) -> Vega.TreemapProperty"
      },
      {
        "name": "toVega",
        "comment": " Convert a list of Vega specifications into a single JSON object that may be\npassed to Vega for graphics generation. Recommended practice for top-level\nproperties that have more than a simple parameter is to create as a series of\ncompactly named functions (e.g. `ds` for the data source, `sc` for scales, `si`\nfor signals, `ax` for axes etc.) and construct a list of them. For example,\n\n    helloWorld : Spec\n    helloWorld =\n        let\n            table =\n                dataFromColumns \"table\" []\n                    << dataColumn \"label\" (vStrs [ \"Hello\", \"from\", \"elm-vega\" ])\n                    << dataColumn \"x\" (vNums [ 1, 2, 3 ])\n\n            ds =\n                dataSource [ table [] ]\n\n            sc =\n                scales\n                    << scale \"xScale\"\n                        [ scDomain (doData [ daDataset \"table\", daField (field \"x\") ])\n                        , scRange RaWidth\n                        ]\n\n            mk =\n                marks\n                    << mark Text\n                        [ mFrom [ srData (str \"table\") ]\n                        , mEncode\n                            [ enEnter\n                                [ maX [ vScale \"xScale\", vField (field \"x\") ]\n                                , maText [ vField (field \"label\") ]\n                                ]\n                            ]\n                        ]\n        in\n        toVega\n            [ width 100, ds, sc [], mk [] ]\n\n",
        "type": "List ( Vega.VProperty, Vega.Spec ) -> Vega.Spec"
      },
      {
        "name": "topojsonFeature",
        "comment": " TopoJSON feature format. The first parameter is the name of the feature object\nset to extract.\n",
        "type": "Vega.Str -> Vega.FormatProperty"
      },
      {
        "name": "topojsonMesh",
        "comment": " Named property to extract from topoJSON file. Unlike\n[topojsonFeature](#topojsonFeature), geo data are returned as a single unified\nmesh instance, not as individual GeoJSON features.\n",
        "type": "Vega.Str -> Vega.FormatProperty"
      },
      {
        "name": "trAggregate",
        "comment": " Ggroup and summarize an input data stream to produce a derived output stream.\nAggregate transforms can be used to compute counts, sums, averages and other\ndescriptive statistics over groups of data objects.\n",
        "type": "List Vega.AggregateProperty -> Vega.Transform"
      },
      {
        "name": "trBin",
        "comment": " Discretises numeric values into a set of bins. The first parameter is the\nfield to bin, the second a two-element numeric list representing the min/max\nextent of the bins. Optional binning properties can be provided in the final parameter.\nCommonly used to create frequency histograms by combining with [trAggregate](#trAggregate)\nto do the counting of field values in each bin.\n\n    transform\n        [ trBin (field \"examScore\") (nums [ 0, 100 ]) []\n        , trAggregate\n            [ agKey (field \"bin0\")\n            , agGroupBy [ field \"bin0\", field \"bin1\" ]\n            , agOps [ Count ]\n            , agAs [ \"count\" ]\n            ]\n        ]\n\n",
        "type": "Vega.Field -> Vega.Num -> List Vega.BinProperty -> Vega.Transform"
      },
      {
        "name": "trCollect",
        "comment": " Collect all the objects in a data stream within a single list, allowing\nsorting by data field values.\n",
        "type": "List ( Vega.Field, Vega.Order ) -> Vega.Transform"
      },
      {
        "name": "trContour",
        "comment": " Generate a set of contour (iso) lines at a set of discrete levels. Commonly\nused to visualize density estimates for 2D point data.\n\nThe first two parameters are the width and height over which to compute the contours.\nThe third a list of optional contour properties. The transform generates a new\nstream of GeoJSON data as output which may be visualized using either the\n`trGeoShape` or `trGeoPath` transforms.\n\n    transform\n        [ trContour (numSignal \"width\")\n            (numSignal \"height\")\n            [ cnX (fExpr \"scale('xScale', datum.Horsepower)\")\n            , cnY (fExpr \"scale('yScale', datum.Miles_per_Gallon)\")\n            , cnCount (numSignal \"count\")\n            ]\n        ]\n\n",
        "type": "Vega.Num -> Vega.Num -> List Vega.ContourProperty -> Vega.Transform"
      },
      {
        "name": "trCountPattern",
        "comment": " Count the number of occurrences of a text pattern, as defined by a regular\nexpression. This transform will iterate through each data object and count all\nunique pattern matches found within the designated text field.\n\nThe first parameter is the field containing the text to count, the second a list\nof optional counting properties. The transform generates two fields named `text`\nand `count` unless renamed via `cpAs`.\n\n",
        "type": "Vega.Field -> List Vega.CountPatternProperty -> Vega.Transform"
      },
      {
        "name": "trCross",
        "comment": " Compute the cross-product of a data stream with itself.\n",
        "type": "List Vega.CrossProperty -> Vega.Transform"
      },
      {
        "name": "trCrossFilter",
        "comment": " Maintain a filter mask for multiple dimensional queries, using a set of\nsorted indices. The parameter is a list of (field,range) pairs indicating which\nfields to filter and the numeric range of values in the form of a `num` that\nshould resolve to a [min (inclusive), max (exclusive)] pair.\n",
        "type": "List ( Vega.Field, Vega.Num ) -> Vega.Transform"
      },
      {
        "name": "trCrossFilterAsSignal",
        "comment": " Perform a crossfilter transform. This version can be used with\n[trResolvefilter](#trResolveFilter) to enable fast interactive querying over large\ndatasets. The final parameter is the name of a new signal with which to bind the\nresults of the filter (which can then be referenced by [trResolveFilter](#trResolveFilter)).\n",
        "type": "List ( Vega.Field, Vega.Num ) -> String -> Vega.Transform"
      },
      {
        "name": "trDensity",
        "comment": " Compute a new data stream of uniformly-spaced samples drawn from a one-dimensional\nprobability density function (pdf) or cumulative distribution function (cdf).\nUseful for representing probability distributions and generating continuous\ndistributions from discrete samples through kernel density estimation.\n",
        "type": "Vega.Distribution -> List Vega.DensityProperty -> Vega.Transform"
      },
      {
        "name": "trExtent",
        "comment": " Compute the minimum and maximum values for a data field, producing a two-element\n[min, max] list.\n",
        "type": "Vega.Field -> Vega.Transform"
      },
      {
        "name": "trExtentAsSignal",
        "comment": " Compute the minimum and maximum values for a given data field and bind it to a\nsignal with the given name.\n",
        "type": "Vega.Field -> String -> Vega.Transform"
      },
      {
        "name": "trFilter",
        "comment": " Remove objects from a data stream based on the given filter expression.\n",
        "type": "Vega.Expr -> Vega.Transform"
      },
      {
        "name": "trFlatten",
        "comment": " Map list-valued fields to a set of individual data objects, one per list entry.\nThis version generates the output fields with names corresponding to the list field used.\n",
        "type": "List Vega.Field -> Vega.Transform"
      },
      {
        "name": "trFlattenAs",
        "comment": " Similar to [trFlatten](#trFlatten) but allowing the output fields to be named.\n",
        "type": "List Vega.Field -> List String -> Vega.Transform"
      },
      {
        "name": "trFold",
        "comment": " Collapse one or more data fields into two properties: a _key_ containing the\noriginal data field name and a _value_ containing the data value.\n",
        "type": "List Vega.Field -> Vega.Transform"
      },
      {
        "name": "trFoldAs",
        "comment": " Perform a fold transform generating the key and value fields named by the second\nand third parameters.\n",
        "type": "List Vega.Field -> String -> String -> Vega.Transform"
      },
      {
        "name": "trForce",
        "comment": " Compute a force-directed layout. This layout transformation uses a model in\nwhich data objects act as charged particles (or nodes), optionally connected by\na set of edges (or links). A set of forces is used to drive a physics simulation\nthat determines the node positions.\n",
        "type": "List Vega.ForceSimulationProperty -> Vega.Transform"
      },
      {
        "name": "trFormula",
        "comment": " Extend a data object with new values according to the given\n[Vega expression](https://vega.github.io/vega/docs/expressions/). The second\nparameter is a new field name to give the result of the evaluated expression.\nThis version will reapply the formula if the data changes. To perform a one-off\nformula calculation use [trFormulaInitOnly](#trFormulaInitOnly).\n\n    dataSource\n        [ data \"world\"\n            [ daUrl (str \"https://vega.github.io/vega/data/world-110m.json\")\n            , daFormat [ topojsonFeature \"countries\" ]\n            ]\n            |> transform\n                [ trFormula \"geoCentroid('myProj', datum)\" \"myCentroid\" ]\n        ]\n\n",
        "type": "String -> String -> Vega.Transform"
      },
      {
        "name": "trFormulaInitOnly",
        "comment": " Similar to [trFormula](#trFormula) but will apply the formula only once even\nif the data changes.\n",
        "type": "String -> String -> Vega.Transform"
      },
      {
        "name": "trGeoJson",
        "comment": " Consolidate geographic data into a single feature collection. This can be\ncaptured as a signal that will represent the consolidated feature collection.\n",
        "type": "List Vega.GeoJsonProperty -> Vega.Transform"
      },
      {
        "name": "trGeoPath",
        "comment": " Map GeoJSON features to SVG path strings according to a provided cartographic\nprojection for use with the path mark. Similar to the [trGeoShape](#trGeoShape)\nbut immediately generates SVG path strings.\n",
        "type": "String -> List Vega.GeoPathProperty -> Vega.Transform"
      },
      {
        "name": "trGeoPoint",
        "comment": " Project a longitude, latitude pair to (x,y) coordinates according to the given\nmap projection. The first parameter is the name of the map projection to use, the\nsecond and third the fields containing the longitude and latitude values respectively.\nThis version generates two new fields with the name `x` and `y` holding the\nprojected coordinates.\n",
        "type": "String -> Vega.Field -> Vega.Field -> Vega.Transform"
      },
      {
        "name": "trGeoPointAs",
        "comment": " Similar to [trGeoPoint](#trGeoPoint) but allowing the projected coordinates\nto be named (last two parameters).\n",
        "type": "String -> Vega.Field -> Vega.Field -> String -> String -> Vega.Transform"
      },
      {
        "name": "trGeoShape",
        "comment": " Generate a renderer instance that maps GeoJSON features to a shape instance\nfor use with the shape mark. Similar to the [trGeoPath](#trGeoPath), but rather than\ngenerate intermediate SVG path strings, this transform produces a shape instance\nthat directly generates drawing commands during rendering resulting in improved\nperformance when using canvas rendering for dynamic maps.\n",
        "type": "String -> List Vega.GeoPathProperty -> Vega.Transform"
      },
      {
        "name": "trGraticule",
        "comment": " Generate a reference grid of meridians (longitude) and parallels (latitude)\nfor cartographic maps. The default graticule has meridians and parallels every\n10° between ±80° latitude; for the polar regions meridians are every 90°.\n\nIt generates a new data stream containing a single GeoJSON data object\nfor the graticule, which can subsequently be drawn using the geopath or geoshape\ntransform.\n\n",
        "type": "List Vega.GraticuleProperty -> Vega.Transform"
      },
      {
        "name": "trIdentifier",
        "comment": " Extend a data object with a globally unique key value. Identifier values are\nassigned using an internal counter. This counter is shared across all instances\nof this transform within a single Vega view, including different data sources,\nbut not across different Vega views.\n",
        "type": "String -> Vega.Transform"
      },
      {
        "name": "trImpute",
        "comment": " Generate new values for missing data. The first parameter is the data field\nfor which missing values should be imputed. The second is a key field that uniquely\nidentifies the data objects within a group and so allows missing values to be\nidentified. The third is a list of optional properties for customising the imputation.\n",
        "type": "Vega.Field -> Vega.Field -> List Vega.ImputeProperty -> Vega.Transform"
      },
      {
        "name": "trJoinAggregate",
        "comment": " Group and summarize an input data stream in a similar way to [trAggregate](#trAggregate)\nbut which is then joined back to the input stream. Helpful for creating derived\nvalues that combine both raw data and aggregate calculations, such as percentages\nof group totals.\n",
        "type": "List Vega.JoinAggregateProperty -> Vega.Transform"
      },
      {
        "name": "trLinkPath",
        "comment": " Route a visual link between two nodes to draw edges in a tree or network layout.\nWrites one property to each datum, providing an SVG path string for the link path.\n",
        "type": "List Vega.LinkPathProperty -> Vega.Transform"
      },
      {
        "name": "trLookup",
        "comment": " Extend a primary data stream by looking up values on a secondary data stream.\nThe first parameter is the name of the secondary data stream upon which to perform\nthe lookup. The second is the key field in that secondary stream. The third is the\nset of key fields from the primary data stream, each of which are then searched\nfor in a single key field of the secondary data stream. Optional customisation\nprovided as a list of properties in the final parameter.\n",
        "type": "String -> Vega.Field -> List Vega.Field -> List Vega.LookupProperty -> Vega.Transform"
      },
      {
        "name": "trNest",
        "comment": " Generate a tree data structure from input data objects by dividing children\ninto groups based on distinct field values. This can provide input to tree layout\nmethods such as [trTree](#trTree), [trTreemap](#trTreemap), [trPack](#trPack) and\n[trPartition](#trPartition).\n",
        "type": "List Vega.Field -> Vega.Boo -> Vega.Transform"
      },
      {
        "name": "trPack",
        "comment": " Compute an enclosure diagram that uses containment (nesting) to represent a\nhierarchy. The size of the leaf circles encodes a quantitative dimension of the\ndata. The enclosing circles show the approximate cumulative size of each subtree,\nbut due to wasted space there is some distortion; only the leaf nodes can be\ncompared accurately.\n",
        "type": "List Vega.PackProperty -> Vega.Transform"
      },
      {
        "name": "trPartition",
        "comment": " Compute the layout for an adjacency diagram: a space-filling variant of a node-link\ntree diagram. Nodes are drawn as solid areas (either arcs or rectangles) sized by\nsome quantitative field, and their placement relative to other nodes reveals their\nposition in the hierarchy.\n",
        "type": "List Vega.PartitionProperty -> Vega.Transform"
      },
      {
        "name": "trPie",
        "comment": " Calculates the angular extents of arc segments laid out in a circle, for example\nto create a pie chart. Writes two properties to each datum, indicating the starting\nand ending angles (in radians) of an arc.\n",
        "type": "List Vega.PieProperty -> Vega.Transform"
      },
      {
        "name": "trPivot",
        "comment": " Map unique values from a field to new aggregated fields in the output stream.\nThe first parameter is the field to pivot on (providing new field names). The second\nis the field containing values to aggregate to populate new values. The third allows\nthe transform to be customised.\n",
        "type": "Vega.Field -> Vega.Field -> List Vega.PivotProperty -> Vega.Transform"
      },
      {
        "name": "trProject",
        "comment": " Perform a relational algebra projection transform resulting in a new stream\nof derived data objects that include one or more fields from the input stream.\nThe parameter is a list of field-name pairs where the fields are those fields to\nbe copied over in the projection and the names are the new names to give the\nprojected fields.\n",
        "type": "List ( Vega.Field, String ) -> Vega.Transform"
      },
      {
        "name": "trResolveFilter",
        "comment": " Use a filter mask generated by a crossfilter transform to generate filtered\ndata streams efficiently. The first prarameter is the signal created by\n[trCrossFilterAsSignal](#trCrossFilterAsSignal) and the second a bit mask indicating\nwhich fields in the crossfilter should be ignored. Each bit corresponds to a field\nand query in the crossfilter transform’s fields and query lists. If the corresponding\nbit is on, that field and query will be ignored when resolving the filter. All other\nqueries must pass the filter for a tuple to be included downstream.\n",
        "type": "String -> Vega.Num -> Vega.Transform"
      },
      {
        "name": "trSample",
        "comment": " Generate a random sample from a data stream to generate a smaller stream. The\nparameter determines the maximum number of data items to sample.\n",
        "type": "Vega.Num -> Vega.Transform"
      },
      {
        "name": "trSequence",
        "comment": " Generate a data stream of numbers between a start (first parameter) and end\n(second parameter) inclusive in increments specified by the third parameter. If\nthe end value is less than the start value, the third parameter should be negative.\nThe resulting output field will be called `data`.\n\nSequences can be used to feed other transforms to generate data to create random\n(x,y) coordinates:\n\n    dataSource\n        [ data \"randomData\" []\n            |> transform\n                [ trSequence (num 1) (num 1000) (num 1)\n                , trFormula \"random()\" \"x\"\n                , trFormula \"random()\" \"y\"\n                ]\n        ]\n\n",
        "type": "Vega.Num -> Vega.Num -> Vega.Num -> Vega.Transform"
      },
      {
        "name": "trSequenceAs",
        "comment": " Similar to [trSequence](#trSequence) but allowing the resulting sequence to\nbe named (fourth parameter).\n",
        "type": "Vega.Num -> Vega.Num -> Vega.Num -> String -> Vega.Transform"
      },
      {
        "name": "trStack",
        "comment": " Compute a layout by stacking groups of values. The most common use case is to\ncreate stacked graphs, including stacked bar charts and stream graphs. This\ntransform writes two properties to each datum, indicating the starting and ending\nstack values.\n",
        "type": "List Vega.StackProperty -> Vega.Transform"
      },
      {
        "name": "trStratify",
        "comment": " Generate a hierarchical (tree) data structure from input data objects, based\non key fields that match an id for each node (first parameter) and their parent's\nkey (second parameter) nodes. Internally, this transform generates a set of tree\nnode objects that can then be processed by tree layout methods such as tree,\ntreemap, pack, and partition.\n",
        "type": "Vega.Field -> Vega.Field -> Vega.Transform"
      },
      {
        "name": "trTree",
        "comment": " Compute a node-link diagram layout for hierarchical data. Supports both cluster\nlayouts (for example to create dendrograms) and tidy layouts.\n",
        "type": "List Vega.TreeProperty -> Vega.Transform"
      },
      {
        "name": "trTreeLinks",
        "comment": " Generate a new stream of data objects representing links between nodes in a\ntree. This transform must occur downstream of a tree-generating transform such as\n[trNest](#trNest) or [trStratify](#trStratify). The generated link objects will\nhave `source` and `target` fields that reference input data objects corresponding\nto parent (source) and child (target) nodes.\n",
        "type": "Vega.Transform"
      },
      {
        "name": "trTreemap",
        "comment": " Recursively subdivide an area into rectangles with areas proportional to each\nnode’s associated value.\n",
        "type": "List Vega.TreemapProperty -> Vega.Transform"
      },
      {
        "name": "trVoronoi",
        "comment": " Compute a voronoi diagram for a set of input points and return the computed\ncell paths.\n",
        "type": "Vega.Field -> Vega.Field -> List Vega.VoronoiProperty -> Vega.Transform"
      },
      {
        "name": "trWindow",
        "comment": " Performs calculations such as ranking, lead/lag analysis and running sums over\nsorted groups of data objects . Calculated values are written back to the input\ndata stream.\n\n    transform\n        [ trWindow [ wnOperation RowNumber \"rank\" ]\n            [ wnSort [ ( field \"myField\", Descend ) ] ]\n        ]\n\n",
        "type": "List Vega.WindowOperation -> List Vega.WindowProperty -> Vega.Transform"
      },
      {
        "name": "trWordcloud",
        "comment": " Compute a word cloud layour similar to a 'wordle'. Useful for visualising the\nrelative frequency of words or phrases.\n\n    mark Text\n        [ mTransform\n            [ trWordcloud\n                [ wcSize (nums [ 800, 400 ])\n                , wcText (field \"text\")\n                , wcRotate (numExpr (exField \"datum.angle\"))\n                , wcFontSize (numExpr (exField \"datum.count\"))\n                , wcFontWeight (strExpr (exField \"datum.weight\"))\n                , wcFontSizeRange (nums [ 12, 56 ])\n                ]\n            ]\n        ]\n\n",
        "type": "List Vega.WordcloudProperty -> Vega.Transform"
      },
      {
        "name": "transform",
        "comment": " Apply the given ordered list of transforms to the given data stream. Transform\nexamples include filtering, creating new data fields from expressions and creating\nnew data fields suitable for a range of visualization and layout types.\n",
        "type": "List Vega.Transform -> Vega.DataTable -> Vega.DataTable"
      },
      {
        "name": "transparent",
        "comment": " Convenience function for specifying a transparent setting for marks that can\nbe colored (e.g. with [maFill](#maFill))\n",
        "type": "Vega.Value"
      },
      {
        "name": "treeMethodSignal",
        "comment": " Tree layout method (`tidy` or `cluster`) referenced by the value in the named signal.\n",
        "type": "String -> Vega.TreeMethod"
      },
      {
        "name": "treemapMethodSignal",
        "comment": " Treemap layout method referenced by the value in the named signal.\n",
        "type": "String -> Vega.TreemapMethod"
      },
      {
        "name": "trigger",
        "comment": " Creates a trigger that may be applied to a data table or mark.\nThe first parameter is the name of the trigger and the second\na list of trigger actions.\n",
        "type": "String -> List Vega.TriggerProperty -> Vega.Trigger"
      },
      {
        "name": "true",
        "comment": " A Boolean true value.\n",
        "type": "Vega.Boo"
      },
      {
        "name": "vAlignSignal",
        "comment": " Vertical text alignment referenced by the value in the named signal.\n",
        "type": "String -> Vega.VAlign"
      },
      {
        "name": "vAlphabetic",
        "comment": " Convenience function for indicating an alphabetic vertical alignment.\n",
        "type": "Vega.Value"
      },
      {
        "name": "vBand",
        "comment": " Band number or fraction of a band number. Band scales are used when\naggregating data into discrete categories such as in a frequency histogram.\n",
        "type": "Vega.Num -> Vega.Value"
      },
      {
        "name": "vBoos",
        "comment": " A list of Boolean values.\n",
        "type": "List Bool -> Vega.Value"
      },
      {
        "name": "vBottom",
        "comment": " Convenience function for indicating a bottom vertical alignment.\n",
        "type": "Vega.Value"
      },
      {
        "name": "vColor",
        "comment": " A color value.\n",
        "type": "Vega.ColorValue -> Vega.Value"
      },
      {
        "name": "vExponent",
        "comment": " An exponential value modifier.\n",
        "type": "Vega.Value -> Vega.Value"
      },
      {
        "name": "vFalse",
        "comment": " A 'false' value.\n",
        "type": "Vega.Value"
      },
      {
        "name": "vField",
        "comment": " A data or signal field.\n",
        "type": "Vega.Field -> Vega.Value"
      },
      {
        "name": "vMiddle",
        "comment": " Convenience function for indicating a middle vertical alignment.\n",
        "type": "Vega.Value"
      },
      {
        "name": "vMultiply",
        "comment": " A multiplication value modifier.\n",
        "type": "Vega.Value -> Vega.Value"
      },
      {
        "name": "vNull",
        "comment": " An absence of a value.\n",
        "type": "Vega.Value"
      },
      {
        "name": "vNum",
        "comment": " A numeric value.\n",
        "type": "Float -> Vega.Value"
      },
      {
        "name": "vNums",
        "comment": " A list of numbers.\n",
        "type": "List Float -> Vega.Value"
      },
      {
        "name": "vObject",
        "comment": " Object containing a list of [key-value](#keyValue) pairs.\n",
        "type": "List Vega.Value -> Vega.Value"
      },
      {
        "name": "vOffset",
        "comment": " An additive value modifier.\n",
        "type": "Vega.Value -> Vega.Value"
      },
      {
        "name": "vRound",
        "comment": " A rounding value modifier. Rounding is applied after all other modifiers.\n",
        "type": "Vega.Boo -> Vega.Value"
      },
      {
        "name": "vScale",
        "comment": " Name of a scale.\n",
        "type": "String -> Vega.Value"
      },
      {
        "name": "vScaleField",
        "comment": " A scale field used to dynamically look up a scale name.\n",
        "type": "Vega.Field -> Vega.Value"
      },
      {
        "name": "vSignal",
        "comment": " A named signal.\n",
        "type": "String -> Vega.Value"
      },
      {
        "name": "vStr",
        "comment": " A string value.\n",
        "type": "String -> Vega.Value"
      },
      {
        "name": "vStrs",
        "comment": " A list of string values.\n",
        "type": "List String -> Vega.Value"
      },
      {
        "name": "vTop",
        "comment": " Convenience function for indicating a top vertical alignment.\n",
        "type": "Vega.Value"
      },
      {
        "name": "vTrue",
        "comment": " A 'true' value.\n",
        "type": "Vega.Value"
      },
      {
        "name": "vValues",
        "comment": " List of values. Useful for nesting collections of possibly mixed types.\n",
        "type": "List Vega.Value -> Vega.Value"
      },
      {
        "name": "voAs",
        "comment": " Name of the output field of a voronoi transform. If not specified, the default\nis `path`.\n",
        "type": "String -> Vega.VoronoiProperty"
      },
      {
        "name": "voExtent",
        "comment": " Extent of the voronoi cells in a voronoi transform. The two parameters\nshould each evaluate to a list of two numbers representing the coordinates of the\ntop-left and bottom-right of the extent respectively.\n",
        "type": "Vega.Num -> Vega.Num -> Vega.VoronoiProperty"
      },
      {
        "name": "voSize",
        "comment": " Extent of the voronoi cells in a voronoi transform. The single parameter\nshould evaluate to a list of two numbers representing the bottom-right of the extent.\nThe top-left is assumed to be [0,0].\n",
        "type": "Vega.Num -> Vega.VoronoiProperty"
      },
      {
        "name": "wOperationSignal",
        "comment": " Window operation referenced by the value in the named signal. For names of\nvalid window operations see the\n[Vega window operation documentation](https://vega.github.io/vega/docs/transforms/window/#ops)\n",
        "type": "String -> Vega.WOperation"
      },
      {
        "name": "wcAs",
        "comment": " Name output fields created by a word cloud transform. The parameters\nmap to the following default values: `x`, `y`, `font`, `fontSize`, `fontStyle`,\n`fontWeight` and `angle`.\n",
        "type": "String -> String -> String -> String -> String -> String -> String -> Vega.WordcloudProperty"
      },
      {
        "name": "wcFont",
        "comment": " Font family to use for a word in a wordcloud.\n",
        "type": "Vega.Str -> Vega.WordcloudProperty"
      },
      {
        "name": "wcFontSize",
        "comment": " Font size to use for a word in a wordcloud.\n",
        "type": "Vega.Num -> Vega.WordcloudProperty"
      },
      {
        "name": "wcFontSizeRange",
        "comment": " Font size range to use for words in a wordcloud. The parameter should\nresolve to a two-element list [min, max]. The size of words in a wordcloud will be\nscaled to lie in the given range according to the square root scale.\n",
        "type": "Vega.Num -> Vega.WordcloudProperty"
      },
      {
        "name": "wcFontStyle",
        "comment": " Font style to use for words in a wordcloud.\n",
        "type": "Vega.Str -> Vega.WordcloudProperty"
      },
      {
        "name": "wcFontWeight",
        "comment": " Font weights to use for words in a wordcloud.\n",
        "type": "Vega.Str -> Vega.WordcloudProperty"
      },
      {
        "name": "wcPadding",
        "comment": " Padding, in pixels, to be placed around words in a wordcloud.\n",
        "type": "Vega.Num -> Vega.WordcloudProperty"
      },
      {
        "name": "wcRotate",
        "comment": " Angle in degrees of words in a wordcloud layout.\n",
        "type": "Vega.Num -> Vega.WordcloudProperty"
      },
      {
        "name": "wcSize",
        "comment": " Size of layout created by a wordcloud transform. The parameter should\nresolve to a two-element list [width, height] in pixels.\n",
        "type": "Vega.Num -> Vega.WordcloudProperty"
      },
      {
        "name": "wcSpiral",
        "comment": " Spiral layout method for a wordcloud transform.\n",
        "type": "Vega.Spiral -> Vega.WordcloudProperty"
      },
      {
        "name": "wcText",
        "comment": " Data field with the input word text for a wordcloud transform.\n",
        "type": "Vega.Field -> Vega.WordcloudProperty"
      },
      {
        "name": "white",
        "comment": " Convenience function for specifying a white color setting for marks that can\nbe colored (e.g. with [maStroke](#maStroke))\n",
        "type": "Vega.Value"
      },
      {
        "name": "width",
        "comment": " Override the default width of the visualization. If not specified the width\nwill be calculated based on the content of the visualization.\n",
        "type": "Float -> ( Vega.VProperty, Vega.Spec )"
      },
      {
        "name": "wnAggOperation",
        "comment": " Aggregate operation to be applied during a window transformation.\nThis version is suitable for operations without parameters (e.g. `RowNumber`) and\nthat are not applied to a specific field.\n\nThe parameters are the operation to apply, the input field (or `Nothing` if no input\nfield) and the name to give to the field which will contain the results of the calculation.\n\nThe example below calculates the average over an unbounded window:\n\n    transform\n        [ trWindow [ wnAggOperation Mean (Just (field \"IMDB_Rating\")) \"avScore\" ]\n            [ wnFrame numNull ]\n        ]\n\n",
        "type": "Vega.Operation -> Maybe.Maybe Vega.Field -> String -> Vega.WindowOperation"
      },
      {
        "name": "wnFrame",
        "comment": " Two-element list indicating how a sliding window should proceed during a window\ntransform. The list entries should either be a number indicating the offset from\nthe current data object, or `NumNull` to indicate unbounded rows preceding or\nfollowing the current data object.\n",
        "type": "Vega.Num -> Vega.WindowProperty"
      },
      {
        "name": "wnGroupBy",
        "comment": " Data fields by which to partition data objects into separate windows\nduring a window transform. If not specified, a single group containing all data\nobjects will be used.\n",
        "type": "List Vega.Field -> Vega.WindowProperty"
      },
      {
        "name": "wnIgnorePeers",
        "comment": " Whether or not a sliding frame in a window transform should ignore\npeer values.\n",
        "type": "Vega.Boo -> Vega.WindowProperty"
      },
      {
        "name": "wnOperation",
        "comment": " Window-specific operation to be applied during a window transformation.\nThis version is suitable for operations without parameters (e.g. `RowNumber`) and\nthat are not applied to a specific field.\n\nThe parameters are the operation to apply and the name to give to the field which\nwill contain the results of the calculation.\n\n    transform\n        [ trWindow [ wnOperation Rank \"order\" ]\n            [ wnSort [ ( field \"Gross\", Descend ) ] ]\n        ]\n\n",
        "type": "Vega.WOperation -> String -> Vega.WindowOperation"
      },
      {
        "name": "wnOperationOn",
        "comment": " Window-specific operation to be applied during a window transformation.\nThis version is suitable for operations that have a parameter (e.g. `Lag` or `Lead`)\nand/or operations that require a specific field as input (e.g. `LastValue`).\nThe parameters are in order: the type of operation, a possible operation parameter,\nthe field to apply it to and its output field name.\n\n    transform\n        [ trWindow\n            [ wnOperationOn Lag\n                (Just (num 5))\n                (Just (field \"temperature\"))\n                \"oldTemp\"\n            ]\n            []\n        ]\n\n",
        "type": "Vega.WOperation -> Maybe.Maybe Vega.Num -> Maybe.Maybe Vega.Field -> String -> Vega.WindowOperation"
      },
      {
        "name": "wnSort",
        "comment": " Indicate how sorting data objects is applied within a window transform.\n\n    transform\n        [ trWindow [ wnOperation RowNumber \"order\" ]\n          [ wnSort [ ( field \"score\", Ascend ) ] ]\n        ]\n\nIf two objects are equal in terms of sorting field datum by they are considered\n'peers'. If no sorting comparator is specified, data objects are processed in the\norder they are observed.\n\n",
        "type": "List ( Vega.Field, Vega.Order ) -> Vega.WindowProperty"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "VegaLite",
    "comment": " Create Vega-Lite specifications in Elm. A specification can be sent to a\nVega-Lite compiler to generate the graphics. While this a pure Elm library, to\ngenerate the graphical output you probably want to send the JSON generated by\n`toVegaLite` via a port to some JavaScript that invokes the Vega-Lite runtime.\n\n\n# Creating A Vega-Lite Specification\n\n@docs toVegaLite\n@docs VLProperty\n@docs Spec\n@docs LabelledSpec\n@docs combineSpecs\n\n\n# Creating the Data Specification\n\nFunctions and types for declaring the data to the visualized. See the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/data.html#format).\n\n@docs dataFromUrl\n@docs dataFromColumns\n@docs dataFromRows\n@docs dataFromJson\n@docs dataFromSource\n@docs dataName\n@docs datasets\n@docs dataColumn\n@docs dataRow\n@docs Data\n@docs DataColumn\n@docs DataRow\n\n\n## Geographic Data\n\n@docs geometry\n@docs geoFeatureCollection\n@docs geometryCollection\n@docs geoPoint\n@docs geoPoints\n@docs geoLine\n@docs geoLines\n@docs geoPolygon\n@docs geoPolygons\n@docs DataType\n\n\n## Formatting Input Data\n\nSee the Vega-Lite\n[format](https://vega.github.io/vega-lite/docs/data.html#format) and\n[JSON](https://vega.github.io/vega-lite/docs/data.html#json) documentation.\n\n@docs Format\n@docs jsonProperty\n@docs topojsonFeature\n@docs topojsonMesh\n@docs parse\n@docs dsv\n\n@docs foDate\n@docs foUtc\n\n\n# Creating the Transform Specification\n\nTransformation rules are applied to data fields or geospatial coordinates before\nthey are encoded visually.\n\n@docs transform\n\n\n## Map Projections\n\nSee the\n[Vega-Lite map projection documentation](https://vega.github.io/vega-lite/docs/projection.html).\n\n@docs projection\n\n@docs prType\n@docs prClipAngle\n@docs prClipExtent\n@docs prCenter\n@docs prRotate\n@docs prPrecision\n@docs prCoefficient\n@docs prDistance\n@docs prFraction\n@docs prLobes\n@docs prParallel\n@docs prRadius\n@docs prRatio\n@docs prSpacing\n@docs prTilt\n\n@docs Projection\n@docs customProjection\n@docs ClipRect\n@docs clipRect\n\n\n## Aggregation\n\nSee the\n[Vega-Lite aggregate documentation](https://vega.github.io/vega-lite/docs/aggregate.html).\n\n@docs aggregate\n@docs Operation\n@docs opAs\n@docs timeUnitAs\n\n\n## Binning\n\nSee the [Vega-Lite binning documentation](https://vega.github.io/vega-lite/docs/bin.html).\n\n@docs binAs\n@docs biBase\n@docs biDivide\n@docs biExtent\n@docs biMaxBins\n@docs biMinStep\n@docs biNice\n@docs biStep\n@docs biSteps\n\n\n## Stacking\n\nSee the [Vega-Lite stack documentation](https://vega.github.io/vega-lite/docs/stack.html)\n\n@docs stack\n@docs stOffset\n@docs StackOffset\n@docs stSort\n@docs stAscending\n@docs stDescending\n\n\n## Data Calculation\n\nSee\n[Vega-Lite calculate documentation](https://vega.github.io/vega-lite/docs/calculate.html).\n\n@docs calculateAs\n\n\n## Filtering\n\nSee the\n[Vega-Lite filter documentation](https://vega.github.io/vega-lite/docs/filter.html).\n\n@docs filter\n\n@docs fiEqual\n@docs fiLessThan\n@docs fiLessThanEq\n@docs fiGreaterThan\n@docs fiGreaterThanEq\n@docs fiExpr\n@docs fiCompose\n@docs fiSelection\n@docs fiOneOf\n@docs fiRange\n@docs fiValid\n@docs numRange\n@docs dtRange\n\n\n## Flattening\n\nSee the Vega-Lite [flatten](https://vega.github.io/vega-lite/docs/flatten.html)\nand [fold](https://vega.github.io/vega-lite/docs/fold.html) documentation.\n\n@docs flatten\n@docs flattenAs\n@docs fold\n@docs foldAs\n\n\n## Relational Joining (lookup)\n\nSee the [Vega-Lite lookup documentation](https://vega.github.io/vega-lite/docs/lookup.html).\n\n@docs lookup\n@docs lookupAs\n\n\n## Data Imputation\n\nImpute missing data. See the\n[Vega-Lite impute documentation](https://vega.github.io/vega-lite/docs/impute.html#transform).\n\n@docs impute\n@docs imFrame\n@docs imKeyVals\n@docs imKeyValSequence\n@docs imMethod\n@docs ImMethod\n@docs imGroupBy\n@docs imValue\n\n\n## Data Sampling\n\nSee the [Vega-Lite sample documentation](https://vega.github.io/vega-lite/docs/sample.html)\n\n@docs sample\n\n\n## Window Transformations\n\nSee the Vega-Lite\n[window transform field](https://vega.github.io/vega-lite/docs/window.html#field-def)\nand [window transform](https://vega.github.io/vega-lite/docs/window.html#window-transform-definition)\ndocumentation.\n\n@docs window\n@docs wiAggregateOp\n@docs wiOp\n@docs WindowOperation\n@docs wiParam\n@docs wiField\n\n@docs wiFrame\n@docs wiIgnorePeers\n@docs wiGroupBy\n@docs wiSort\n@docs wiAscending\n@docs wiDescending\n\n\n# Creating the Mark Specification\n\nFunctions for declaring the type of visual marks used in the visualization.\n\n@docs area\n@docs bar\n@docs boxplot\n@docs errorband\n@docs errorbar\n@docs circle\n@docs geoshape\n@docs line\n@docs point\n@docs rect\n@docs rule\n@docs square\n@docs textMark\n@docs tick\n@docs trail\n\n\n## Mark Properties\n\nSee the Vega-Lite\n[general mark](https://vega.github.io/vega-lite/docs/mark.html#general-mark-properties),\n[area mark](https://vega.github.io/vega-lite/docs/area.html#properties),\n[bar mark](https://vega.github.io/vega-lite/docs/bar.html),\n[hyperlink mark](https://vega.github.io/vega-lite/docs/mark.html#hyperlink),\n[line mark](https://vega.github.io/vega-lite/docs/line.html#properties),\n[point mark](https://vega.github.io/vega-lite/docs/point.html#properties),\n[text mark](https://vega.github.io/vega-lite/docs/text.html) and\n[tick mark](https://vega.github.io/vega-lite/docs/tick.html#config)\nproperty documentation.\n\n@docs maAlign\n@docs maAngle\n@docs maBandSize\n@docs maBaseline\n@docs maBinSpacing\n@docs maBorders\n@docs maClip\n@docs maColor\n@docs maCursor\n@docs maExtent\n@docs maHRef\n@docs maContinuousBandSize\n@docs maDiscreteBandSize\n@docs maDx\n@docs maDy\n@docs maFill\n@docs maFilled\n@docs maFillOpacity\n@docs maFont\n@docs maFontSize\n@docs maFontStyle\n@docs maFontWeight\n@docs maInterpolate\n@docs maOpacity\n@docs maOrient\n@docs maPoint\n@docs maLine\n@docs maRadius\n@docs maRule\n@docs maShape\n@docs maShortTimeLabels\n@docs maSize\n@docs maStroke\n@docs maStrokeCap\n@docs StrokeCap\n@docs maStrokeDash\n@docs maStrokeDashOffset\n@docs maStrokeJoin\n@docs StrokeJoin\n@docs maStrokeMiterLimit\n@docs maStrokeOpacity\n@docs maStrokeWidth\n@docs maStyle\n@docs maTension\n@docs maText\n@docs maTheta\n@docs maThickness\n@docs maTicks\n@docs maTooltip\n@docs maXOffset\n@docs maYOffset\n@docs maX2Offset\n@docs maY2Offset\n\n\n### Used by Mark Properties\n\n@docs MarkOrientation\n@docs MarkInterpolation\n@docs Symbol\n@docs symbolPath\n@docs Cursor\n@docs PointMarker\n@docs pmMarker\n@docs LineMarker\n@docs lmMarker\n@docs SummaryExtent\n@docs iqrScale\n@docs TooltipContent\n\n\n# Creating the Encoding Specification\n\nTypes and functions for declaring which data fields (data) are mapped to which channels\n(position, color etc.).\n\n@docs encoding\n@docs Measurement\n\n\n## Position channel\n\nRelates to where something appears in the visualization.\nSee the\n[Vega-Lite position documentation](https://vega.github.io/vega-lite/docs/encoding.html#position)\n\n@docs position\n@docs Position\n\n\n### Position Channel Properties\n\n@docs pName\n@docs pRepeat\n@docs pMType\n@docs pBin\n@docs pBinned\n@docs pTimeUnit\n@docs pTitle\n@docs pAggregate\n@docs pScale\n@docs pAxis\n@docs pSort\n@docs pStack\n@docs pWidth\n@docs pHeight\n@docs pImpute\n\n\n## Properties Used by Position Channels\n\n\n## Sorting Properties\n\nSee the\n[Vega-Lite sort documentation](https://vega.github.io/vega-lite/docs/sort.html).\n\n@docs SortProperty\n@docs soByField\n@docs soByRepeat\n@docs soCustom\n\n\n## Axis Properties\n\nSee the\n[Vega-Lite axis property documentation](https://vega.github.io/vega-lite/docs/axis.html#axis-properties)\n\n@docs axDomain\n@docs axFormat\n@docs axGrid\n@docs axLabelAngle\n@docs axLabelOverlap\n@docs axLabelPadding\n@docs axLabels\n@docs axMaxExtent\n@docs axMinExtent\n@docs axOffset\n@docs axOrient\n@docs axPosition\n\n@docs axBandPosition\n@docs axDates\n@docs axDomainColor\n@docs axDomainOpacity\n@docs axDomainWidth\n@docs axLabelAlign\n@docs axLabelBaseline\n@docs axLabelBound\n@docs axLabelColor\n@docs axLabelFlush\n@docs axLabelFlushOffset\n@docs axLabelFont\n@docs axLabelFontSize\n@docs axLabelFontWeight\n@docs axLabelLimit\n@docs axLabelOpacity\n@docs axTickColor\n@docs axTickCount\n@docs axTickExtra\n@docs axTickOffset\n@docs axTickOpacity\n@docs axTickRound\n@docs axTicks\n@docs axTickSize\n@docs axTickStep\n@docs axTickWidth\n@docs axTitle\n@docs axTitleAlign\n@docs axTitleAngle\n@docs axTitleBaseline\n@docs axTitleColor\n@docs axTitleFont\n@docs axTitleFontSize\n@docs axTitleFontWeight\n@docs axTitleLimit\n@docs axTitleOpacity\n@docs axTitlePadding\n@docs axTitleX\n@docs axTitleY\n@docs axValues\n@docs axZIndex\n\n\n## Positioning Constants\n\n@docs OverlapStrategy\n@docs Side\n@docs HAlign\n@docs VAlign\n\n\n## Mark channels\n\nRelate to the appearance of the visual marks in the visualization such as their\ncolor or size.\n\n@docs size\n@docs color\n@docs fill\n@docs stroke\n@docs opacity\n@docs shape\n\n\n### Mark Channel Properties\n\n@docs mName\n@docs mRepeat\n@docs mMType\n@docs mScale\n@docs mBin\n@docs mBinned\n@docs mImpute\n@docs mTimeUnit\n@docs mTitle\n@docs mAggregate\n@docs mLegend\n@docs mPath\n@docs mNum\n@docs mStr\n@docs mBoo\n\n\n### Mark Legends\n\nSee the\n[Vega-Lite legend property documentation](https://vega.github.io/vega-lite/docs/legend.html#legend-properties).\n\n@docs leClipHeight\n@docs leColumnPadding\n@docs leColumns\n@docs leCornerRadius\n@docs leDirection\n@docs leFillColor\n@docs leFormat\n@docs leGradientLength\n@docs leGradientThickness\n@docs leGradientStrokeColor\n@docs leGradientStrokeWidth\n@docs leGridAlign\n@docs leLabelAlign\n@docs leLabelBaseline\n@docs leLabelColor\n@docs leLabelFont\n@docs leLabelFontSize\n@docs leLabelLimit\n@docs leLabelOffset\n@docs leLabelOverlap\n@docs leOffset\n@docs leOrient\n@docs lePadding\n@docs leRowPadding\n@docs leStrokeColor\n@docs leStrokeWidth\n@docs leSymbolFillColor\n@docs leSymbolSize\n@docs leSymbolStrokeColor\n@docs leSymbolStrokeWidth\n@docs leSymbolType\n@docs leTickCount\n@docs leTitle\n@docs leTitleAlign\n@docs leTitleBaseline\n@docs leTitleColor\n@docs leTitleFont\n@docs leTitleFontSize\n@docs leTitleFontWeight\n@docs leTitleLimit\n@docs leTitlePadding\n@docs leType\n@docs leValues\n@docs leZIndex\n\n@docs Legend\n@docs LegendOrientation\n@docs leNums\n@docs leStrs\n@docs leDts\n\n\n## Text Channels\n\nRelate to the appearance of the text and tooltip elements of the visualization.\nSee the\n[Vega-Lite text documentation](https://vega.github.io/vega-lite/docs/encoding.html#text)\n\n@docs text\n@docs tooltip\n@docs tooltips\n@docs tName\n@docs tRepeat\n@docs tMType\n@docs tBin\n@docs tBinned\n@docs tAggregate\n@docs tTimeUnit\n@docs tTitle\n@docs tFormat\n@docs FontWeight\n\n\n## Hyperlink Channel\n\nRelates to a clickable URL destination of a mark. Unlike most other channels, the\nhyperlink channel has no direct visual expression other than the option of changing\nthe cursor style when hovering, so an encoding will usually pair hyperlinks with\nother visual channels such as marks or texts. See the\n[Vega-Lite hyperlink documentation](https://vega.github.io/vega-lite/docs/encoding.html#href)\n\n@docs hyperlink\n@docs hName\n@docs hRepeat\n@docs hMType\n@docs hBin\n@docs hBinned\n@docs hAggregate\n@docs hTimeUnit\n@docs hStr\n\n\n## Order channels\n\nChannels that relate to the order of data fields such as for sorting stacking order\nor order of data points in a connected scatterplot. See the\n[Vega-Lite order documentation](https://vega.github.io/vega-lite/docs/encoding.html#order).\n\n@docs order\n@docs oName\n@docs oRepeat\n@docs oMType\n@docs oBin\n@docs oAggregate\n@docs oSort\n@docs oTimeUnit\n\n\n## Facet channels\n\nChannels for faceting single plots into small multiples. Can be used to create\ntrellis plots or other arrangements in rows and columns. See the\n[Vega-Lite facet documentation](https://vega.github.io/vega-lite/docs/encoding.html#facet).\nSee also, 'faceted view composition' for a more flexible (but more verbose) way\nof defining faceted views.\n\n@docs row\n@docs column\n\n\n## Level of detail Channel\n\nUsed for grouping data but without changing the visual appearance of a mark. When,\nfor example, a field is encoded by color, all data items with the same value for\nthat field are given the same color. When a detail channel encodes a field, all\ndata items with the same value are placed in the same group. See the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/encoding.html#detail).\n\n@docs detail\n@docs dName\n@docs dMType\n@docs dAggregate\n@docs dBin\n@docs dImpute\n@docs dTimeUnit\n\n\n## Scaling\n\nUsed to specify how the encoding of a data field should be applied. See the\n[Vega-Lite scale documentation](https://vega.github.io/vega-lite/docs/scale.html).\n\n@docs scType\n@docs scDomain\n@docs scRange\n@docs scScheme\n@docs scPadding\n@docs scPaddingInner\n@docs scPaddingOuter\n@docs scRangeStep\n@docs scRound\n@docs scClamp\n@docs scInterpolate\n@docs scNice\n@docs scZero\n@docs scReverse\n\n@docs Scale\n@docs raName\n@docs raNums\n@docs raStrs\n@docs categoricalDomainMap\n@docs domainRangeMap\n@docs ScaleDomain\n@docs doNums\n@docs doStrs\n@docs doDts\n@docs doSelection\n\n@docs ScaleNice\n@docs scNiceTickCount\n@docs scNiceInterval\n\n\n### Color Scaling\n\n@docs CInterpolate\n@docs cubeHelix\n@docs cubeHelixLong\n@docs rgb\n\n\n# Creating view compositions\n\nViews can be combined to create more complex multiview displays. This may involve\nlayering views on top of each other (superposition) or laying them out in adjacent\nspaces (juxtaposition using `repeat`, `facet`, `hConcat` or `vConcat`). Where different\nviews have potentially conflicting channels (e.g. two position scales in a layered\nvisualization) the rules for resolving them can be defined with `resolve`.\nSee the\n[Vega-Lite composition documentation](https://vega.github.io/vega-lite/docs/composition.html)\n\n@docs layer\n@docs hConcat\n@docs vConcat\n@docs resolve\n@docs resolution\n@docs align\n@docs alignRC\n@docs CompositionAlignment\n@docs bounds\n@docs Bounds\n@docs spacing\n@docs spacingRC\n@docs center\n@docs centerRC\n\n@docs reAxis\n@docs reLegend\n@docs reScale\n@docs Channel\n@docs Resolution\n\n\n## Faceted views\n\nSmall multiples each of which show subsets of the same dataset. The specification\ndetermines which field should be used to determine subsets along with their spatial\narrangement. See the\n[Vega-Lite facet documentation](https://vega.github.io/vega-lite/docs/facet.html)\n\n@docs repeat\n@docs rowFields\n@docs columnFields\n@docs facet\n@docs columnBy\n@docs rowBy\n\n@docs fName\n@docs fMType\n@docs fAggregate\n@docs fBin\n@docs fHeader\n@docs fTimeUnit\n\n@docs asSpec\n@docs specification\n@docs Arrangement\n\n\n### Facet Headers\n\nSee\n[Vega-Lite header documentation](https://vega.github.io/vega-lite/docs/header.html)\n\n@docs hdLabelAngle\n@docs hdLabelColor\n@docs hdLabelFont\n@docs hdLabelFontSize\n@docs hdLabelLimit\n@docs hdLabelPadding\n\n@docs hdTitle\n@docs hdTitleAnchor\n@docs hdTitleAngle\n@docs hdTitleBaseline\n@docs hdTitleColor\n@docs hdTitleFont\n@docs hdTitleFontWeight\n@docs hdTitleFontSize\n@docs hdTitleLimit\n@docs hdTitlePadding\n\n@docs hdFormat\n\n\n# Creating Selections for Interaction\n\nSelections allow a visualization to respond to interactions (such as clicking or\ndragging). They transform interactions into data queries. See the Vega-Lite\n[selection](https://vega.github.io/vega-lite/docs/selection.html) and\n[bind](https://vega.github.io/vega-lite/docs/bind.html)\ndocumentation.\n\n@docs selection\n@docs select\n@docs Selection\n@docs SelectionProperty\n@docs seBind\n@docs seEncodings\n@docs seFields\n@docs seNearest\n@docs seOn\n@docs seResolve\n@docs seSelectionMark\n@docs seToggle\n@docs seTranslate\n@docs seZoom\n\n@docs iRange\n@docs iCheckbox\n@docs iRadio\n@docs iSelect\n@docs iText\n@docs iNumber\n@docs iDate\n@docs iTime\n@docs iMonth\n@docs iWeek\n@docs iDateTimeLocal\n@docs iTel\n@docs iColor\n\n@docs inDebounce\n@docs inElement\n@docs inOptions\n@docs inMin\n@docs inMax\n@docs inName\n@docs inStep\n@docs inPlaceholder\n\n@docs SelectionResolution\n\n@docs smFill\n@docs smFillOpacity\n@docs smStroke\n@docs smStrokeDash\n@docs smStrokeDashOffset\n@docs smStrokeOpacity\n@docs smStrokeWidth\n\n\n## Making conditional channel encodings\n\nTo make channel encoding conditional on the result of some interaction, use\n[mSelectionCondition](#mSelectionCondition) (and its 't' and 'h' variants). Similarly\n[mDataCondition](#mDataCondition) (and its 't' and 'h' variants) will encode a mark\nconditionally depending on some data properties such as whether a datum is null\nor an outlier.\n\nFor interaction, once a selection has been defined and named, supplying a set of\nencodings allow mark encodings to become dependent on that selection.\n`mSelectionCondition` is followed firstly a (Boolean) selection and then an\nencoding if that selection is true and another encoding to be applied if it is false.\nThe color specification below states \"whenever data marks are selected with an\ninterval mouse drag, encode the cylinder field with an ordinal color scheme,\notherwise make them grey\":\n\n    sel =\n        selection << select \"myBrush\" Interval []\n\n    enc =\n        encoding\n            << position X [ pName \"Horsepower\", pMType Quantitative ]\n            << position Y [ pName \"Miles_per_Gallon\", pMType Quantitative ]\n            << color\n                [ mSelectionCondition (selectionName \"myBrush\")\n                    [ mName \"Cylinders\", mMType Ordinal ]\n                    [ mStr \"grey\" ]\n                ]\n\nIn a similar way, `mDataCondition` will encocode a mark depending on whether any\npredicate tests are satisfied. Unlike slections, multiple conditions and associated\nencodings can be specified. Each test condition is evaluated in order and only on\nfailure of the test does encoding procede to the next test. If no tests are true,\nthe encoding in the final parameter is applied in a similar way to 'case of'\nexpressions:\n\n    enc =\n        encoding\n            << position X [ pName \"value\", pMType Ordinal ]\n            << color\n                [ mDataCondition\n                    [ ( expr \"datum.value < 40\", [ mStr \"blue\" ] )\n                    , ( expr \"datum.value < 50\", [ mStr \"red\" ] )\n                    , ( expr \"datum.value < 60\", [ mStr \"yellow\" ] )\n                    ]\n                    [ mStr \"black\" ]\n                ]\n\nSee the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/condition.html).\n\n@docs mSelectionCondition\n@docs mDataCondition\n@docs tSelectionCondition\n@docs tDataCondition\n@docs hDataCondition\n@docs hSelectionCondition\n\n@docs and\n@docs or\n@docs not\n@docs expr\n@docs selected\n@docs selectionName\n\n\n# Global Configuration\n\nConfiguration options that affect the entire visualization. These are in addition\nto the data and transform options described above. See the\n[Vega-Lite top level spec documentation](https://vega.github.io/vega-lite/docs/spec.html#top-level-specifications)\n\n@docs name\n@docs title\n@docs description\n@docs height\n@docs width\n@docs padding\n@docs paSize\n@docs paEdges\n@docs autosize\n@docs Autosize\n@docs background\n\n\n## Style Setting\n\nAllows default properties for most marks and guides to be set. See the\n[Vega-Lite configuration documentation](https://vega.github.io/vega-lite/docs/config.html).\n\n@docs configure\n@docs configuration\n\n@docs coArea\n@docs coAutosize\n@docs coAxis\n@docs coAxisX\n@docs coAxisY\n@docs coAxisLeft\n@docs coAxisRight\n@docs coAxisTop\n@docs coAxisBottom\n@docs coAxisBand\n@docs coBackground\n@docs coBar\n@docs coCircle\n@docs coCountTitle\n@docs coFieldTitle\n@docs coGeoshape\n@docs coLegend\n@docs coLine\n@docs coHeader\n@docs coMark\n@docs coNamedStyle\n@docs coNumberFormat\n@docs coPadding\n@docs coPoint\n@docs coProjection\n@docs coRange\n@docs coRect\n@docs coRemoveInvalid\n@docs coRule\n@docs coScale\n@docs coSelection\n@docs coSquare\n@docs coStack\n@docs coText\n@docs coTick\n@docs coTitle\n@docs coTimeFormat\n@docs coTrail\n@docs coView\n\n\n## Axis Configuration Options\n\nSee the\n[Vega-Lite axis config documentation](https://vega.github.io/vega-lite/docs/axis.html#general-config).\n\n@docs axcoBandPosition\n@docs axcoDomain\n@docs axcoDomainColor\n@docs axcoDomainOpacity\n@docs axcoDomainWidth\n@docs axcoMaxExtent\n@docs axcoMinExtent\n@docs axcoGrid\n@docs axcoGridColor\n@docs axcoGridDash\n@docs axcoGridOpacity\n@docs axcoGridWidth\n@docs axcoLabels\n@docs axcoLabelAlign\n@docs axcoLabelAngle\n@docs axcoLabelBaseline\n@docs axcoLabelBound\n@docs axcoLabelColor\n@docs axcoLabelFlush\n@docs axcoLabelFlushOffset\n@docs axcoLabelFontWeight\n@docs axcoLabelFont\n@docs axcoLabelFontSize\n@docs axcoLabelLimit\n@docs axcoLabelOpacity\n@docs axcoLabelOverlap\n@docs axcoLabelPadding\n@docs axcoShortTimeLabels\n@docs axcoTicks\n@docs axcoTickColor\n@docs axcoTickExtra\n@docs axcoTickOffset\n@docs axcoTickOpacity\n@docs axcoTickRound\n@docs axcoTickSize\n@docs axcoTickStep\n@docs axcoTickWidth\n@docs axcoTitleAlign\n@docs axcoTitleAngle\n@docs axcoTitleBaseline\n@docs axcoTitleColor\n@docs axcoTitleFont\n@docs axcoTitleFontWeight\n@docs axcoTitleFontSize\n@docs axcoTitleLimit\n@docs axcoTitleOpacity\n@docs axcoTitlePadding\n@docs axcoTitleX\n@docs axcoTitleY\n\n\n## Legend Configuration Options\n\nSee the\n[Vega-Lite legend configuration documentation](https://vega.github.io/vega-lite/docs/legend.html#config).\n\n@docs lecoClipHeight\n@docs lecoColumnPadding\n@docs lecoColumns\n@docs lecoCornerRadius\n@docs lecoFillColor\n@docs lecoOrient\n@docs lecoOffset\n@docs lecoStrokeColor\n@docs lecoStrokeDash\n@docs lecoStrokeWidth\n@docs lecoPadding\n@docs lecoRowPadding\n@docs lecoGradientDirection\n@docs lecoGradientLabelBaseline\n@docs lecoGradientLabelLimit\n@docs lecoGradientLabelOffset\n@docs lecoGradientStrokeColor\n@docs lecoGradientStrokeWidth\n@docs lecoGradientHeight\n@docs lecoGradientWidth\n@docs lecoGridAlign\n@docs lecoLabelAlign\n@docs lecoLabelBaseline\n@docs lecoLabelColor\n@docs lecoLabelFont\n@docs lecoLabelFontSize\n@docs lecoLabelLimit\n@docs lecoLabelOffset\n@docs lecoLabelOverlap\n@docs lecoShortTimeLabels\n@docs lecoEntryPadding\n@docs lecoSymbolBaseFillColor\n@docs lecoSymbolBaseStrokeColor\n@docs lecoSymbolDirection\n@docs lecoSymbolFillColor\n@docs lecoSymbolOffset\n@docs lecoSymbolSize\n@docs lecoSymbolStrokeColor\n@docs lecoSymbolStrokeWidth\n@docs lecoSymbolType\n@docs lecoTitleAlign\n@docs lecoTitleBaseline\n@docs lecoTitleColor\n@docs lecoTitleFont\n@docs lecoTitleFontSize\n@docs lecoTitleFontWeight\n@docs lecoTitleLimit\n@docs lecoTitlePadding\n\n\n## Scale Configuration Options\n\nSee the\n[Vega-Lite scale configuration documentation](https://vega.github.io/vega-lite/docs/scale.html#scale-config)\n\n@docs sacoBandPaddingInner\n@docs sacoBandPaddingOuter\n@docs sacoClamp\n@docs sacoMaxBandSize\n@docs sacoMinBandSize\n@docs sacoMaxFontSize\n@docs sacoMinFontSize\n@docs sacoMaxOpacity\n@docs sacoMinOpacity\n@docs sacoMaxSize\n@docs sacoMinSize\n@docs sacoMaxStrokeWidth\n@docs sacoMinStrokeWidth\n@docs sacoPointPadding\n@docs sacoRangeStep\n@docs sacoRound\n@docs sacoTextXRangeStep\n@docs sacoUseUnaggregatedDomain\n\n\n## Scale Range Configuration Options\n\nSee the\n[Vega-Lite scheme configuration documentation](https://vega.github.io/vega/docs/schemes/#scheme-properties).\n\n@docs racoCategory\n@docs racoDiverging\n@docs racoHeatmap\n@docs racoOrdinal\n@docs racoRamp\n@docs racoSymbol\n\n\n## Title Configuration Options\n\nSee the\n[Vega-Lite title configuration documentation](https://vega.github.io/vega-lite/docs/title.html#config)\n\n@docs ticoAnchor\n@docs ticoAngle\n@docs ticoBaseline\n@docs ticoColor\n@docs ticoFont\n@docs ticoFontSize\n@docs ticoFontWeight\n@docs ticoLimit\n@docs ticoOffset\n@docs ticoOrient\n\n\n## View Configuration Options\n\nSee the\n[Vega-Lite view configuration documentation](https://vega.github.io/vega-lite/docs/spec.html#config)\n\n@docs vicoWidth\n@docs vicoHeight\n@docs vicoClip\n@docs vicoFill\n@docs vicoFillOpacity\n@docs vicoStroke\n@docs vicoStrokeOpacity\n@docs vicoStrokeWidth\n@docs vicoStrokeDash\n@docs vicoStrokeDashOffset\n\n@docs APosition\n\n@docs FieldTitleProperty\n\n\n# General Data functions\n\nIn addition to more general data types like integers and string, the following types\ncan carry data used in specifications.\n\n@docs boo\n@docs true\n@docs false\n@docs dt\n@docs num\n@docs str\n@docs boos\n@docs dts\n@docs nums\n@docs strs\n\n\n## Temporal Data\n\nSee the\n[Vega-Lite dateTime documentation](https://vega.github.io/vega-lite/docs/types.html#datetime)\n\n@docs dtYear\n@docs dtQuarter\n@docs dtMonth\n@docs dtDate\n@docs dtDay\n@docs dtHour\n@docs dtMinute\n@docs dtSecond\n@docs dtMillisecond\n@docs MonthName\n@docs DayName\n\n@docs TimeUnit\n@docs utc\n\n---\n\n\n# Type Reference\n\nTypes that are not specified directly, provided here for reference with links\nto the functions that generate them.\n\n@docs PositionChannel\n@docs MarkChannel\n@docs DetailChannel\n@docs FacetChannel\n@docs HyperlinkChannel\n@docs OrderChannel\n@docs TextChannel\n\n@docs Mark\n@docs MarkProperty\n\n@docs BooleanOp\n@docs Binding\n\n@docs AxisProperty\n@docs AxisConfig\n@docs BinProperty\n@docs ConfigurationProperty\n@docs InputProperty\n@docs HeaderProperty\n@docs LegendConfig\n@docs LegendProperty\n@docs LegendValues\n@docs ProjectionProperty\n@docs ScaleProperty\n@docs ScaleConfig\n@docs StackProperty\n@docs RangeConfig\n@docs SelectionMarkProperty\n@docs TitleConfig\n@docs ViewConfig\n\n@docs DataValue\n@docs DataValues\n@docs ImputeProperty\n@docs DateTime\n@docs Geometry\n\n@docs FacetMapping\n@docs RepeatFields\n@docs Filter\n@docs FilterRange\n\n@docs Resolve\n\n@docs Padding\n@docs ScaleRange\n\n@docs Window\n@docs WindowProperty\n@docs SortField\n\n",
    "aliases": [
      {
        "name": "Data",
        "comment": " Convenience type annotation label for use with data generation functions.\n\n    myRegion : List DataColumn -> Data\n    myRegion =\n        dataFromColumns []\n            << dataColumn \"easting\" (nums [ -3, 4, 4, -3, -3 ])\n            << dataColumn \"northing\" (nums [ 52, 52, 45, 45, 52 ])\n\n",
        "args": [],
        "type": "( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "DataColumn",
        "comment": " A single column of data. Used when generating inline data with [dataColumn](#dataColumn).\n",
        "args": [],
        "type": "List VegaLite.LabelledSpec"
      },
      {
        "name": "DataRow",
        "comment": " A single row of data. Used when generating inline data with [dataRow](#dataRow).\n",
        "args": [],
        "type": "VegaLite.Spec"
      },
      {
        "name": "LabelledSpec",
        "comment": " A named Vega-Lite specification, usually generated by an elm-vega\nfunction. You shouldn't need to create `LabelledSpec` tuples directly, but are\nuseful for type annotations.\n",
        "args": [],
        "type": "( String, VegaLite.Spec )"
      },
      {
        "name": "Spec",
        "comment": " Part or all of Vega-Lite specification. Specs are usually nested\nand can range from a single Boolean value up to the entire Vega-Lite specification.\n",
        "args": [],
        "type": "Json.Encode.Value"
      }
    ],
    "types": [
      {
        "name": "APosition",
        "comment": " Anchor position for some text.\n",
        "args": [],
        "cases": [
          [
            "AStart",
            []
          ],
          [
            "AMiddle",
            []
          ],
          [
            "AEnd",
            []
          ]
        ]
      },
      {
        "name": "Arrangement",
        "comment": " Row or column arrangment in a repeated/faceted view.\n",
        "args": [],
        "cases": [
          [
            "Column",
            []
          ],
          [
            "Row",
            []
          ]
        ]
      },
      {
        "name": "Autosize",
        "comment": " The auto-sizing characteristics of a visualization such as amount of padding,\nwhether it should fill the parent container etc.\n",
        "args": [],
        "cases": [
          [
            "AContent",
            []
          ],
          [
            "AFit",
            []
          ],
          [
            "ANone",
            []
          ],
          [
            "APad",
            []
          ],
          [
            "APadding",
            []
          ],
          [
            "AResize",
            []
          ]
        ]
      },
      {
        "name": "AxisConfig",
        "comment": " Generated by functions prefixed with `axco`.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "AxisProperty",
        "comment": " Generated by functions prefixed with `ax`, for example [axBandPosition](#axBandPosition).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "BinProperty",
        "comment": " Generated by [biBase](#biBase), [biDivide](#biDivide), [biExtent](#biExtent),\n[biMaxBins](#biMaxBins), [biMinStep](#biMinStep), [biNice](#biNice),\n[biStep](#biStep) and [biSteps](#biSteps).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Binding",
        "comment": " Generated by [iRange](#iRange), [iCheckbox](#iCheckbox),\n[iRadio](#iRadio), [iSelect](#iSelect), [iText](#iText), [iNumber](#iNumber),\n[iDate](#iDate), [iTime](#iTime), [iMonth](#iMonth), [iWeek](#iWeek), [iDateTimeLocal](#iDateTimeLocal),\n[iTel](#iTel) and [iColor](#iColor).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "BooleanOp",
        "comment": " Generated by [expr](#expr), [selected](#selected),\n[selectionName](#selectionName), [and](#and), [or](#or) and [not](#not).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Bounds",
        "comment": " The bounds calculation method to use for determining the extent of a sub-plot\nin a composed view.\n",
        "args": [],
        "cases": [
          [
            "Full",
            []
          ],
          [
            "Flush",
            []
          ]
        ]
      },
      {
        "name": "CInterpolate",
        "comment": " Type of color interpolation to apply when mapping a data field onto a color\nscale. Note that color interpolation cannot be applied with the default `sequential`\ncolor scale, so additionally, you should set the `sType` to another continuous scale\nsuch as `linear`, `pow` etc.\n\nOptions that require a `gamma` value (with 1 being a recommended default to provide)\nare generated by [cubeHelix](#cubeHelix), [cubeHelixLong](#cubeHelixLong) and [rgb](#rgb).\n\nSee the\n[Vega-Lite continouus scale documentation](https://vega.github.io/vega-lite/docs/scale.html#continuous).\n\n",
        "args": [],
        "cases": [
          [
            "Hcl",
            []
          ],
          [
            "HclLong",
            []
          ],
          [
            "Hsl",
            []
          ],
          [
            "HslLong",
            []
          ],
          [
            "Lab",
            []
          ]
        ]
      },
      {
        "name": "Channel",
        "comment": " Channel type to be used in a resolution specification.\n",
        "args": [],
        "cases": [
          [
            "ChX",
            []
          ],
          [
            "ChY",
            []
          ],
          [
            "ChX2",
            []
          ],
          [
            "ChY2",
            []
          ],
          [
            "ChColor",
            []
          ],
          [
            "ChOpacity",
            []
          ],
          [
            "ChShape",
            []
          ],
          [
            "ChSize",
            []
          ]
        ]
      },
      {
        "name": "ClipRect",
        "comment": " No clipping to be applied. To specify a clipping rectangle dimenstions, see\n[clipRect](#clipRect).\n",
        "args": [],
        "cases": [
          [
            "NoClip",
            []
          ]
        ]
      },
      {
        "name": "CompositionAlignment",
        "comment": " Alignment to apply to grid rows and columns generated by composition (faceting etc.).\n",
        "args": [],
        "cases": [
          [
            "CANone",
            []
          ],
          [
            "CAEach",
            []
          ],
          [
            "CAAll",
            []
          ]
        ]
      },
      {
        "name": "ConfigurationProperty",
        "comment": " Generated with [coArea](#coArea), [coAutosize](#coAutosize), [coAxis](#coAxis),\n[coAxisX](#coAxisX), [coAxisY](#coAxisY), [coAxisLeft](#coAxisLeft),\n[coAxisRight](#coAxisRight), [coAxisTop](#coAxisTop),\n[coAxisBottom](#coAxisBottom), [coAxisBand](#coAxisBand), [coBackground](#coBackground),\n[coBar](#coBar), [coCircle](#coCircle), [coCountTitle](#coCountTitle), [coFieldTitle](#coFieldTitle),\n[coGeoshape](#coGeoshape), [coHeader](#coHeader), [coLegend](#coLegend), [coLine](#coLine),\n[coMark](#coMark), [coNamedStyle](#coNamedStyle), [coNumberFormat](#coNumberFormat),\n[coPadding](#coPadding), [coPoint](#coPoint), [coProjection](#coProjection),\n[coRange](#coRange), [coRect](#coRect), [coRemoveInvalid](#coRemoveInvalid),\n[coRule](#coRule), [coScale](#coScale), [coSelection](#coSelection),\n[coSquare](#coSquare), [coStack](#coStack), [coText](#coText), [coTick](#coTick),\n[coTitle](#coTitle), [coTimeFormat](#coTimeFormat), [coTrail](#coTrail) and [coView](#coView).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Cursor",
        "comment": " Type of cursor to display. See the\n[CSS cursor documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Keyword%20values)\n",
        "args": [],
        "cases": [
          [
            "CAuto",
            []
          ],
          [
            "CDefault",
            []
          ],
          [
            "CNone",
            []
          ],
          [
            "CContextMenu",
            []
          ],
          [
            "CHelp",
            []
          ],
          [
            "CPointer",
            []
          ],
          [
            "CProgress",
            []
          ],
          [
            "CWait",
            []
          ],
          [
            "CCell",
            []
          ],
          [
            "CCrosshair",
            []
          ],
          [
            "CText",
            []
          ],
          [
            "CVerticalText",
            []
          ],
          [
            "CAlias",
            []
          ],
          [
            "CCopy",
            []
          ],
          [
            "CMove",
            []
          ],
          [
            "CNoDrop",
            []
          ],
          [
            "CNotAllowed",
            []
          ],
          [
            "CAllScroll",
            []
          ],
          [
            "CColResize",
            []
          ],
          [
            "CRowResize",
            []
          ],
          [
            "CNResize",
            []
          ],
          [
            "CEResize",
            []
          ],
          [
            "CSResize",
            []
          ],
          [
            "CWResize",
            []
          ],
          [
            "CNEResize",
            []
          ],
          [
            "CNWResize",
            []
          ],
          [
            "CSEResize",
            []
          ],
          [
            "CSWResize",
            []
          ],
          [
            "CEWResize",
            []
          ],
          [
            "CNSResize",
            []
          ],
          [
            "CNESWResize",
            []
          ],
          [
            "CNWSEResize",
            []
          ],
          [
            "CZoomIn",
            []
          ],
          [
            "CZoomOut",
            []
          ],
          [
            "CGrab",
            []
          ],
          [
            "CGrabbing",
            []
          ]
        ]
      },
      {
        "name": "DataType",
        "comment": " Data type to be parsed when reading input data. To parse dates, see\n[foDate](#FoDate) and [foUtc](#foUtc).\n",
        "args": [],
        "cases": [
          [
            "FoNumber",
            []
          ],
          [
            "FoBoolean",
            []
          ]
        ]
      },
      {
        "name": "DataValue",
        "comment": " Generated by [boo](#boo), [true](#true), [false](#false), [dt](#dt),\n[num](#num) and [str](#str).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "DataValues",
        "comment": " Generated by [boos](#boos), [dts](#dts), [nums](#nums) and [strs](#strs).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "DateTime",
        "comment": " Generated by [dtYear](#dtYear), [dtQuarter](#dtQuarter), [dtMonth](#dtMonth),\n[dtDate](#DTDate), [dtDay](#dtDay), [dtHour](#dtHour), [dtMinute](#dtMinute),\n[dtSecond](#dtSecond) and [dtMillisecond](#dtMillisecond).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "DayName",
        "comment": " Day of the week.\n",
        "args": [],
        "cases": [
          [
            "Mon",
            []
          ],
          [
            "Tue",
            []
          ],
          [
            "Wed",
            []
          ],
          [
            "Thu",
            []
          ],
          [
            "Fri",
            []
          ],
          [
            "Sat",
            []
          ],
          [
            "Sun",
            []
          ]
        ]
      },
      {
        "name": "DetailChannel",
        "comment": " Generated by [dName](#dName), [dMType](#dMType), [dAggregate](#dAggregate),\n[dBin](#dBin), [dImpute](#dImpute) and [dTimeUnit](#dTimeUnit).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "FacetChannel",
        "comment": " Generated by [fName](#fName), [fMType](#fMType), [fAggregate](#fAggregate),\n[fBin](#fBin), [fHeader](#fHeader) and [fTimeUnit](#fTimeUnit).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "FacetMapping",
        "comment": " Generated by [columnBy](#columnBy) and [rowBy](#rowBy).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "FieldTitleProperty",
        "comment": " Style in which field names are displayed. The `Verbal` style is 'Sum of field',\n'Year of date' etc. The `Function` style is 'SUM(field)', 'YEAR(date)' etc. The\n`Plain` style is just the field name without any additional text.\n",
        "args": [],
        "cases": [
          [
            "Verbal",
            []
          ],
          [
            "Function",
            []
          ],
          [
            "Plain",
            []
          ]
        ]
      },
      {
        "name": "Filter",
        "comment": " Generated by [fiEqual](#fiEqual), [fiLessThan](#fiLessThan),\n[fiLessThanEq](#fiLessThanEq), [fiGreaterThan](#fiEqGreaterThan),\n[fiGreaterThanEq](#fiGreaterThanEq), [fiExpr](#fiExpr), [fiCompose](#fiCompose),\n[fiSelection](#fiSelection), [fiOneOf](#fiOneOf), [fiRange](#fiRange) and\n[fiValid](#fiValid).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "FilterRange",
        "comment": " Generated by [numRange](#numRange) and [dtRange](#dtRange).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "FontWeight",
        "comment": " Weight options for a font.\n",
        "args": [],
        "cases": [
          [
            "Bold",
            []
          ],
          [
            "Bolder",
            []
          ],
          [
            "Lighter",
            []
          ],
          [
            "Normal",
            []
          ],
          [
            "W100",
            []
          ],
          [
            "W200",
            []
          ],
          [
            "W300",
            []
          ],
          [
            "W400",
            []
          ],
          [
            "W500",
            []
          ],
          [
            "W600",
            []
          ],
          [
            "W700",
            []
          ],
          [
            "W800",
            []
          ],
          [
            "W900",
            []
          ]
        ]
      },
      {
        "name": "Format",
        "comment": " Data file format (only necessary if the file extension does not indicate the\ntype). To read a file with a delimiter other than comma or tab, use [dsv](#dsv).\nTo customise the parsing of a file use [parse](#parse), [jsonProperty](#jsonProperty),\n[topojsonFeature](#topojsonFeature) or [topojsonMesh](#topojsonMesh).\n",
        "args": [],
        "cases": [
          [
            "CSV",
            []
          ],
          [
            "TSV",
            []
          ]
        ]
      },
      {
        "name": "Geometry",
        "comment": " Generated by [geoPoint](#geoPoint), [geoPoints](#geoPoints),\n[geoLine](#geoLine), [geoLines](#geoLines), [geoPolygon](#geoPolygon) and\n[geoPolygons](#geoPolygons).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "HAlign",
        "comment": " Horizontal alignment of some text such as on an axis or legend.\n",
        "args": [],
        "cases": [
          [
            "AlignCenter",
            []
          ],
          [
            "AlignLeft",
            []
          ],
          [
            "AlignRight",
            []
          ]
        ]
      },
      {
        "name": "HeaderProperty",
        "comment": " Generated by [hdFormat](#hdFormat), [hdLabelAngle](#hdLabelAngle),\n[hdLabelColor](#hdLabelColor), [hdLabelFont](#hdLabelFont), [hdLabelFontSize](#hdLabelFontSize),\n[hdLabelLimit](#hdLabelLimit), [hdLabelPadding](#hdLabelPadding), [hdTitle](#hdTitle),\n[hdTitleAnchor](#hdTitleAnchor), [hdTitleAngle](#hdTitleAngle),\n[hdTitleBaseline](#hdTitleBaseline), [hdTitleColor](#hdTitleColor),\n[hdTitleFont](#hdTitleFont),[hdTitleFontWeight](#hdTitleFontWeight),\n[hdTitleFontSize](#hdTitleFontSize), [hdTitleLimit](#hdTitleLimit) and\n[hdTitlePadding](#hdTitlePadding).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "HyperlinkChannel",
        "comment": " Generated by [hName](#hName), [hRepeat](#hRepeat), [hMType](#hMType), [hBin](#hBin),\n[hBinned](#hBinned), [hAggregate](#hAggregate), [hTimeUnit](#hTimeUnit),\n[hDataCondition](#hDataCondition), [hSelectionCondition](#hSelectionCondition)\nand [hStr](#hStr).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ImMethod",
        "comment": " The imputation method to use when replacing values.\n",
        "args": [],
        "cases": [
          [
            "ImValue",
            []
          ],
          [
            "ImMean",
            []
          ],
          [
            "ImMedian",
            []
          ],
          [
            "ImMax",
            []
          ],
          [
            "ImMin",
            []
          ]
        ]
      },
      {
        "name": "ImputeProperty",
        "comment": " Generated by [imKeyVals](#imKeyVals), [imKeyValSequence](#imKeyValSequence)\n[imFrame](#imFrame), [imGroupBy](#imGroupBy), [imMethod](#imMethod) and [imValue](#imValue).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "InputProperty",
        "comment": " Generated by [inDebounce](#inDebounce), [inElement](#inElement),\n[inOptions](#inOptions), [inMin](#inMin), [inMax](#inMax), [inName](#inName),\n[inStep](#inStep) and [inPlaceholder](#inPlaceholder).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Legend",
        "comment": " Type of legend. Gradient legends are usually used for continuous quantitative\ndata while symbol legends used for categorical data.\n",
        "args": [],
        "cases": [
          [
            "Gradient",
            []
          ],
          [
            "Symbol",
            []
          ]
        ]
      },
      {
        "name": "LegendConfig",
        "comment": " Generated by functions prefixed with `leco`.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "LegendOrientation",
        "comment": " Legend position relative to data rectangle.\n",
        "args": [],
        "cases": [
          [
            "BottomLeft",
            []
          ],
          [
            "BottomRight",
            []
          ],
          [
            "Left",
            []
          ],
          [
            "None",
            []
          ],
          [
            "Right",
            []
          ],
          [
            "TopLeft",
            []
          ],
          [
            "TopRight",
            []
          ]
        ]
      },
      {
        "name": "LegendProperty",
        "comment": " Generated by functions prefied with `le`. For example [leCornerRadius](#leCornerRadius).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "LegendValues",
        "comment": " Generated by [leNums](#leNums), [leStrs](#leStrs) and [leDts](#leDts).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "LineMarker",
        "comment": " Appearance of a line marker that is overlaid on to an area mark.\nAlso generated by [lmLine](#lmLine).\n",
        "args": [],
        "cases": [
          [
            "LMNone",
            []
          ]
        ]
      },
      {
        "name": "Mark",
        "comment": " Generated by\n[area](#area), [bar](#bar), [boxplot](#boxplot), [circle](#circle), [errorband](#errorband),\n[errorbar](#errorbar), [geoshape](#geoshape), [line](#line), [point](#point), [rect](#rect),\n[rule](#rule),[square](#square), [textMark](#textMark), [tick](#tick) and [trail](#trail).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "MarkChannel",
        "comment": " Generated by [mName](#mName), [mRepeat](#mRepeat), [mMType](#mMType), [mScale](#mScale),\n[mBin](#mBin), [mBinned](#mBinned), [mImpute](#mImpute)[mTimeUnit](#mTimeUnit),\n[mTitle](#mTitle), [mAggregate](#mAggregate), [mLegend](#mLegend),\n[mSelectionCondition](#mSelectionCondition), [mDataCondition](#mDataCondition),\n[mPath](#mPath), [mNum](#mNum), [mStr](#mStr) and [mBoo](#mBoo).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "MarkInterpolation",
        "comment": " Mark interpolation style.\n",
        "args": [],
        "cases": [
          [
            "Basis",
            []
          ],
          [
            "BasisClosed",
            []
          ],
          [
            "BasisOpen",
            []
          ],
          [
            "Bundle",
            []
          ],
          [
            "Cardinal",
            []
          ],
          [
            "CardinalClosed",
            []
          ],
          [
            "CardinalOpen",
            []
          ],
          [
            "Linear",
            []
          ],
          [
            "LinearClosed",
            []
          ],
          [
            "Monotone",
            []
          ],
          [
            "StepAfter",
            []
          ],
          [
            "StepBefore",
            []
          ],
          [
            "Stepwise",
            []
          ]
        ]
      },
      {
        "name": "MarkOrientation",
        "comment": " Desired orientation of a mark (e.g. horizontally or vertically oriented bars.)\n",
        "args": [],
        "cases": [
          [
            "Horizontal",
            []
          ],
          [
            "Vertical",
            []
          ]
        ]
      },
      {
        "name": "MarkProperty",
        "comment": " Generated by [maAlign](#maAlign), [maAngle](#maAngle), [maBandSize](#maBandSize),\n[maBaseline](#maBaseline), [maBinSpacing](#maBinSpacing), [maBorders](#maBorders),\n[maClip](#maClip), [maColor](#maColor), [maCursor](#maCursor), [maHRef](#maHRef),\n[maContinuousBandSize](#maContinuousBandSize), [maDiscreteBandSize](#maDiscreteBandSize),\n[maDx](#maDx), [maDy](#maDy), [maExtent](#maExtent), [maFill](#maFill), [maFilled](#maFilled),\n[maFillOpacity](#maFillOpacity), [maFont](#maFont), [maFontSize](#maFontSize),\n[maFontStyle](#maFontStyle), [maFontWeight](#maFontWeight), [maInterpolate](#maInterpolate),\n[maLine](#maLine), [maOpacity](#maOpacity), [maOrient](#maOrient), [maPoint](#maPoint),\n[maRadius](#maRadius), [maRule](#maRule), [maShape](#maShape), [maShortTimeLabels](#maShortTimeLabels),\n[maSize](#maSize), [maStroke](#maStroke), [maStrokeCap](#maStrokeCap), [maStrokeDash](#maStrokeDash),\n[maStrokeDashOffset](#maStrokeDashOffset), [maStrokeJoin](#maStrokeJoin),\n[maStrokeMiterLimit](#maStrokeMiterLimit), [maStrokeOpacity](#maStrokeOpacity),\n[maStrokeWidth](#maStrokeWidth), [maStyle](#maStyle), [maTension](#maTension),\n[maText](#maText), [maTheta](#maTheta), [maThickness](#maThickness), [maTicks](#maTicks),\n[maTooltip](#maTooltip), [maXOffset](#maXOffset), [maYOffset](#maYOffset),\n[maX2Offset](#maX2Offset) and [maY2Offset](#maY2Offset).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Measurement",
        "comment": " Type of measurement to be associated with some channel.\n",
        "args": [],
        "cases": [
          [
            "Nominal",
            []
          ],
          [
            "Ordinal",
            []
          ],
          [
            "Quantitative",
            []
          ],
          [
            "Temporal",
            []
          ],
          [
            "GeoFeature",
            []
          ]
        ]
      },
      {
        "name": "MonthName",
        "comment": " Idntifies a month of the year.\n",
        "args": [],
        "cases": [
          [
            "Jan",
            []
          ],
          [
            "Feb",
            []
          ],
          [
            "Mar",
            []
          ],
          [
            "Apr",
            []
          ],
          [
            "May",
            []
          ],
          [
            "Jun",
            []
          ],
          [
            "Jul",
            []
          ],
          [
            "Aug",
            []
          ],
          [
            "Sep",
            []
          ],
          [
            "Oct",
            []
          ],
          [
            "Nov",
            []
          ],
          [
            "Dec",
            []
          ]
        ]
      },
      {
        "name": "Operation",
        "comment": " Type of aggregation operation.\n",
        "args": [],
        "cases": [
          [
            "ArgMax",
            []
          ],
          [
            "ArgMin",
            []
          ],
          [
            "Average",
            []
          ],
          [
            "CI0",
            []
          ],
          [
            "CI1",
            []
          ],
          [
            "Count",
            []
          ],
          [
            "Distinct",
            []
          ],
          [
            "Max",
            []
          ],
          [
            "Mean",
            []
          ],
          [
            "Median",
            []
          ],
          [
            "Min",
            []
          ],
          [
            "Missing",
            []
          ],
          [
            "Q1",
            []
          ],
          [
            "Q3",
            []
          ],
          [
            "Stderr",
            []
          ],
          [
            "Stdev",
            []
          ],
          [
            "StdevP",
            []
          ],
          [
            "Sum",
            []
          ],
          [
            "Valid",
            []
          ],
          [
            "Variance",
            []
          ],
          [
            "VarianceP",
            []
          ]
        ]
      },
      {
        "name": "OrderChannel",
        "comment": " Generated by [OName](#oName), [oRepeat](#oRepeat), [oMType](#oMType), [oBin](#oBin),\n[oAggregate](#oAggregate), [oTimeUnit](#oTimeUnit) and [oSort](#oSort).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "OverlapStrategy",
        "comment": " Type of overlap strategy to be applied when there is not space to show all items\non an axis or legend. See the\n",
        "args": [],
        "cases": [
          [
            "ONone",
            []
          ],
          [
            "OParity",
            []
          ],
          [
            "OGreedy",
            []
          ]
        ]
      },
      {
        "name": "Padding",
        "comment": " Generated by [paSize](#paSize) and [paEdges](#paEdges).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "PointMarker",
        "comment": " Appearance of a point marker that is overlaid on a line or area mark. Also\ngenerated by [pmMarker](#pmMarker).\n",
        "args": [],
        "cases": [
          [
            "PMTransparent",
            []
          ],
          [
            "PMNone",
            []
          ]
        ]
      },
      {
        "name": "Position",
        "comment": " Type of position channel.\n",
        "args": [],
        "cases": [
          [
            "X",
            []
          ],
          [
            "Y",
            []
          ],
          [
            "X2",
            []
          ],
          [
            "Y2",
            []
          ],
          [
            "Longitude",
            []
          ],
          [
            "Latitude",
            []
          ],
          [
            "Longitude2",
            []
          ],
          [
            "Latitude2",
            []
          ]
        ]
      },
      {
        "name": "PositionChannel",
        "comment": " Generated by [pName](#pName), [pRepeat](#pRepeat), [pMType](#pMType), [pBin](#PBin),\n[pBinned](#pBinned), [pTimeUnit](#pTimeUnit), [pTitle](#pTitle), [pAggregate](#pAggregate),\n[pScale](#pScale), [pAxis](#pAxis), [pSort](#pSort), [pStack](#pStack),\n[pWidth](#pWidth), [pHeight](#pHeight) and [pImpute](#pImpute).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Projection",
        "comment": " Types of geographic map projection. These are based on a subset of those provided\nby the [d3-geo library](https://github.com/d3/d3-geo). To generate a custom projection\nuse [customProjection](#customProjection).\n",
        "args": [],
        "cases": [
          [
            "Albers",
            []
          ],
          [
            "AlbersUsa",
            []
          ],
          [
            "AzimuthalEqualArea",
            []
          ],
          [
            "AzimuthalEquidistant",
            []
          ],
          [
            "ConicConformal",
            []
          ],
          [
            "ConicEqualArea",
            []
          ],
          [
            "ConicEquidistant",
            []
          ],
          [
            "Equirectangular",
            []
          ],
          [
            "Gnomonic",
            []
          ],
          [
            "Mercator",
            []
          ],
          [
            "Orthographic",
            []
          ],
          [
            "Stereographic",
            []
          ],
          [
            "TransverseMercator",
            []
          ]
        ]
      },
      {
        "name": "ProjectionProperty",
        "comment": " Generated by\n[prType](#prType), [prClipAngle](#prClipAngle), [prClipExtent](#prClipExtent),\n[prCenter](#prCenter), [prRotate](#prRotate), [prPrecision](#prPrecision),\n[prCoefficient](#prCoefficient), [prDistance](#prDistance), [prFraction](#prFraction),\n[prLobes](#prLobes), [prParallel](#prParallel), [prRadius](#prRadius), [prRatio](#prRatio),\n[prSpacing](#prSpacing) and [prTilt](#prTilt).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "RangeConfig",
        "comment": " Generated by functions prefixed with `raco`.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "RepeatFields",
        "comment": " Generated by [rowFields](#rowFields) and [columnFields](#columnFields).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Resolution",
        "comment": " Whether or not a scale domain should be independent of others in a\ncomposite visualization. See the\n[Vega-Lite resolve documentation](https://vega.github.io/vega-lite/docs/resolve.html).\n",
        "args": [],
        "cases": [
          [
            "Shared",
            []
          ],
          [
            "Independent",
            []
          ]
        ]
      },
      {
        "name": "Resolve",
        "comment": " Generated by [reAxis](#reAxis), [reLegend](#reLegend) and [reScale](#reScale).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Scale",
        "comment": " Used to indicate the type of scale transformation to apply.\n",
        "args": [],
        "cases": [
          [
            "ScLinear",
            []
          ],
          [
            "ScPow",
            []
          ],
          [
            "ScSqrt",
            []
          ],
          [
            "ScLog",
            []
          ],
          [
            "ScTime",
            []
          ],
          [
            "ScUtc",
            []
          ],
          [
            "ScSequential",
            []
          ],
          [
            "ScOrdinal",
            []
          ],
          [
            "ScBand",
            []
          ],
          [
            "ScPoint",
            []
          ],
          [
            "ScBinLinear",
            []
          ],
          [
            "ScBinOrdinal",
            []
          ],
          [
            "ScQuantile",
            []
          ],
          [
            "ScQuantize",
            []
          ],
          [
            "ScThreshold",
            []
          ]
        ]
      },
      {
        "name": "ScaleConfig",
        "comment": " Generated by functions prefixed by `saco`\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ScaleDomain",
        "comment": " A scale domain (type of data in scale). To specify scale domain values explicitly,\nuse [doNums](#doNums), [doStrs](#doStrs), [doDts](#doDts) or [doSelection](#doSelection).\n",
        "args": [],
        "cases": [
          [
            "Unaggregated",
            []
          ]
        ]
      },
      {
        "name": "ScaleNice",
        "comment": " The style of selecting 'nice' numbers. To specify nice time intervals use\n[scNiceInterval](#scNiceInterval) and to set a nice tick count use\n[scNiceTickCount](#scNiceTickCount).\n",
        "args": [],
        "cases": [
          [
            "NMillisecond",
            []
          ],
          [
            "NSecond",
            []
          ],
          [
            "NMinute",
            []
          ],
          [
            "NHour",
            []
          ],
          [
            "NDay",
            []
          ],
          [
            "NWeek",
            []
          ],
          [
            "NMonth",
            []
          ],
          [
            "NYear",
            []
          ],
          [
            "NTrue",
            []
          ],
          [
            "NFalse",
            []
          ]
        ]
      },
      {
        "name": "ScaleProperty",
        "comment": " Generated by [scType](#scType), [scDomain](#scDomain), [scRange](#scRange),\n[scScheme](#scScheme), [scPadding](#scPadding), [scPaddingInner](#scPaddingInner),\n[scPaddingOuter](#scPaddingOuter), [scRangeStep](#scRangeStep), [scRound](#scRound),\n[scClamp](#scClamp), [scInterpolate](#scInterpolate), [scNice](#scNice), [scZero](#scZero)\nand [scReverse](#scReverse).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ScaleRange",
        "comment": " Generated by [raNums](#raNums), [raStrs](#raStrs) and [raName](#raName).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Selection",
        "comment": " Type of selection to be generated by the user. `Single` allows\none mark at a time to be selected. 'Multi' allows multiple items to be selected\n(e.g. with shift-click). 'Interval' allows a bounding rectangle to be dragged by\nuser to select all items intersecting with it.\n",
        "args": [],
        "cases": [
          [
            "Single",
            []
          ],
          [
            "Multi",
            []
          ],
          [
            "Interval",
            []
          ]
        ]
      },
      {
        "name": "SelectionMarkProperty",
        "comment": " Generated by [smFill](#smFill), [smFillOpacity](#smFillOpacity), [smStroke](#smStroke),\n[smStrokeDash](#smStrokeDash), [smStrokeDashOffset](#smStrokeDashOffset),\n[smStrokeOpacity](#smStrokeOpacity) and [smStrokeWidth](#smStrokeWidth).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "SelectionProperty",
        "comment": " Properties for customising the nature of an interactive selection. Parameterised\nproperties generated by [seBind](#seBind), [seEncodings](#seEncodings), [seFields](#seFields),\n[seNearest](#seNearest), [seOn](#seOn), [seResolve](#seResolve), [seSelectionMark](#seSelectionMark),\n[seToggle](#seToggle), [seTranslate](#seTranslate) and [seZoom](#seZoom).\n",
        "args": [],
        "cases": [
          [
            "Empty",
            []
          ],
          [
            "BindScales",
            []
          ]
        ]
      },
      {
        "name": "SelectionResolution",
        "comment": " How selections in faceted or repeated views are resolved. See the\n[Vege-Lite resolve documentation](https://vega.github.io/vega-lite/docs/selection.html#resolve).\n",
        "args": [],
        "cases": [
          [
            "Global",
            []
          ],
          [
            "Union",
            []
          ],
          [
            "Intersection",
            []
          ]
        ]
      },
      {
        "name": "Side",
        "comment": " One side of a rectangular space.\n",
        "args": [],
        "cases": [
          [
            "STop",
            []
          ],
          [
            "SBottom",
            []
          ],
          [
            "SLeft",
            []
          ],
          [
            "SRight",
            []
          ]
        ]
      },
      {
        "name": "SortField",
        "comment": " Generated by [stAscending](#stAscending), [wiAscending](#wiAscending),\n[stDescending](#stDescending) and [wiDescending](#wiDescending).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "SortProperty",
        "comment": " Allow type of sorting to be customised. To sort a field by the aggregated\nvalues of another use [soByField](#soByField) or [soByRepeat](#soByRepeat). Custom\nsorting by explicit values can be provided by [soCustom](#soCustom).\n",
        "args": [],
        "cases": [
          [
            "Ascending",
            []
          ],
          [
            "Descending",
            []
          ]
        ]
      },
      {
        "name": "StackOffset",
        "comment": " Type of stacking to apply when showing multiple quantities.\n",
        "args": [],
        "cases": [
          [
            "StZero",
            []
          ],
          [
            "StNormalize",
            []
          ],
          [
            "StCenter",
            []
          ],
          [
            "NoStack",
            []
          ]
        ]
      },
      {
        "name": "StackProperty",
        "comment": " Generated by [stOffset](#stOffset) and [stSort](#stSort).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "StrokeCap",
        "comment": " Type of stroke cap.\n",
        "args": [],
        "cases": [
          [
            "CButt",
            []
          ],
          [
            "CRound",
            []
          ],
          [
            "CSquare",
            []
          ]
        ]
      },
      {
        "name": "StrokeJoin",
        "comment": " Type of stroke join.\n",
        "args": [],
        "cases": [
          [
            "JMiter",
            []
          ],
          [
            "JRound",
            []
          ],
          [
            "JBevel",
            []
          ]
        ]
      },
      {
        "name": "SummaryExtent",
        "comment": " Type of extent summary of a statistical distribution. Additionally generated\nby [iqrScale](#iqrScale).\n",
        "args": [],
        "cases": [
          [
            "ExCI",
            []
          ],
          [
            "ExStderr",
            []
          ],
          [
            "ExStdev",
            []
          ],
          [
            "ExIqr",
            []
          ],
          [
            "ExRange",
            []
          ]
        ]
      },
      {
        "name": "Symbol",
        "comment": " Type of symbol. To create a user defined path for a symbol use\n[symPath](#symPath).\n",
        "args": [],
        "cases": [
          [
            "SymCircle",
            []
          ],
          [
            "SymSquare",
            []
          ],
          [
            "Cross",
            []
          ],
          [
            "Diamond",
            []
          ],
          [
            "TriangleUp",
            []
          ],
          [
            "TriangleDown",
            []
          ]
        ]
      },
      {
        "name": "TextChannel",
        "comment": " Generated by [tName](#tName), [tRepeat](#tRepeat), [tMType](#tMType),\n[tBin](#tBin), [tBinned](#tBinned), [tAggregate](#tAggregate), [tTimeUnit](#tTimeUnit),\n[tTitle](#tTitle), [tSelectionCondition](#tSelectionCondition),\n[tDataCondition](#tDataCondition) and [tFormat](#tFormat).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "TimeUnit",
        "comment": " A unit of time. See the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/timeunit.html).\n\nTo encode a time as UTC (coordinated universal time, independent of local time\nzones or daylight saving), provide a time unit to the `utc` function.\nFor example,\n\n    encoding\n        << position X [ pName \"date\", pMType Temporal, pTimeUnit (utc YearMonthDateHours) ]\n\n",
        "args": [],
        "cases": [
          [
            "Year",
            []
          ],
          [
            "YearQuarter",
            []
          ],
          [
            "YearQuarterMonth",
            []
          ],
          [
            "YearMonth",
            []
          ],
          [
            "YearMonthDate",
            []
          ],
          [
            "YearMonthDateHours",
            []
          ],
          [
            "YearMonthDateHoursMinutes",
            []
          ],
          [
            "YearMonthDateHoursMinutesSeconds",
            []
          ],
          [
            "Quarter",
            []
          ],
          [
            "QuarterMonth",
            []
          ],
          [
            "Month",
            []
          ],
          [
            "MonthDate",
            []
          ],
          [
            "Date",
            []
          ],
          [
            "Day",
            []
          ],
          [
            "Hours",
            []
          ],
          [
            "HoursMinutes",
            []
          ],
          [
            "HoursMinutesSeconds",
            []
          ],
          [
            "Minutes",
            []
          ],
          [
            "MinutesSeconds",
            []
          ],
          [
            "Seconds",
            []
          ],
          [
            "SecondsMilliseconds",
            []
          ],
          [
            "Milliseconds",
            []
          ]
        ]
      },
      {
        "name": "TitleConfig",
        "comment": " Generated by functions prefixed by `tico`.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "TooltipContent",
        "comment": " Indicate whether tooltips are generated by encoding (default) or data.\n",
        "args": [],
        "cases": [
          [
            "TTEncoding",
            []
          ],
          [
            "TTData",
            []
          ]
        ]
      },
      {
        "name": "VAlign",
        "comment": " Vertical alignment of some text that may be attached to a mark.\n",
        "args": [],
        "cases": [
          [
            "AlignTop",
            []
          ],
          [
            "AlignMiddle",
            []
          ],
          [
            "AlignBottom",
            []
          ]
        ]
      },
      {
        "name": "VLProperty",
        "comment": " Top-level Vega-Lite properties. These are the ones that define the core of the\nvisualization grammar. All `VLProperties` are created by functions in seven broad groups.\n\n**Data properties** relate to the input data to be visualized. Generated by\n[`dataFromColumns`](#dataFromColumns), [`dataFromRows`](#dataFromRows),\n[`dataFromUrl`](#dataFromUrl), [`dataFromSource`](#dataFromSource) and\n[`dataFromJson`](#dataFromJson).\n\n**Transform properties** indicate that some transformation of input data should\nbe applied before encoding them visually. Generated by [`transform`](#transform)\nand [`projection`](#projection) they can include data transformations such as\n[`filter`](#filter), [`binAs`](#binAs) and [`calculateAs`](#calculateAs) and geo\ntransformations of longitude, latitude coordinates used by marks such as those\ngenerated by [`geoshape`](#geoshape), [`point`](#point) and [`line`](#line).\n\n**Mark functions** specify the symbols used to visualize data items. Generated\nby functions such as [`circle`](#circle), [`bar`](#bar) and [`line`](#line).\n\n**Encoding properties** specify which data elements are mapped to which mark\ncharacteristics (known as _channels_). Generated by [`encoding`](#encoding) they\ninclude encodings such as [`position`](#position), [`color`](#color), [`size`](#size),\n[`shape`](#shape), [`text`](#text) and [`hyperlink`](#hyperlink).\n\n**Composition properties** allow visualization views to be combined to form more\ncomplex visualizations. Generated by [`layer`](#layer), [`repeat`](#repeat),\n[`facet`](#facet), [`hConcat`](#hConcat), [`vConcat`](#vConcat), [`spec`](#spec)\nand [`resolve`](#resolve).\n\n**Interaction properties** allow clicking, dragging and other interactions generated\nvia a GUI or data stream to influence the visualization. Generated by\n[`selection`](#selection).\n\n**Supplementary and configuration properties** provide a means to add metadata and\nstyling to one or more visualizations. Generated by [`name`](#name), [`title`](#title),\n[`description`](#description), [`background`](#background), [`width`](#width),\n[`height`](#height), [`padding`](#padding), [`autosize`](#autosize) and\n[`configure`](#configure).\n\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ViewConfig",
        "comment": " Generated by functions prefixed with `vico`.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Window",
        "comment": " Generated by [wiAggregateOp](#wiAggregateOp), [wiOp](#wiOp), [wiParam](#wiParam)\nand [wiField](#wiField).\n",
        "args": [],
        "cases": []
      },
      {
        "name": "WindowOperation",
        "comment": " Operations that may be applied during a window transformation.\n",
        "args": [],
        "cases": [
          [
            "RowNumber",
            []
          ],
          [
            "Rank",
            []
          ],
          [
            "DenseRank",
            []
          ],
          [
            "PercentRank",
            []
          ],
          [
            "CumeDist",
            []
          ],
          [
            "Ntile",
            []
          ],
          [
            "Lag",
            []
          ],
          [
            "Lead",
            []
          ],
          [
            "FirstValue",
            []
          ],
          [
            "LastValue",
            []
          ],
          [
            "NthValue",
            []
          ]
        ]
      },
      {
        "name": "WindowProperty",
        "comment": " Generated by [wiFrame](#wiFrame), [wiIgnorePeers](#wiIgnorePeers), [wiGroupBy](#wiGroupBy)\nand [wiSort](#wiSort).\n",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "aggregate",
        "comment": " Aggregation transformations to be used when encoding channels. Useful when for\napplying the same transformation to a number of channels without defining it each\ntime. The first parameter is a list of the named aggregation operations to apply.\nThe second is a list of 'group by' fields.\n\n    trans =\n        transform\n            << aggregate\n                [ opAs Min \"people\" \"lowerBound\", opAs Max \"people\" \"upperBound\" ]\n                [ \"age\" ]\n\n",
        "type": "List VegaLite.Spec -> List String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "align",
        "comment": " Alignment to apply to grid rows and columns generated by a composition\noperator. This version sets the same alignment for rows and columns.\n",
        "type": "VegaLite.CompositionAlignment -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "alignRC",
        "comment": " Similar to [align](#align) but with independent alignments for rows (first\nparameter) and columns (second parameter).\n",
        "type": "VegaLite.CompositionAlignment -> VegaLite.CompositionAlignment -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "and",
        "comment": " Apply an 'and' Boolean operation as part of a logical composition.\n\n    and (expr \"datum.IMDB_Rating === null\") (expr \"datum.Rotten_Tomatoes_Rating === null\")\n\n",
        "type": "VegaLite.BooleanOp -> VegaLite.BooleanOp -> VegaLite.BooleanOp"
      },
      {
        "name": "area",
        "comment": " An [area mark](https://vega.github.io/vega-lite/docs/area.html) for representing\na series of data elements, such as in a stacked area chart or streamgraph.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "asSpec",
        "comment": " Create a specification sufficient to define an element in a composed visualization\nsuch as a superposed layer or juxtaposed facet. Typically a layer will contain a\nfull set of specifications that define a visualization with the exception of the\ndata specification which is usually defined outside of any one\nlayer. For repeated and faceted specs, the entire specification is provided.\n",
        "type": "List ( VegaLite.VLProperty, VegaLite.Spec ) -> VegaLite.Spec"
      },
      {
        "name": "autosize",
        "comment": " Declare the way the view is sized. See the\n[Vega-Lite autosize documentation](https://vega.github.io/vega-lite/docs/size.html#autosize).\n\n    enc = ...\n    toVegaLite\n        [ width 250\n        , height 300\n        , autosize [ AFit, APadding, AResize ]\n        , dataFromUrl \"data/population.json\" []\n        , bar []\n        , enc []\n        ]\n\n",
        "type": "List VegaLite.Autosize -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "axBandPosition",
        "comment": " Position of axis tick relative to a band (0 to 1).\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axDates",
        "comment": " Dates/times to appear along an axis.\n",
        "type": "List (List VegaLite.DateTime) -> VegaLite.AxisProperty"
      },
      {
        "name": "axDomain",
        "comment": " Whether or not an axis baseline (domain) should be included as part of an axis.\n",
        "type": "Bool -> VegaLite.AxisProperty"
      },
      {
        "name": "axDomainColor",
        "comment": " Color of axis domain line.\n",
        "type": "String -> VegaLite.AxisProperty"
      },
      {
        "name": "axDomainOpacity",
        "comment": " Opacity of axis domain line.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axDomainWidth",
        "comment": " Width of axis domain line.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axFormat",
        "comment": " [Format](https://vega.github.io/vega-lite/docs/format.html) to apply to\nlabels on an axis.\n",
        "type": "String -> VegaLite.AxisProperty"
      },
      {
        "name": "axGrid",
        "comment": " Whether or not grid lines should be included as part of an axis.\n",
        "type": "Bool -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabelAlign",
        "comment": " Horizontal alignment of axis tick labels.\n",
        "type": "VegaLite.HAlign -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabelAngle",
        "comment": " Rotation angle in degrees of axis labels.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabelBaseline",
        "comment": " Vertical alignment of axis tick labels.\n",
        "type": "VegaLite.VAlign -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabelBound",
        "comment": " How or if labels should be hidden if they exceed the axis range. If\n`Nothing`, no check for label size is made. A number specifies the permitted\noverflow in pixels.\n",
        "type": "Maybe.Maybe Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabelColor",
        "comment": " Color of axis tick label.\n",
        "type": "String -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabelFlush",
        "comment": " How or if labels at beginning or end of the axis should be aligned. Specifies\nthe distance threshold from an end-point within which labels are flush-adjusted\nor if `Nothing`, no flush-adjustment made.\n",
        "type": "Maybe.Maybe Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabelFlushOffset",
        "comment": " Number of pixels by which to offset flush-adjusted labels.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabelFont",
        "comment": " Font name of an axis label.\n",
        "type": "String -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabelFontSize",
        "comment": " Font size of an axis label.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabelFontWeight",
        "comment": " Font weight of an axis label.\n",
        "type": "VegaLite.FontWeight -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabelLimit",
        "comment": " Maximum length in pixels of axis tick labels.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabelOpacity",
        "comment": " Opacity of an axis label.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabelOverlap",
        "comment": " Overlap strategy for labels when they are too large to fit within the space\ndevoted to an axis.\n",
        "type": "VegaLite.OverlapStrategy -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabelPadding",
        "comment": " Padding in pixels between an axis and its text labels.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axLabels",
        "comment": " Whether or not axis labels should be displayed.\n",
        "type": "Bool -> VegaLite.AxisProperty"
      },
      {
        "name": "axMaxExtent",
        "comment": " Maximum extent in pixels that axis ticks and labels should use.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axMinExtent",
        "comment": " Minimum extent in pixels that axis ticks and labels should use.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axOffset",
        "comment": " Offset to displace the axis from the edge of the enclosing group or data rectangle.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axOrient",
        "comment": " Orientation of an axis relative to the plot it is describing.\n",
        "type": "VegaLite.Side -> VegaLite.AxisProperty"
      },
      {
        "name": "axPosition",
        "comment": " Anchor position of the axis in pixels. For x-axis with top or\nbottom orientation, this sets the axis group x coordinate. For y-axis with left\nor right orientation, this sets the axis group y coordinate.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axTickColor",
        "comment": " Color of axis ticks.\n",
        "type": "String -> VegaLite.AxisProperty"
      },
      {
        "name": "axTickCount",
        "comment": " Desired number of ticks for axes visualizing quantitative scales.\nThe resulting number may be different so that values are “nice” (multiples of 2, 5, 10).\n",
        "type": "Int -> VegaLite.AxisProperty"
      },
      {
        "name": "axTickExtra",
        "comment": " Whether or not an extra axis tick should be added for the initial position\nof an axis.\n",
        "type": "Bool -> VegaLite.AxisProperty"
      },
      {
        "name": "axTickOffset",
        "comment": " Offset in pixels of an axis's ticks, labels and gridlines.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axTickOpacity",
        "comment": " Opacity of axis ticks.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axTickRound",
        "comment": " Whether or not axis tick positions should be rounded to nearest integer.\n",
        "type": "Bool -> VegaLite.AxisProperty"
      },
      {
        "name": "axTickSize",
        "comment": " Tick mark size in pixels.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axTickStep",
        "comment": " Desired step size for ticks. Will generate corresponding tick count and values.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axTickWidth",
        "comment": " Width of axis ticks.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axTicks",
        "comment": " Whether or not an axis should include tick marks.\n",
        "type": "Bool -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitle",
        "comment": " Title to display as part of an axis. An empty string can be used\nto prevent a title being displayed.\n",
        "type": "String -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitleAlign",
        "comment": " Horizontal alignment of an axis title.\n",
        "type": "VegaLite.HAlign -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitleAngle",
        "comment": " Angle in degrees of an axis title.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitleBaseline",
        "comment": " Vertical alignment of axis title.\n",
        "type": "VegaLite.VAlign -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitleColor",
        "comment": " Color of axis title.\n",
        "type": "String -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitleFont",
        "comment": " Font name for an axis title.\n",
        "type": "String -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitleFontSize",
        "comment": " Font size for an axis title.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitleFontWeight",
        "comment": " Font weight of an axis title.\n",
        "type": "VegaLite.FontWeight -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitleLimit",
        "comment": " Maximum length in pixels of axis title.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitleOpacity",
        "comment": " Opacity of an axis title.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitlePadding",
        "comment": " Padding in pixels between a title and axis.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitleX",
        "comment": " X position of an axis title relative to the axis group.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axTitleY",
        "comment": " Y position of an axis title relative to the axis group.\n",
        "type": "Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axValues",
        "comment": " Numeric values to appear along an axis.\n",
        "type": "List Float -> VegaLite.AxisProperty"
      },
      {
        "name": "axZIndex",
        "comment": " Drawing order of the axis relative to the other chart elements. 1 indicates\naxis is drawn in front of chart marks, 0 indicates it is drawn behind them.\n",
        "type": "Int -> VegaLite.AxisProperty"
      },
      {
        "name": "axcoBandPosition",
        "comment": " Default axis band position.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoDomain",
        "comment": " Whether or not an axis domain should be displayed by default.\n",
        "type": "Bool -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoDomainColor",
        "comment": " Default axis domain color.\n",
        "type": "String -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoDomainOpacity",
        "comment": " Default axis domain opacity.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoDomainWidth",
        "comment": " Default axis domain width style.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoGrid",
        "comment": " Whether or not an axis grid is displayed by default.\n",
        "type": "Bool -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoGridColor",
        "comment": " Default axis grid color style.\n",
        "type": "String -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoGridDash",
        "comment": " Default axis line dash style.\n",
        "type": "List Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoGridOpacity",
        "comment": " Default axis grid line opacity.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoGridWidth",
        "comment": " Default axis grid line width.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelAlign",
        "comment": " Default axis label horizontal alignment.\n",
        "type": "VegaLite.HAlign -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelAngle",
        "comment": " Default axis label angle.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelBaseline",
        "comment": " Default axis label vertical alignment.\n",
        "type": "VegaLite.VAlign -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelBound",
        "comment": " Default axis label bounding when label exceeds available space. If `Nothing`,\nno check for label size is made. A number specifies the permitted overflow in pixels.\n",
        "type": "Maybe.Maybe Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelColor",
        "comment": " Default axis label color.\n",
        "type": "String -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelFlush",
        "comment": " Default label alignment at beginning or end of the axis. Specifies the distance\nthreshold from an end-point within which labels are flush-adjusted or if `Nothing`,\nno flush-adjustment made.\n",
        "type": "Maybe.Maybe Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelFlushOffset",
        "comment": " Defailt number of pixels by which to offset flush-adjusted labels.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelFont",
        "comment": " Default axis label font.\n",
        "type": "String -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelFontSize",
        "comment": " Default axis label font size.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelFontWeight",
        "comment": " Default axis label font weight.\n",
        "type": "VegaLite.FontWeight -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelLimit",
        "comment": " Default axis label limit (how much a label can extend beyond the\nleft/bottom or right/top of the axis line).\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelOpacity",
        "comment": " Default axis label opacity.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelOverlap",
        "comment": " Default axis label overlap strategy for cases where labels cannot\nfit within the allotted space.\n",
        "type": "VegaLite.OverlapStrategy -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabelPadding",
        "comment": " Default axis label padding (space between labels in pixels).\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoLabels",
        "comment": " Whether or not an axis has labels by default.\n",
        "type": "Bool -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoMaxExtent",
        "comment": " Default maximum extent style.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoMinExtent",
        "comment": " Default minimum extent style.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoShortTimeLabels",
        "comment": " Whether or not an axis should use short time labels by default.\n",
        "type": "Bool -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTickColor",
        "comment": " Default axis tick mark color.\n",
        "type": "String -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTickExtra",
        "comment": " Whether or not by default an extra axis tick should be added for the initial\nposition of axes.\n",
        "type": "Bool -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTickOffset",
        "comment": " Default offset in pixels of axis ticks, labels and gridlines.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTickOpacity",
        "comment": " Default opacity of axis ticks.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTickRound",
        "comment": " Whether or not axis tick labels use rounded values by default.\n",
        "type": "Bool -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTickSize",
        "comment": " Default axis tick mark size.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTickStep",
        "comment": " Default step size for axis ticks.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTickWidth",
        "comment": " Default axis tick mark width.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTicks",
        "comment": " Whether or not an axis should show ticks by default.\n",
        "type": "Bool -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleAlign",
        "comment": " Default axis tick label horizontal alignment.\n",
        "type": "VegaLite.HAlign -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleAngle",
        "comment": " Default axis title angle.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleBaseline",
        "comment": " Default axis title vertical alignment.\n",
        "type": "VegaLite.VAlign -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleColor",
        "comment": " Default axis title color.\n",
        "type": "String -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleFont",
        "comment": " Default axis title font.\n",
        "type": "String -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleFontSize",
        "comment": " Default axis title font size.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleFontWeight",
        "comment": " Default axis title font weight.\n",
        "type": "VegaLite.FontWeight -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleLimit",
        "comment": " Default axis title maximum size.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleOpacity",
        "comment": " Default opacity of axis titles.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitlePadding",
        "comment": " Default axis title padding between axis line and text.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleX",
        "comment": " Default axis x-position relative to the axis group.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "axcoTitleY",
        "comment": " Default axis y-position relative to the axis group.\n",
        "type": "Float -> VegaLite.AxisConfig"
      },
      {
        "name": "background",
        "comment": " Background color of the visualization. Should be specified with a CSS\nstring such as `#ffe` or `rgb(200,20,150)`. If not specified the background will\nbe transparent.\n",
        "type": "String -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "bar",
        "comment": " [Bar mark](https://vega.github.io/vega-lite/docs/bar.html) for histograms,\nbar charts etc.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "biBase",
        "comment": " Number base to use for automatic bin determination (default is base 10).\n",
        "type": "Float -> VegaLite.BinProperty"
      },
      {
        "name": "biDivide",
        "comment": " Scale factors indicating allowable subdivisions for binning. The default value\nis [5, 2], which indicates that for base 10 numbers (the default base), binning\nwill consider dividing bin sizes by 5 and/or 2.\n",
        "type": "List Float -> VegaLite.BinProperty"
      },
      {
        "name": "biExtent",
        "comment": " Desired range of bin values when binning a collection of values.\nThe first and second parameters indicate the minimum and maximum range values.\n",
        "type": "Float -> Float -> VegaLite.BinProperty"
      },
      {
        "name": "biMaxBins",
        "comment": " Maximum number of bins when binning a collection of values.\n",
        "type": "Int -> VegaLite.BinProperty"
      },
      {
        "name": "biMinStep",
        "comment": " Step size between bins when binning a collection of values.\n",
        "type": "Float -> VegaLite.BinProperty"
      },
      {
        "name": "biNice",
        "comment": " Whether or not binning boundaries use human-friendly values such as multiples\nof ten.\n",
        "type": "Bool -> VegaLite.BinProperty"
      },
      {
        "name": "biStep",
        "comment": " Step size between bins when binning a collection of values.\n",
        "type": "Float -> VegaLite.BinProperty"
      },
      {
        "name": "biSteps",
        "comment": " Allowable step sizes between bins when binning a collection of values.\n",
        "type": "List Float -> VegaLite.BinProperty"
      },
      {
        "name": "binAs",
        "comment": " Binning transformation that may be referenced in other transformations or\nencodings. The type of binning can be customised with a list of `BinProperty`\ngenerating functions ([biBase](#biBase), [biDivide](#biDivide) etc.) or an empty\nlist to use the default binning.\n\n    trans =\n        transform\n            << binAs [ MaxBins 3 ] \"IMDB_Rating\" \"ratingGroup\"\n\nNote that usually, direct binning within an encoding is preferred over this form\nof bin transformation.\n\n",
        "type": "List VegaLite.BinProperty -> String -> String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "boo",
        "comment": " A boolean data value.\n",
        "type": "Bool -> VegaLite.DataValue"
      },
      {
        "name": "boos",
        "comment": " A list of boolean data values.\n",
        "type": "List Bool -> VegaLite.DataValues"
      },
      {
        "name": "bounds",
        "comment": " Bounds calculation method to use for determining the extent of a sub-plot in\na composed view. If set to `Full` the entire calculated bounds including axes,\ntitle and legend are used; if `Flush` only the width and height values for the\nsub-view will be used.\n",
        "type": "VegaLite.Bounds -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "boxplot",
        "comment": " [Boxplot composite mark](https://vega.github.io/vega-lite/docs/boxplot.html)\nfor showing summaries of statistical distibutions.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "calculateAs",
        "comment": " Generate a new data field based on calculations from existing fields.\nThe first parameter is an expression representing the calculation and the second\nis the name to give the newly calculated field.\n\n    trans =\n        transform << calculateAs \"datum.sex == 2 ? 'F' : 'M'\" \"gender\"\n\n",
        "type": "String -> String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "categoricalDomainMap",
        "comment": " Create a set of discrete domain to color mappings suitable for customising categorical\nscales. The first item in each tuple should be a domain value and the second the\ncolor value with which it should be associated. It is a convenience function equivalent\nto specifying separate `SDomain` and `SRange` lists and is safer as it guarantees\na one-to-one correspondence between domain and range values.\n\n    color\n        [ mName \"weather\"\n        , mMType Nominal\n        , mScale <|\n            categoricalDomainMap\n                [ ( \"sun\", \"yellow\" )\n                , ( \"rain\", \"blue\" )\n                , ( \"fog\", \"grey\" )\n                ]\n        ]\n\n",
        "type": "List ( String, String ) -> List VegaLite.ScaleProperty"
      },
      {
        "name": "center",
        "comment": " Whether or not sub-views specified in a composition operator should be centred\nrelative to their respective rows and columns.\n",
        "type": "Bool -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "centerRC",
        "comment": " Similar to [center](#center) but with independent centring for rows and columns.\n",
        "type": "Bool -> Bool -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "circle",
        "comment": " [Circle mark](https://vega.github.io/vega-lite/docs/circle.html) for\nsymbolising points.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "clipRect",
        "comment": " Clipping rectangle in pixel units. The four parameters are respectively\n'left', 'top', 'right' and 'bottom' of the rectangular clipping bounds.\n",
        "type": "Float -> Float -> Float -> Float -> VegaLite.ClipRect"
      },
      {
        "name": "coArea",
        "comment": " Configure the default appearance of area marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAutosize",
        "comment": " Configure the default sizing of visualizations.\n",
        "type": "List VegaLite.Autosize -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAxis",
        "comment": " Configure the default appearance of axes.\n",
        "type": "List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAxisBand",
        "comment": " Configure the default appearance of axes with band scaling.\n",
        "type": "List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAxisBottom",
        "comment": " Configure the default appearance of bottom-side axes.\n",
        "type": "List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAxisLeft",
        "comment": " Configure the default appearance of left-side axes.\n",
        "type": "List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAxisRight",
        "comment": " Configure the default appearance of right-side axes.\n",
        "type": "List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAxisTop",
        "comment": " Configure the default appearance of top-side axes.\n",
        "type": "List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAxisX",
        "comment": " Configure the default appearance of x-axes.\n",
        "type": "List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coAxisY",
        "comment": " Configure the default appearance of y-axes.\n",
        "type": "List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coBackground",
        "comment": " Configure the default background color of visualizations.\n",
        "type": "String -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coBar",
        "comment": " Configure the default appearance of bar marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coCircle",
        "comment": " Configure the default appearance of circle marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coCountTitle",
        "comment": " Configure the default title style for count fields.\n",
        "type": "String -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coFieldTitle",
        "comment": " Configure the default title generation style for fields.\n",
        "type": "VegaLite.FieldTitleProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coGeoshape",
        "comment": " Configure the default appearance of geoshape marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coHeader",
        "comment": " Configure the default appearance of facet headers.\n",
        "type": "List VegaLite.HeaderProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coLegend",
        "comment": " Configure the default appearance of legends.\n",
        "type": "List VegaLite.LegendConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coLine",
        "comment": " Configure the default appearance of line marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coMark",
        "comment": " Configure the default mark appearance.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coNamedStyle",
        "comment": " Configure the default appearance of a named style.\n",
        "type": "String -> List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coNumberFormat",
        "comment": " Configure the default number formatting for axis and text labels.\n",
        "type": "String -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coPadding",
        "comment": " Configure the default padding in pixels from the edge of the of visualization\nto the data rectangle.\n",
        "type": "VegaLite.Padding -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coPoint",
        "comment": " Configure the default appearance of point marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coProjection",
        "comment": " Configure the default style of map projections.\n",
        "type": "List VegaLite.ProjectionProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coRange",
        "comment": " Configure the default range properties used when scaling.\n",
        "type": "List VegaLite.RangeConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coRect",
        "comment": " Configure the default appearance of rectangle marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coRemoveInvalid",
        "comment": " Configure the default handling of invalid (`null` and `NaN`) values. If `true`,\ninvalid values are skipped or filtered out when represented as marks.\n",
        "type": "Bool -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coRule",
        "comment": " Configure the default appearance of rule marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coScale",
        "comment": " Configure the default scale properties used when scaling.\n",
        "type": "List VegaLite.ScaleConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coSelection",
        "comment": " Configure the default appearance of selection marks.\n",
        "type": "List ( VegaLite.Selection, List VegaLite.SelectionProperty ) -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coSquare",
        "comment": " Configure the default appearance of square marks.)\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coStack",
        "comment": " Configure the default stack offset style for stackable marks.\n",
        "type": "VegaLite.StackOffset -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coText",
        "comment": " Configure the default appearance of text marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coTick",
        "comment": " Configure the default appearance of tick marks.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coTimeFormat",
        "comment": " Configure the default time format for axis and legend labels.\n",
        "type": "String -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coTitle",
        "comment": " Configure the default style of visualization titles.\n",
        "type": "List VegaLite.TitleConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "coTrail",
        "comment": " Configure the default style of trail marks.\n",
        "type": "List VegaLite.MarkProperty -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "coView",
        "comment": " Configure the default single view style.\n",
        "type": "List VegaLite.ViewConfig -> VegaLite.ConfigurationProperty"
      },
      {
        "name": "color",
        "comment": " Encode a color channel. The first parameter is a list of mark channel properties\nthat characterise the way a data field is encoded by color.\n",
        "type": "List VegaLite.MarkChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "column",
        "comment": " Encodes a new facet to be arranged in columns. The first parameter is a list\nof properties that define the faceting channel. This should include at least the\nname of the data field and its measurement type.\n",
        "type": "List VegaLite.FacetChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "columnBy",
        "comment": " The mapping between a column and its field definitions in a set of\nfaceted small multiples.\n",
        "type": "List VegaLite.FacetChannel -> VegaLite.FacetMapping"
      },
      {
        "name": "columnFields",
        "comment": " Create a list of fields to use in set of repeated small multiples arranged in\ncolumns. The list of fields named here can be referenced in an encoding with\n`pRepeat Column`, `mRepeat Column` etc.\n",
        "type": "List String -> VegaLite.RepeatFields"
      },
      {
        "name": "combineSpecs",
        "comment": " Combines a list of labelled specifications that may be passed to JavaScript\nfor rendering. Useful when you wish to create a single page with multiple\nvisulizualizations.\n\n    combineSpecs\n        [ ( \"vis1\", myFirstVis )\n        , ( \"vis2\", mySecondVis )\n        , ( \"vis3\", myOtherVis )\n        ]\n\n",
        "type": "List VegaLite.LabelledSpec -> VegaLite.Spec"
      },
      {
        "name": "configuration",
        "comment": " A configuration option to be applied globally across the visualization.\n",
        "type": "VegaLite.ConfigurationProperty -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "configure",
        "comment": " Create a single global configuration from a list of configuration specifications.\nSee the [Vega-Lite documentation](https://vega.github.io/vega-lite/docs/config.html).\n\n    config =\n        configure\n            << configuration (coAxis [ axcoDomainWidth 1 ])\n            << configuration (coView [ vicoStroke Nothing ])\n            << configuration (coSelection [ ( Single, [ seOn \"dblclick\" ] ) ])\n\n",
        "type": "List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "cubeHelix",
        "comment": " Cube helix color interpolation for continuous color scales using the given\ngamma value (anchored at 1).\n",
        "type": "Float -> VegaLite.CInterpolate"
      },
      {
        "name": "cubeHelixLong",
        "comment": " Long-path cube helix color interpolation for continuous color scales using\nthe given gamma value (anchored at 1).\n",
        "type": "Float -> VegaLite.CInterpolate"
      },
      {
        "name": "customProjection",
        "comment": " Custom projection type. Additional custom projections from d3 can\nbe defined via the [Vega API](https://vega.github.io/vega/docs/projections/#register)\nand called from with this function where the parameter is the name of the D3\nprojection to use (e.g. `customProjection \"winkel3\"`).\n",
        "type": "String -> VegaLite.Projection"
      },
      {
        "name": "dAggregate",
        "comment": " Compute some aggregate summaray statistics for a field to be encoded with a\nlevel of detail (grouping) channel. The type of aggregation is determined by the\ngiven operation parameter.\n",
        "type": "VegaLite.Operation -> VegaLite.DetailChannel"
      },
      {
        "name": "dBin",
        "comment": " Discretize numeric values into bins when encoding with a level of detail\n(grouping) channel.\n",
        "type": "List VegaLite.BinProperty -> VegaLite.DetailChannel"
      },
      {
        "name": "dImpute",
        "comment": " Set the iputation rules for a detail channel. See the\n[Vega-Lite impute documentation](https://vega.github.io/vega-lite/docs/impute.html)\n",
        "type": "List VegaLite.ImputeProperty -> VegaLite.DetailChannel"
      },
      {
        "name": "dMType",
        "comment": " Level of measurement when encoding with a level of detail (grouping) channel.\n",
        "type": "VegaLite.Measurement -> VegaLite.DetailChannel"
      },
      {
        "name": "dName",
        "comment": " Field used for encoding with a level of detail (grouping) channel.\n",
        "type": "String -> VegaLite.DetailChannel"
      },
      {
        "name": "dTimeUnit",
        "comment": " Form of time unit aggregation of field values when encoding with a level of\ndetail (grouping) channel.\n",
        "type": "VegaLite.TimeUnit -> VegaLite.DetailChannel"
      },
      {
        "name": "dataColumn",
        "comment": " Create a column of data. A column has a name and a list of values.\n",
        "type": "String -> VegaLite.DataValues -> List VegaLite.DataColumn -> List VegaLite.DataColumn"
      },
      {
        "name": "dataFromColumns",
        "comment": " Declare a data source from a list of column values. Each column should contain\nvalues of the same type, but columns each with a different type are permitted.\nIf columns do not contain the same number of items the dataset will be truncated\nto the length of the shortest. A list of field formatting instructions can be\nprovided as the first parameter or an empty list to use the default formatting.\nThe columns are most easily generated with [dataColumn](#dataColumn):\n\n    data =\n        dataFromColumns [ parse [ ( \"Year\", foDate \"%Y\" ) ] ]\n            << dataColumn \"Animal\" (strs [ \"Fish\", \"Dog\", \"Cat\" ])\n            << dataColumn \"Age\" (nums [ 28, 12, 6 ])\n            << dataColumn \"Year\" (strs [ \"2010\", \"2014\", \"2015\" ])\n\nFor more complex inline data tables, such as mixures of arrays and objects, consider\nusing [dataFromJson](#dataFromJson).\n\n",
        "type": "List VegaLite.Format -> List VegaLite.DataColumn -> VegaLite.Data"
      },
      {
        "name": "dataFromJson",
        "comment": " Declare a data source from a json specification. The most likely use-case is\ncreating [geojson](http://geojson.org) objects with [`geometry`](#geometry),\n[`geometryCollection`](#geometryCollection) and [`geoFeatureCollection`](#geoFeatureCollection).\nFor more general cases of json creation such as data tables that mix arrays and\nobjects, consider\n[`Json.Encode`](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Encode).\n\n    let\n        geojson =\n            geometry (geoPolygon [ [ ( -3, 59 ), ( 4, 59 ), ( 4, 52 ), ( -3, 59 ) ] ]) []\n    in\n    toVegaLite\n        [ width 200\n        , height 200\n        , dataFromJson geojson []\n        , projection [ prType Orthographic ]\n        , geoshape []\n        ]\n\n",
        "type": "VegaLite.Spec -> List VegaLite.Format -> VegaLite.Data"
      },
      {
        "name": "dataFromRows",
        "comment": " Declare a data source from a list of row values. Each row should contain a\nlist of tuples in the form (_column name_, _value_). Each column can have a value\nof a different type but you must ensure that values are of the same type as others\nin the same column. A list of field formatting instructions can be provided as\nthe first parameter or an empty list to use the default formatting. Rows are most\neasily generated with [dataRow](#dataRow).\n\n    data =\n        dataFromRows [ parse [ ( \"Year\", foDate \"%Y\" ) ] ]\n            << dataRow [ ( \"Animal\", str \"Fish\" ), ( \"Age\", num 28 ), ( \"Year\", str \"2010\" ) ]\n            << dataRow [ ( \"Animal\", str \"Dog\" ), ( \"Age\", num 12 ), ( \"Year\", str \"2014\" ) ]\n            << dataRow [ ( \"Animal\", str \"Cat\" ), ( \"Age\", num 6 ), ( \"Year\", str \"2015\" ) ]\n\nGenerally, adding data by column is more efficient and less error-prone. For more\ncomplex inline data tables, such as mixures of arrays and objects, consider using\n[dataFromJson](#dataFromJson).\n\n",
        "type": "List VegaLite.Format -> List VegaLite.DataRow -> VegaLite.Data"
      },
      {
        "name": "dataFromSource",
        "comment": " Declare data from a named source. The source may be from named `datasets` within\na specification or one created via the [Vega View API](https://vega.github.io/vega/docs/api/view/#data).\nA list of field formatting instructions can be provided as the second parameter\nor an empty list to use the default formatting.\n\n    data = ...\n    json = ...\n    enc = ...\n    toVegaLite\n        [ datasets [ ( \"myData\", data [] ),  ( \"myJson\", dataFromJson json [] ) ]\n        , dataFromSource \"myData\" []\n        , bar []\n        , enc []\n        ]\n\n",
        "type": "String -> List VegaLite.Format -> VegaLite.Data"
      },
      {
        "name": "dataFromUrl",
        "comment": " Declare a data source from a url. The URL can be a local path on a web server\nor an external (CORS) URL. A list of field formatting instructions can be provided\nas the second parameter or an empty list to use the default formatting.\n",
        "type": "String -> List VegaLite.Format -> VegaLite.Data"
      },
      {
        "name": "dataName",
        "comment": " Name to give a data source. Useful when a specification needs to reference a\ndata source, such as one generated via an API call.\n\n    data =\n        dataFromUrl \"myData.json\" [] |> dataName \"myName\"\n\n",
        "type": "String -> VegaLite.Data -> VegaLite.Data"
      },
      {
        "name": "dataRow",
        "comment": " Create a row of data. A row comprises a list of (_columnName_, _value_) pairs.\n",
        "type": "List ( String, VegaLite.DataValue ) -> List VegaLite.DataRow -> List VegaLite.DataRow"
      },
      {
        "name": "datasets",
        "comment": " Create a dataset comprising a collection of named `Data` items. Each data item\ncan be created with normal data generating functions such as [dataFromRows](#dataFromRows)\nor [dataFromJson](#dataFromJson). These can be later referred to using\n[dataFromSource](#dataFromSource).\n\n    import Json.Encode as JE\n\n    let\n        data =\n            dataFromRows []\n                << dataRow [ ( \"cat\", str \"a\" ), ( \"val\", num 10 ) ]\n                << dataRow [ ( \"cat\", str \"b\" ), ( \"val\", num 18 ) ]\n        json =\n            JE.list\n                [ JE.object [ ( \"cat\", JE.string \"a\" ), ( \"val\", JE.float 120 ) ]\n                , JE.object [ ( \"cat\", JE.string \"b\" ), ( \"val\", JE.float 180 ) ]\n                ]\n\n        enc = ...\n\n    in\n    toVegaLite\n        [ datasets [ ( \"myData\", data [] ),  ( \"myJson\", dataFromJson json [] ) ]\n        , dataFromSource \"myData\" []\n        , bar []\n        , enc []\n        ]\n\n",
        "type": "List ( String, VegaLite.Data ) -> VegaLite.Data"
      },
      {
        "name": "description",
        "comment": " Description to be associated with a visualization.\n",
        "type": "String -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "detail",
        "comment": " Encode a 'level of detail' channel. This provides a way of grouping by a field\nbut unlike, say `color`, all groups have the same visual properties. The first\nparameter is a list of the field characteristics to be grouped.\n",
        "type": "List VegaLite.DetailChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "doDts",
        "comment": " Date-time values that define a scale domain.\n",
        "type": "List (List VegaLite.DateTime) -> VegaLite.ScaleDomain"
      },
      {
        "name": "doNums",
        "comment": " Numeric values that define a scale domain.\n",
        "type": "List Float -> VegaLite.ScaleDomain"
      },
      {
        "name": "doSelection",
        "comment": " Scale domain based on a named interactive selection.\n",
        "type": "String -> VegaLite.ScaleDomain"
      },
      {
        "name": "doStrs",
        "comment": " String values that define a scale domain.\n",
        "type": "List String -> VegaLite.ScaleDomain"
      },
      {
        "name": "domainRangeMap",
        "comment": " Create a pair of continuous domain to color mappings suitable for customising\nordered scales. The first parameter is a tuple representing the mapping of the lowest\nnumeric value in the domain to its equivalent color; the second tuple the mapping\nof the highest numeric value to color. If the domain contains any values between\nthese lower and upper bounds they are interpolated according to the scale's interpolation\nfunction. Convenience function equivalent to specifying separate `SDomain` and\n`SRange` lists and is safer as it guarantees a one-to-one correspondence between\ndomain and range values.\n\n    color\n        [ mName \"year\"\n        , mMType Ordinal\n        , mScale (domainRangeMap ( 1955, \"#e6959c\" ) ( 2000, \"#911a24\" ))\n        ]\n\n",
        "type": "( Float, String ) -> ( Float, String ) -> List VegaLite.ScaleProperty"
      },
      {
        "name": "dsv",
        "comment": " Delimited file format (DSV) with a given separator.\n",
        "type": "Char -> VegaLite.Format"
      },
      {
        "name": "dt",
        "comment": " Date-time data value.\n",
        "type": "List VegaLite.DateTime -> VegaLite.DataValue"
      },
      {
        "name": "dtDate",
        "comment": " Day of the month (1 to 31).\n",
        "type": "Int -> VegaLite.DateTime"
      },
      {
        "name": "dtDay",
        "comment": " Day of the week.\n",
        "type": "VegaLite.DayName -> VegaLite.DateTime"
      },
      {
        "name": "dtHour",
        "comment": " Hour of the day (0=midnight, 1=1am, 23=11pm etc.).\n",
        "type": "Int -> VegaLite.DateTime"
      },
      {
        "name": "dtMillisecond",
        "comment": " Millisecond of a second (0-999).\n",
        "type": "Int -> VegaLite.DateTime"
      },
      {
        "name": "dtMinute",
        "comment": " Minute of an hour (0-59).\n",
        "type": "Int -> VegaLite.DateTime"
      },
      {
        "name": "dtMonth",
        "comment": " Month of a year (1 to 12).\n",
        "type": "VegaLite.MonthName -> VegaLite.DateTime"
      },
      {
        "name": "dtQuarter",
        "comment": " Year quarter (1 to 4).\n",
        "type": "Int -> VegaLite.DateTime"
      },
      {
        "name": "dtRange",
        "comment": " Min max date-time range to be used in data filtering. If either\nparameter is an empty list, it is assumed to be unbounded.\n",
        "type": "List VegaLite.DateTime -> List VegaLite.DateTime -> VegaLite.FilterRange"
      },
      {
        "name": "dtSecond",
        "comment": " Second of a minute (0-59).\n",
        "type": "Int -> VegaLite.DateTime"
      },
      {
        "name": "dtYear",
        "comment": " A year.\n",
        "type": "Int -> VegaLite.DateTime"
      },
      {
        "name": "dts",
        "comment": " List of date-time data values.\n",
        "type": "List (List VegaLite.DateTime) -> VegaLite.DataValues"
      },
      {
        "name": "encoding",
        "comment": " Create an encoding specification from a list of channel encodings.\n",
        "type": "List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "errorband",
        "comment": " [Errorband composite mark](https://vega.github.io/vega-lite/docs/errorband.html)\nfor showing summaries of variation along a signal. By default no border is drawn.\nTo add a border with default properties use [maBorders](#maBorders) with an empty list.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "errorbar",
        "comment": " [Errorbar composite mark](https://vega.github.io/vega-lite/docs/errorbar.html)\nfor showing summaries of variation along a signal. By default no ticks are drawn.\nTo add ticks with default properties use [maTicks](#maTicks) with an empty list.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "expr",
        "comment": " Expression that should evaluate to either true or false. Can use any valid\n[Vega expression](https://vega.github.io/vega/docs/expressions/).\n",
        "type": "String -> VegaLite.BooleanOp"
      },
      {
        "name": "fAggregate",
        "comment": " Compute some aggregate summaray statistics for a field to be encoded with a\nfacet channel. The type of aggregation is determined by the given operation\nparameter.\n",
        "type": "VegaLite.Operation -> VegaLite.FacetChannel"
      },
      {
        "name": "fBin",
        "comment": " Discretize numeric values into bins when encoding with a facet channel.\n",
        "type": "List VegaLite.BinProperty -> VegaLite.FacetChannel"
      },
      {
        "name": "fHeader",
        "comment": " Guide that spans a collection of faceted plots, each of which may have their own axes.\n",
        "type": "List VegaLite.HeaderProperty -> VegaLite.FacetChannel"
      },
      {
        "name": "fMType",
        "comment": " Level of measurement when encoding with a facet channel.\n",
        "type": "VegaLite.Measurement -> VegaLite.FacetChannel"
      },
      {
        "name": "fName",
        "comment": " Field used for encoding with a facet channel.\n",
        "type": "String -> VegaLite.FacetChannel"
      },
      {
        "name": "fTimeUnit",
        "comment": " Form of time unit aggregation of field values when encoding with a facet channel.\n",
        "type": "VegaLite.TimeUnit -> VegaLite.FacetChannel"
      },
      {
        "name": "facet",
        "comment": " Fields to be used to facet a view in rows or columns creating a set of small\nmultiples. Used when the encoding of the visualization in small multiples is\nidentical, but data for each is grouped by the given fields. When\ncreating a faceted view in this way you also need to define a full specification\nto apply to each of those facets using `asSpec`.\n\n    spec = ...\n    toVegaLite\n        [ facet [ rowBy [ fName \"Origin\", fMType Nominal ] ]\n        , specifcation spec\n        ]\n\n",
        "type": "List VegaLite.FacetMapping -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "false",
        "comment": " A false value used for functions that can accept a Boolean literal or a\nreference to something that generates a Boolean value. Convenience function\nequivalent to `boo False`\n",
        "type": "VegaLite.DataValue"
      },
      {
        "name": "fiCompose",
        "comment": " Build up a filtering predicate through logical composition (`and`, `or` etc.).\n",
        "type": "VegaLite.BooleanOp -> VegaLite.Filter"
      },
      {
        "name": "fiEqual",
        "comment": " Filter a data stream so that only data in a given field equal to the given\nvalue are used.\n",
        "type": "String -> VegaLite.DataValue -> VegaLite.Filter"
      },
      {
        "name": "fiExpr",
        "comment": " Filter a data stream so that only data that satisfy the given predicate\nexpression are used.\n",
        "type": "String -> VegaLite.Filter"
      },
      {
        "name": "fiGreaterThan",
        "comment": " Filter a data stream so that only data in a given field greater than the given\nvalue are used.\n",
        "type": "String -> VegaLite.DataValue -> VegaLite.Filter"
      },
      {
        "name": "fiGreaterThanEq",
        "comment": " Filter a data stream so that only data in a given field greater than or equal\nto the given value are used.\n",
        "type": "String -> VegaLite.DataValue -> VegaLite.Filter"
      },
      {
        "name": "fiLessThan",
        "comment": " Filter a data stream so that only data in a given field less than the given\nvalue are used.\n",
        "type": "String -> VegaLite.DataValue -> VegaLite.Filter"
      },
      {
        "name": "fiLessThanEq",
        "comment": " Filter a data stream so that only data in a given field less than or equal to\nthe given value are used.\n",
        "type": "String -> VegaLite.DataValue -> VegaLite.Filter"
      },
      {
        "name": "fiOneOf",
        "comment": " Filter a data stream so that only data in a given field contained in the given\nlist of values are used.\n",
        "type": "String -> VegaLite.DataValues -> VegaLite.Filter"
      },
      {
        "name": "fiRange",
        "comment": " Filter a data stream so that only data in a given field that are within the\ngiven range are used.\n",
        "type": "String -> VegaLite.FilterRange -> VegaLite.Filter"
      },
      {
        "name": "fiSelection",
        "comment": " Filter a data stream so that only data in a given field that are within the\ngiven interactive selection are used.\n",
        "type": "String -> VegaLite.Filter"
      },
      {
        "name": "fiValid",
        "comment": " Filter a data stream so that only valid data (i.e. not null or NaN) in a given\nfield are used.\n",
        "type": "String -> VegaLite.Filter"
      },
      {
        "name": "fill",
        "comment": " Encode a fill channel. This acts in a similar way to encoding by `color` but\nonly affects the interior of closed shapes. If both `fill` and `color` encodings\nare specified, `fill` takes precedence.\n",
        "type": "List VegaLite.MarkChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "filter",
        "comment": " Apply a filter to a channel or field.\n",
        "type": "VegaLite.Filter -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "flatten",
        "comment": " Map array-valued fields to a set of individual data objects, one per array entry.\n",
        "type": "List String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "flattenAs",
        "comment": " Similar to [flatten](#flatten) but allows the new output fields to be named\n(second parameter).\n",
        "type": "List String -> List String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "foDate",
        "comment": " Date format for parsing input data using\n[D3's formatting specifiers](https://vega.github.io/vega-lite/docs/data.html#format)\nor left as an empty string for default formatting.\n",
        "type": "String -> VegaLite.DataType"
      },
      {
        "name": "foUtc",
        "comment": " Similar to [foDate](#foDate) but for UTC format dates.\n",
        "type": "String -> VegaLite.DataType"
      },
      {
        "name": "fold",
        "comment": " Collapse one or more data fields into two properties: a _key_ (containing\nthe original data field name) and a _value_ (containing the data value). Useful\nfor mapping matrix or cross-tabulation data into a standardized format.\n",
        "type": "List String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "foldAs",
        "comment": " Similar to [fold](#fold) but allows the new output `key` and `value` fields\nto be given alternative names\n",
        "type": "List String -> String -> String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "geoFeatureCollection",
        "comment": " Geo features to be used in a `geoshape` specification. Each feature object in\nthis collection can be created with [geometry](#geometry).\n\n    geojson =\n        geoFeatureCollection\n            [ geometry (geoPolygon [ [ ( -3, 59 ), ( -3, 52 ), ( 4, 52 ), ( -3, 59 ) ] ])\n                [ ( \"myRegionName\", str \"Northern region\" ) ]\n            , geometry (geoPolygon [ [ ( -3, 52 ), ( 4, 52 ), ( 4, 45 ), ( -3, 52 ) ] ])\n                [ ( \"myRegionName\", str \"Southern region\" ) ]\n            ]\n\n",
        "type": "List VegaLite.Spec -> VegaLite.Spec"
      },
      {
        "name": "geoLine",
        "comment": " Line geometry for programmatically creating GeoShapes. Equivalent to the\n[GeoJson geometry `line` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
        "type": "List ( Float, Float ) -> VegaLite.Geometry"
      },
      {
        "name": "geoLines",
        "comment": " Multi-line geometry for programmatically creating GeoShapes. Equivalent\nto the [GeoJson geometry `multi-line` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
        "type": "List (List ( Float, Float )) -> VegaLite.Geometry"
      },
      {
        "name": "geoPoint",
        "comment": " Point geometry for programmatically creating GeoShapes. Equivalent to\nthe [GeoJson geometry `point` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
        "type": "Float -> Float -> VegaLite.Geometry"
      },
      {
        "name": "geoPoints",
        "comment": " Multi-point geometry for programmatically creating GeoShapes. Equivalent\nto the [GeoJson geometry `multi-point` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
        "type": "List ( Float, Float ) -> VegaLite.Geometry"
      },
      {
        "name": "geoPolygon",
        "comment": " Polygon geometry for programmatically creating GeoShapes. Equivalent\nto the [GeoJson geometry `polygon` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
        "type": "List (List ( Float, Float )) -> VegaLite.Geometry"
      },
      {
        "name": "geoPolygons",
        "comment": " Multi-polygon geometry for programmatically creating GeoShapes. Equivalent\nto the [GeoJson geometry `multi-polygon` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n",
        "type": "List (List (List ( Float, Float ))) -> VegaLite.Geometry"
      },
      {
        "name": "geometry",
        "comment": " Geometric object to be used in a `geoshape`. The first parameter is\nthe geometric type, the second an optional list of properties to be associated\nwith the object.\n\n      geojson =\n          geometry (geoPolygon [ [ ( -3, 59 ), ( 4, 59 ), ( 4, 52 ), ( -3, 59 ) ] ]) []\n\n",
        "type": "VegaLite.Geometry -> List ( String, VegaLite.DataValue ) -> VegaLite.Spec"
      },
      {
        "name": "geometryCollection",
        "comment": " Geometry objects to be used in a `geoshape` specification. Each geometry\nobject can be created with [geometry](#geometry).\n\n    geojson =\n        geometryCollection\n            [ geometry (geoPolygon [ [ ( -3, 59 ), ( 4, 59 ), ( 4, 52 ), ( -3, 59 ) ] ]) []\n            , geometry (geoPoint -3.5 55.5) []\n            ]\n\n",
        "type": "List VegaLite.Spec -> VegaLite.Spec"
      },
      {
        "name": "geoshape",
        "comment": " [Geoshape](https://vega.github.io/vega-lite/docs/geoshape.html)\ndetermined by georaphically referenced coordinates.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "hAggregate",
        "comment": " Compute some aggregate summaray statistics for a field to be encoded with a\nhyperlink channel. The type of aggregation is determined by the given operation\nparameter.\n",
        "type": "VegaLite.Operation -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hBin",
        "comment": " Discretize numeric values into bins when encoding with a hyperlink channel.\n",
        "type": "List VegaLite.BinProperty -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hBinned",
        "comment": " Indicate that data encoded with a hyperlink channel are already binned.\n",
        "type": "VegaLite.HyperlinkChannel"
      },
      {
        "name": "hConcat",
        "comment": " Specifications to be juxtaposed horizontally in a visualization.\n",
        "type": "List VegaLite.Spec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "hDataCondition",
        "comment": " Make a hyperlink channel conditional on some predicate expression. The first\nparameter provides the expression to evaluate, the second the encoding to apply\nif the expression is true, the third the encoding if the expression is false.\n",
        "type": "VegaLite.BooleanOp -> List VegaLite.HyperlinkChannel -> List VegaLite.HyperlinkChannel -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hMType",
        "comment": " Level of measurement when encoding with a hyperlink channel.\n",
        "type": "VegaLite.Measurement -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hName",
        "comment": " Field used for encoding with a hyperlink channel.\n",
        "type": "String -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hRepeat",
        "comment": " Reference in a hyperlink channel to a field name generated by `repeat`. The\nparameter identifies whether reference is being made to fields being laid out\nin columns or in rows.\n",
        "type": "VegaLite.Arrangement -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hSelectionCondition",
        "comment": " Make a hyperlink channel conditional on interactive selection. The first parameter\nprovides the selection to evaluate, the second the encoding to apply if the hyperlink\nhas been selected, the third the encoding if it is not selected.\n",
        "type": "VegaLite.BooleanOp -> List VegaLite.HyperlinkChannel -> List VegaLite.HyperlinkChannel -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hStr",
        "comment": " Literal string value when encoding with a hyperlink channel.\n",
        "type": "String -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hTimeUnit",
        "comment": " Time unit aggregation of field values when encoding with a hyperlink channel.\n",
        "type": "VegaLite.TimeUnit -> VegaLite.HyperlinkChannel"
      },
      {
        "name": "hdFormat",
        "comment": " Header format for a faceted view.\n",
        "type": "String -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdLabelAngle",
        "comment": " Header label rotation angle (in degrees) for a faceted view. A 'label' is the\ntitle for each sub-plot in a faceted view.\n",
        "type": "Float -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdLabelColor",
        "comment": " Header label text color for a faceted view.\n",
        "type": "String -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdLabelFont",
        "comment": " Header label font for a faceted view.\n",
        "type": "String -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdLabelFontSize",
        "comment": " Header label font size for a faceted view.\n",
        "type": "Float -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdLabelLimit",
        "comment": " Maximum length of a header label in a faceted view.\n",
        "type": "Float -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdLabelPadding",
        "comment": " Spacing in pixels between facet labels and the main plot area.\n",
        "type": "Float -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitle",
        "comment": " Header title in a faceted view. A 'title' is the overall title describing\nthe collection of faceted plots.\n",
        "type": "String -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitleAnchor",
        "comment": " Anchor position of a header title in a faceted view.\n",
        "type": "VegaLite.APosition -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitleAngle",
        "comment": " Text angle of a header title in a faceted view.\n",
        "type": "Float -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitleBaseline",
        "comment": " Vertical alignment of a header title in a faceted view.\n",
        "type": "VegaLite.VAlign -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitleColor",
        "comment": " Text color of a header title in a faceted view.\n",
        "type": "String -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitleFont",
        "comment": " Title font in a faceted view.\n",
        "type": "String -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitleFontSize",
        "comment": " Title font size in a faceted view.\n",
        "type": "Float -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitleFontWeight",
        "comment": " Title font weight in a faceted view.\n",
        "type": "String -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitleLimit",
        "comment": " Maximum length of a header title in a faceted view.\n",
        "type": "Float -> VegaLite.HeaderProperty"
      },
      {
        "name": "hdTitlePadding",
        "comment": " Spacing in pixels between the main facet title and labels.\n",
        "type": "Float -> VegaLite.HeaderProperty"
      },
      {
        "name": "height",
        "comment": " Override the default height of the visualization. If not specified the height\nwill be calculated based on the content of the visualization.\n",
        "type": "Float -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "hyperlink",
        "comment": " Encode a hyperlink channel. The first parameter is a list of hyperlink channel\nproperties that characterise the hyperlinking such as the destination URL and cursor\ntype.\n",
        "type": "List VegaLite.HyperlinkChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "iCheckbox",
        "comment": " Checkbox input element that can bound to a named field value.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iColor",
        "comment": " Color input element that can bound to a named field value.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iDate",
        "comment": " Date input element that can bound to a named field value.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iDateTimeLocal",
        "comment": " Local time input element that can bound to a named field value.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iMonth",
        "comment": " Month input element that can bound to a named field value.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iNumber",
        "comment": " Number input element that can bound to a named field value.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iRadio",
        "comment": " Radio box input element that can bound to a named field value.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iRange",
        "comment": " Range slider input element that can bound to a named field value.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iSelect",
        "comment": " Select input element that can bound to a named field value.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iTel",
        "comment": " Telephone number input element that can bound to a named field value.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iText",
        "comment": " Text input element that can bound to a named field value.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iTime",
        "comment": " Time input element that can bound to a named field value.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "iWeek",
        "comment": " Week input element that can bound to a named field value.\n",
        "type": "String -> List VegaLite.InputProperty -> VegaLite.Binding"
      },
      {
        "name": "imFrame",
        "comment": " 1d window over which data imputation values are generated. The two\nparameters should either be `Just` a number indicating the offset from the current\ndata object, or `Nothing` to indicate unbounded rows preceding or following the\ncurrent data object.\n",
        "type": "Maybe.Maybe Int -> Maybe.Maybe Int -> VegaLite.ImputeProperty"
      },
      {
        "name": "imGroupBy",
        "comment": " Allow imputing of missing values on a per-group basis. For use with the impute\ntransform only and not a channel encoding.\n",
        "type": "List String -> VegaLite.ImputeProperty"
      },
      {
        "name": "imKeyValSequence",
        "comment": " Key values to be considered for imputation as a sequence of numbers between\na start (first parameter), to less than an end (second parameter) in steps of\nthe third parameter.\n",
        "type": "Float -> Float -> Float -> VegaLite.ImputeProperty"
      },
      {
        "name": "imKeyVals",
        "comment": " Key values to be considered for imputation.\n",
        "type": "VegaLite.DataValues -> VegaLite.ImputeProperty"
      },
      {
        "name": "imMethod",
        "comment": " Imputation method to use when replacing values.\n",
        "type": "VegaLite.ImMethod -> VegaLite.ImputeProperty"
      },
      {
        "name": "imValue",
        "comment": " New value to use when imputing with the method `ImValue`.\n",
        "type": "VegaLite.DataValue -> VegaLite.ImputeProperty"
      },
      {
        "name": "impute",
        "comment": " Impute missing data values. The first parameter is the data field to process;\nthe second the key field to uniquely identify data objects within a group; the\nthird customisable options.\n",
        "type": "String -> String -> List VegaLite.ImputeProperty -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "inDebounce",
        "comment": " Delay to introduce when processing input events in order to avoid unnecessary\nevent broadcasting.\n",
        "type": "Float -> VegaLite.InputProperty"
      },
      {
        "name": "inElement",
        "comment": " CSS selector indicating the parent element to which an input element should\nbe added. Allows the option of the input element to be outside the visualization\ncontainer.\n",
        "type": "String -> VegaLite.InputProperty"
      },
      {
        "name": "inMax",
        "comment": " Maximum slider value for a range input element.\n",
        "type": "Float -> VegaLite.InputProperty"
      },
      {
        "name": "inMin",
        "comment": " Minimum slider value for a range input element.\n",
        "type": "Float -> VegaLite.InputProperty"
      },
      {
        "name": "inName",
        "comment": " Custom label for a radio or select input element.\n",
        "type": "String -> VegaLite.InputProperty"
      },
      {
        "name": "inOptions",
        "comment": " Options for a radio or select input element.\n",
        "type": "List String -> VegaLite.InputProperty"
      },
      {
        "name": "inPlaceholder",
        "comment": " Initial placeholding text for input elements such as text fields.\n",
        "type": "String -> VegaLite.InputProperty"
      },
      {
        "name": "inStep",
        "comment": " Minimum input element range slider increment.\n",
        "type": "Float -> VegaLite.InputProperty"
      },
      {
        "name": "iqrScale",
        "comment": " A scaling of the interquartile range to be used as whiskers in a boxplot.\nFor example a value of 1.5 would extend whiskers to ±1.5x the IQR from the mean.\n",
        "type": "Float -> VegaLite.SummaryExtent"
      },
      {
        "name": "jsonProperty",
        "comment": " Property to be extracted from some JSON when it has some surrounding structure.\ne.g., specifying the property `values.features` is equivalent to retrieving\n`json.values.features` from a JSON object with a custom delimiter.\n",
        "type": "String -> VegaLite.Format"
      },
      {
        "name": "layer",
        "comment": " Assign a list of specifications to superposed layers in a visualization.\n",
        "type": "List VegaLite.Spec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "leClipHeight",
        "comment": " Limit height of legend entries.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leColumnPadding",
        "comment": " Horizontal padding between symbol legend entries.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leColumns",
        "comment": " Number of columns in which to arrange symbol legend entries.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leCornerRadius",
        "comment": " Legend corner radius.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leDirection",
        "comment": " Direction of a legend.\n",
        "type": "VegaLite.MarkOrientation -> VegaLite.LegendProperty"
      },
      {
        "name": "leDts",
        "comment": " An explicit set of legend date-times.\n",
        "type": "List (List VegaLite.DateTime) -> VegaLite.LegendValues"
      },
      {
        "name": "leFillColor",
        "comment": " Legend background color.\n",
        "type": "String -> VegaLite.LegendProperty"
      },
      {
        "name": "leFormat",
        "comment": " Formatting pattern for legend labels.\n",
        "type": "String -> VegaLite.LegendProperty"
      },
      {
        "name": "leGradientLength",
        "comment": " Length in pixels of the primary axis of a color ramp legend.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leGradientStrokeColor",
        "comment": " Color for strokes in a color ramp legend.\n",
        "type": "String -> VegaLite.LegendProperty"
      },
      {
        "name": "leGradientStrokeWidth",
        "comment": " Width for strokes in a color ramp legend.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leGradientThickness",
        "comment": " Thickness in pixels of a color ramp legend.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leGridAlign",
        "comment": " Alignment to apply to symbol legends rows and columns.\n",
        "type": "VegaLite.CompositionAlignment -> VegaLite.LegendProperty"
      },
      {
        "name": "leLabelAlign",
        "comment": " Horizontal alignment of legend labels.\n",
        "type": "VegaLite.HAlign -> VegaLite.LegendProperty"
      },
      {
        "name": "leLabelBaseline",
        "comment": " Vertical alignment of legend labels.\n",
        "type": "VegaLite.VAlign -> VegaLite.LegendProperty"
      },
      {
        "name": "leLabelColor",
        "comment": " Color for legend labels.\n",
        "type": "String -> VegaLite.LegendProperty"
      },
      {
        "name": "leLabelFont",
        "comment": " Font for legend labels.\n",
        "type": "String -> VegaLite.LegendProperty"
      },
      {
        "name": "leLabelFontSize",
        "comment": " Font size legend labels.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leLabelLimit",
        "comment": " Maximum width for legend labels in pixel units.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leLabelOffset",
        "comment": " Offset for legend labels.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leLabelOverlap",
        "comment": " Strategy for resolving overlapping legend labels.\n",
        "type": "VegaLite.OverlapStrategy -> VegaLite.LegendProperty"
      },
      {
        "name": "leNums",
        "comment": " An explicit set of numeric legend values.\n",
        "type": "List Float -> VegaLite.LegendValues"
      },
      {
        "name": "leOffset",
        "comment": " Offset in pixels of a legend from the edge of its enclosing group or data rectangle.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leOrient",
        "comment": " Position of a legend in a scene.\n",
        "type": "VegaLite.LegendOrientation -> VegaLite.LegendProperty"
      },
      {
        "name": "lePadding",
        "comment": " Padding in pixels between a legend and axis.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leRowPadding",
        "comment": " Vertical spacing in pixel units between a symbol legend entries.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leStrokeColor",
        "comment": " Legend border color.\n",
        "type": "String -> VegaLite.LegendProperty"
      },
      {
        "name": "leStrokeWidth",
        "comment": " Legend border stroke width.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leStrs",
        "comment": " An explicit set of legend strings.\n",
        "type": "List String -> VegaLite.LegendValues"
      },
      {
        "name": "leSymbolFillColor",
        "comment": " Legend symbol fill color.\n",
        "type": "String -> VegaLite.LegendProperty"
      },
      {
        "name": "leSymbolSize",
        "comment": " Legend symbol size.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leSymbolStrokeColor",
        "comment": " Legend symbol outline color.\n",
        "type": "String -> VegaLite.LegendProperty"
      },
      {
        "name": "leSymbolStrokeWidth",
        "comment": " Legend symbol stroke width.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leSymbolType",
        "comment": " Legend symbol type.\n",
        "type": "VegaLite.Symbol -> VegaLite.LegendProperty"
      },
      {
        "name": "leTickCount",
        "comment": " Number of tick marks in a quantitative legend.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leTitle",
        "comment": " Title of a legend.\n",
        "type": "String -> VegaLite.LegendProperty"
      },
      {
        "name": "leTitleAlign",
        "comment": " Horizontal alignment for legend titles.\n",
        "type": "VegaLite.HAlign -> VegaLite.LegendProperty"
      },
      {
        "name": "leTitleBaseline",
        "comment": " Vertical alignment for legend titles.\n",
        "type": "VegaLite.VAlign -> VegaLite.LegendProperty"
      },
      {
        "name": "leTitleColor",
        "comment": " Color for legend title.\n",
        "type": "String -> VegaLite.LegendProperty"
      },
      {
        "name": "leTitleFont",
        "comment": " Font for legend titles.\n",
        "type": "String -> VegaLite.LegendProperty"
      },
      {
        "name": "leTitleFontSize",
        "comment": " Font size for legend titles.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leTitleFontWeight",
        "comment": " Font weight for legend titles.\n",
        "type": "VegaLite.FontWeight -> VegaLite.LegendProperty"
      },
      {
        "name": "leTitleLimit",
        "comment": " Maximum size in pixel units for legend titles.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leTitlePadding",
        "comment": " Spacing in pixel units between title and legend.\n",
        "type": "Float -> VegaLite.LegendProperty"
      },
      {
        "name": "leType",
        "comment": " Type of legend.\n",
        "type": "VegaLite.Legend -> VegaLite.LegendProperty"
      },
      {
        "name": "leValues",
        "comment": " An explicit set of legend values.\n",
        "type": "VegaLite.LegendValues -> VegaLite.LegendProperty"
      },
      {
        "name": "leZIndex",
        "comment": " Drawing order of a legend relative to other chart elements. To\nplace a legend in front of others use a positive integer, or 0 to draw behind.\n",
        "type": "Int -> VegaLite.LegendProperty"
      },
      {
        "name": "lecoClipHeight",
        "comment": " Default maximum height of legend entries.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoColumnPadding",
        "comment": " Default horizontal padding between symbol legend entries.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoColumns",
        "comment": " Default number of columns in which to arrange symbol legend entries.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoCornerRadius",
        "comment": " Default legend corner radius.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoEntryPadding",
        "comment": " Default spacing between legend items.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoFillColor",
        "comment": " Default background legend color.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoGradientDirection",
        "comment": " Default direction of a color ramp legend.\n",
        "type": "VegaLite.MarkOrientation -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoGradientHeight",
        "comment": " Default height of a color ramp legend.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoGradientLabelBaseline",
        "comment": " Default vertical alignment for labels in a color ramp legend.\n",
        "type": "VegaLite.VAlign -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoGradientLabelLimit",
        "comment": " Default maximum allowable length for labels in a color ramp legend.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoGradientLabelOffset",
        "comment": " Default vertical offset in pixel units for labels in a color ramp legend.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoGradientStrokeColor",
        "comment": " Default color for strokes in a color ramp legend.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoGradientStrokeWidth",
        "comment": " Default width for strokes in a color ramp legend.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoGradientWidth",
        "comment": " Default width of a color ramp legend.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoGridAlign",
        "comment": " Defailt alignment to apply to symbol legends rows and columns.\n",
        "type": "VegaLite.CompositionAlignment -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoLabelAlign",
        "comment": " Default horizontal alignment of legend labels.\n",
        "type": "VegaLite.HAlign -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoLabelBaseline",
        "comment": " Default vertical alignment of legend labels.\n",
        "type": "VegaLite.VAlign -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoLabelColor",
        "comment": " Default color for legend labels.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoLabelFont",
        "comment": " Default font for legend labels.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoLabelFontSize",
        "comment": " Default font size legend labels.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoLabelLimit",
        "comment": " Default maximum width for legend labels in pixel units.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoLabelOffset",
        "comment": " Default offset for legend labels.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoLabelOverlap",
        "comment": " Strategy for resolving overlapping legend labels.\n",
        "type": "VegaLite.OverlapStrategy -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoOffset",
        "comment": " Default offset in pixel units between the legend and the enclosing\ngroup or data rectangle.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoOrient",
        "comment": " Default legend position relative to the main plot content.\n",
        "type": "VegaLite.LegendOrientation -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoPadding",
        "comment": " Default spacing in pixel units between a legend and axis.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoRowPadding",
        "comment": " Default vertical spacing in pixel units between legend symbol entries.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoShortTimeLabels",
        "comment": " Whether or not time labels are abbreviated by default in a legend.\n",
        "type": "Bool -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoStrokeColor",
        "comment": " Default legend border color.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoStrokeDash",
        "comment": " Default legend border stroke dash style.\n",
        "type": "List Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoStrokeWidth",
        "comment": " Default legend border stroke width.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoSymbolBaseFillColor",
        "comment": " Default legend symbol fill color for when no fill scale color in legend encoding.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoSymbolBaseStrokeColor",
        "comment": " Default legend symbol stroke color for when no stroke scale color in legend encoding.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoSymbolDirection",
        "comment": " Default direction of a symbol legend.\n",
        "type": "VegaLite.MarkOrientation -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoSymbolFillColor",
        "comment": " Default legend symbol fill color.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoSymbolOffset",
        "comment": " Default horizontal pixel offset for legend symbols.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoSymbolSize",
        "comment": " Default legend symbol size.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoSymbolStrokeColor",
        "comment": " Default legend symbol outline color.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoSymbolStrokeWidth",
        "comment": " Default legend symbol stroke width.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoSymbolType",
        "comment": " Default legend symbol type.\n",
        "type": "VegaLite.Symbol -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoTitleAlign",
        "comment": " Default horizontal alignment for legend titles.\n",
        "type": "VegaLite.HAlign -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoTitleBaseline",
        "comment": " Default vertical alignment for legend titles.\n",
        "type": "VegaLite.VAlign -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoTitleColor",
        "comment": " Default color legend titles.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoTitleFont",
        "comment": " Default font for legend titles.\n",
        "type": "String -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoTitleFontSize",
        "comment": " Default font size for legend titles.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoTitleFontWeight",
        "comment": " Default font weight for legend titles.\n",
        "type": "VegaLite.FontWeight -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoTitleLimit",
        "comment": " Default maximum size in pixel units for legend titles.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "lecoTitlePadding",
        "comment": " Default spacing in pixel units between title and legend.\n",
        "type": "Float -> VegaLite.LegendConfig"
      },
      {
        "name": "line",
        "comment": " [Line mark](https://vega.github.io/vega-lite/docs/line.html) for symbolising\na sequence of values.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "lmMarker",
        "comment": " Properties of a line marker that is overlaid on an area mark.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.LineMarker"
      },
      {
        "name": "lookup",
        "comment": " Perform a lookup of named fields between two data sources. This allows you to\nfind values in one data source based on the values in another. The first parameter\nis the field in the primary data source to act as key, the second is the secondary\ndata source which can be specified with a call to `dataFromUrl` or other data\ngenerating function. The third is the name of the field in the secondary\ndata source to match values with the primary key. The fourth parameter is the list\nof fields to be stored when the keys match.\n",
        "type": "String -> ( VegaLite.VLProperty, VegaLite.Spec ) -> String -> List String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "lookupAs",
        "comment": " Similar to [lookup](#lookup) but returns the entire set of field values from\nthe secondary data source when keys match. Accessed with via name provided in the\nfourth parameter.\n",
        "type": "String -> VegaLite.Data -> String -> String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "mAggregate",
        "comment": " Compute some aggregate summaray statistics for a field to be encoded with a\nmark property channel. The type of aggregation is determined by the given operation\nparameter.\n",
        "type": "VegaLite.Operation -> VegaLite.MarkChannel"
      },
      {
        "name": "mBin",
        "comment": " Discretize numeric values into bins when encoding with a mark property channel.\n",
        "type": "List VegaLite.BinProperty -> VegaLite.MarkChannel"
      },
      {
        "name": "mBinned",
        "comment": " Indicate that data encoding with a mark are already binned.\n",
        "type": "VegaLite.MarkChannel"
      },
      {
        "name": "mBoo",
        "comment": " Boolean value when encoding with a mark property channel.\n",
        "type": "Bool -> VegaLite.MarkChannel"
      },
      {
        "name": "mDataCondition",
        "comment": " Make a mark channel conditional on one or more predicate expressions. The first\nparameter is a list of tuples each pairing a test condition with the encoding if\nthat condition evaluates to true. The second is the encoding if none of the tests\nare true.\n\n    color\n        [ mDataCondition [ ( expr \"datum.myField === null\", [ mStr \"grey\" ] ) ]\n            [ mStr \"black\" ]\n        ]\n\n",
        "type": "List ( VegaLite.BooleanOp, List VegaLite.MarkChannel ) -> List VegaLite.MarkChannel -> VegaLite.MarkChannel"
      },
      {
        "name": "mImpute",
        "comment": " Iputation rules for a mark channel. See the\n[Vega-Lite impute documentation](https://vega.github.io/vega-lite/docs/impute.html)\n",
        "type": "List VegaLite.ImputeProperty -> VegaLite.MarkChannel"
      },
      {
        "name": "mLegend",
        "comment": " Properties of a legend that describes a mark's encoding. For no legend, provide\nan empty list as a parameter.\n",
        "type": "List VegaLite.LegendProperty -> VegaLite.MarkChannel"
      },
      {
        "name": "mMType",
        "comment": " Level of measurement when encoding with a mark property channel.\n",
        "type": "VegaLite.Measurement -> VegaLite.MarkChannel"
      },
      {
        "name": "mName",
        "comment": " Field used for encoding with a mark property channel.\n",
        "type": "String -> VegaLite.MarkChannel"
      },
      {
        "name": "mNum",
        "comment": " Literal numeric value when encoding with a mark property channel.\n",
        "type": "Float -> VegaLite.MarkChannel"
      },
      {
        "name": "mPath",
        "comment": " SVG path string used when encoding with a mark property channel. Useful\nfor providing custom shapes.\n",
        "type": "String -> VegaLite.MarkChannel"
      },
      {
        "name": "mRepeat",
        "comment": " Reference in a mark channel to a field name generated by `repeat`. The\nparameter identifies whether fields are to be laid out in columns or rows.\n",
        "type": "VegaLite.Arrangement -> VegaLite.MarkChannel"
      },
      {
        "name": "mScale",
        "comment": " Scaling applied to a field when encoding with a mark property channel.\nThe scale will transform a field's value into a color, shape, size etc.\n",
        "type": "List VegaLite.ScaleProperty -> VegaLite.MarkChannel"
      },
      {
        "name": "mSelectionCondition",
        "comment": " Make a mark channel conditional on interactive selection. The first parameter\nis a selection condition to evaluate; the second the encoding to apply if that selection\nis true; the third parameter is the encoding if the selection is false.\n\n    color\n        [ mSelectionCondition ( selectionName \"myBrush\")\n            [ mName \"myField\", mMType Ordinal ]\n            [ mStr \"grey\" ]\n        ]\n\n",
        "type": "VegaLite.BooleanOp -> List VegaLite.MarkChannel -> List VegaLite.MarkChannel -> VegaLite.MarkChannel"
      },
      {
        "name": "mStr",
        "comment": " Literal string value when encoding with a mark property channel.\n",
        "type": "String -> VegaLite.MarkChannel"
      },
      {
        "name": "mTimeUnit",
        "comment": " Time unit aggregation of field values when encoding with a mark property channel.\n",
        "type": "VegaLite.TimeUnit -> VegaLite.MarkChannel"
      },
      {
        "name": "mTitle",
        "comment": " Title of a field when encoding with a mark property channel.\n",
        "type": "String -> VegaLite.MarkChannel"
      },
      {
        "name": "maAlign",
        "comment": " Horizontal alignment of a text mark.\n",
        "type": "VegaLite.HAlign -> VegaLite.MarkProperty"
      },
      {
        "name": "maAngle",
        "comment": " Rotation angle in degrees of a text mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maBandSize",
        "comment": " Band size of a bar mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maBaseline",
        "comment": " Vertical alignment of a text mark.\n",
        "type": "VegaLite.VAlign -> VegaLite.MarkProperty"
      },
      {
        "name": "maBinSpacing",
        "comment": " Offset between bars for a binned field using a bar mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maBorders",
        "comment": " Border properties for an errorband mark.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.MarkProperty"
      },
      {
        "name": "maClip",
        "comment": " Whether or not a mark should be clipped to the enclosing group's dimensions.\n",
        "type": "Bool -> VegaLite.MarkProperty"
      },
      {
        "name": "maColor",
        "comment": " Default color of a mark. Note that `maFill` and `maStroke` have higher\nprecedence and will override this if specified.\n",
        "type": "String -> VegaLite.MarkProperty"
      },
      {
        "name": "maContinuousBandSize",
        "comment": " Continuous band size of a bar mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maCursor",
        "comment": " Cursor to be associated with a hyperlink mark.\n",
        "type": "VegaLite.Cursor -> VegaLite.MarkProperty"
      },
      {
        "name": "maDiscreteBandSize",
        "comment": " Discrete band size of a bar mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maDx",
        "comment": " Horizontal offset between a text mark and its anchor.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maDy",
        "comment": " Vertical offset between a text mark and its anchor.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maExtent",
        "comment": " Extent of whiskers used in a boxplot, error bars or error bands.\n",
        "type": "VegaLite.SummaryExtent -> VegaLite.MarkProperty"
      },
      {
        "name": "maFill",
        "comment": " Default fill color of a mark.\n",
        "type": "String -> VegaLite.MarkProperty"
      },
      {
        "name": "maFillOpacity",
        "comment": " Fill opacity of a mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maFilled",
        "comment": " Whether or not a mark's color should be used as the fill color instead of\nstroke color.\n",
        "type": "Bool -> VegaLite.MarkProperty"
      },
      {
        "name": "maFont",
        "comment": " Font of a text mark. Can be any font name made accessible via\na css file (or a generic font like `serif`, `monospace` etc.).\n",
        "type": "String -> VegaLite.MarkProperty"
      },
      {
        "name": "maFontSize",
        "comment": " Font size in pixels used by a text mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maFontStyle",
        "comment": " Font style (e.g. `italic`) used by a text mark.\n",
        "type": "String -> VegaLite.MarkProperty"
      },
      {
        "name": "maFontWeight",
        "comment": " Font wight used by a text mark.\n",
        "type": "VegaLite.FontWeight -> VegaLite.MarkProperty"
      },
      {
        "name": "maHRef",
        "comment": " Hyperlink to be associated with a mark making it a clickable hyperlink.\n",
        "type": "String -> VegaLite.MarkProperty"
      },
      {
        "name": "maInterpolate",
        "comment": " Interpolation method used by line and area marks.\n",
        "type": "VegaLite.MarkInterpolation -> VegaLite.MarkProperty"
      },
      {
        "name": "maLine",
        "comment": " Appearance of a line marker joining the vertices of an area mark.\n",
        "type": "VegaLite.LineMarker -> VegaLite.MarkProperty"
      },
      {
        "name": "maOpacity",
        "comment": " Overal opacity of a mark in the range 0 to 1.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maOrient",
        "comment": " Orientation of a non-stacked bar, tick, area or line mark.\n",
        "type": "VegaLite.MarkOrientation -> VegaLite.MarkProperty"
      },
      {
        "name": "maPoint",
        "comment": " Appearance of a point marker joining the vertices of a line or area mark.\n",
        "type": "VegaLite.PointMarker -> VegaLite.MarkProperty"
      },
      {
        "name": "maRadius",
        "comment": " Polar coordinate radial offset of a text mark from its origin.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maRule",
        "comment": " Rule (main line) properties for the errorbar mark.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.MarkProperty"
      },
      {
        "name": "maShape",
        "comment": " Shape of a point mark.\n",
        "type": "VegaLite.Symbol -> VegaLite.MarkProperty"
      },
      {
        "name": "maShortTimeLabels",
        "comment": " Whether or not month and weekday names are abbreviated in a text mark.\n",
        "type": "Bool -> VegaLite.MarkProperty"
      },
      {
        "name": "maSize",
        "comment": " Ssize of a mark in square units.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maStroke",
        "comment": " Default stroke color of a mark.\n",
        "type": "String -> VegaLite.MarkProperty"
      },
      {
        "name": "maStrokeCap",
        "comment": " Cap style of a mark's stroke.\n",
        "type": "VegaLite.StrokeCap -> VegaLite.MarkProperty"
      },
      {
        "name": "maStrokeDash",
        "comment": " Stroke dash style used by a mark. Determined by an alternating 'on-off'\nsequence of line lengths.\n",
        "type": "List Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maStrokeDashOffset",
        "comment": " Number of pixels before the first line dash is drawn.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maStrokeJoin",
        "comment": " Line segment join style of a mark's stroke.\n",
        "type": "VegaLite.StrokeJoin -> VegaLite.MarkProperty"
      },
      {
        "name": "maStrokeMiterLimit",
        "comment": " Miter limit at which to bevel a join between line segments of a mark's stroke.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maStrokeOpacity",
        "comment": " Stroke opacity of a mark in the range 0 to 1.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maStrokeWidth",
        "comment": " Stroke width of a mark in pixel units.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maStyle",
        "comment": " Names of custom styles to apply to a mark. Each should refer to a named style\ndefined in a separate style configuration.\n",
        "type": "List String -> VegaLite.MarkProperty"
      },
      {
        "name": "maTension",
        "comment": " Interpolation tension used when interpolating line and area marks.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maText",
        "comment": " Placeholder text for a text mark for when a text channel is not specified.\n",
        "type": "String -> VegaLite.MarkProperty"
      },
      {
        "name": "maTheta",
        "comment": " Polar coordinate angle (clockwise from north in radians) of a text mark from\nthe origin determined by its x and y properties.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maThickness",
        "comment": " Thickness of a tick mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maTicks",
        "comment": " Tick properties for the errorbar mark.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.MarkProperty"
      },
      {
        "name": "maTooltip",
        "comment": " Source of a mark's tooltip content.\n",
        "type": "VegaLite.TooltipContent -> VegaLite.MarkProperty"
      },
      {
        "name": "maX2Offset",
        "comment": " X2 position offset for a mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maXOffset",
        "comment": " X position offset for a mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maY2Offset",
        "comment": " Y2 position offset for a mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "maYOffset",
        "comment": " Y position offset for a mark.\n",
        "type": "Float -> VegaLite.MarkProperty"
      },
      {
        "name": "name",
        "comment": " Name to be associated with a visualization.\n",
        "type": "String -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "not",
        "comment": " Apply a negation Boolean operation as part of a logical composition. Boolean\noperations can be nested to any level.\n\n    not (and (expr \"datum.IMDB_Rating === null\") (expr \"datum.Rotten_Tomatoes_Rating === null\") )\n\n",
        "type": "VegaLite.BooleanOp -> VegaLite.BooleanOp"
      },
      {
        "name": "num",
        "comment": " A numeric data value.\n",
        "type": "Float -> VegaLite.DataValue"
      },
      {
        "name": "numRange",
        "comment": " Minimum-maximum number range to be used in data filtering.\n",
        "type": "Float -> Float -> VegaLite.FilterRange"
      },
      {
        "name": "nums",
        "comment": " List of numeric data values.\n",
        "type": "List Float -> VegaLite.DataValues"
      },
      {
        "name": "oAggregate",
        "comment": " Compute some aggregate summaray statistics for a field to be encoded with an\norder channel. The type of aggregation is determined by the given operation\nparameter.\n",
        "type": "VegaLite.Operation -> VegaLite.OrderChannel"
      },
      {
        "name": "oBin",
        "comment": " Discretize numeric values into bins when encoding with an order channel.\n",
        "type": "List VegaLite.BinProperty -> VegaLite.OrderChannel"
      },
      {
        "name": "oMType",
        "comment": " Level of measurement when encoding with an order channel.\n",
        "type": "VegaLite.Measurement -> VegaLite.OrderChannel"
      },
      {
        "name": "oName",
        "comment": " Name of the field used for encoding with an order channel.\n",
        "type": "String -> VegaLite.OrderChannel"
      },
      {
        "name": "oRepeat",
        "comment": " Reference in a order channel to a field name generated by `repeat`. The\nparameter identifies whether reference is being made to fields that are to be\nlaid out in columns or in rows.\n",
        "type": "VegaLite.Arrangement -> VegaLite.OrderChannel"
      },
      {
        "name": "oSort",
        "comment": " Sort order to be used by an order channel.\n",
        "type": "List VegaLite.SortProperty -> VegaLite.OrderChannel"
      },
      {
        "name": "oTimeUnit",
        "comment": " Time unit aggregation of field values when encoding with an order channel.\n",
        "type": "VegaLite.TimeUnit -> VegaLite.OrderChannel"
      },
      {
        "name": "opAs",
        "comment": " Aaggregation operation. The first parameter is the operation to use; the second\nthe name of the field in which to apply it and the third the name to be given to\nthis transformation.\n\n    trans =\n        transform\n            << aggregate\n                [ opAs Min \"people\" \"lowerBound\"\n                , opAs Max \"people\" \"upperBound\"\n                ]\n                [ \"age\" ]\n\nIf the operation is `Count`, it does not apply to any specific field, so the second\nparameter can be an empty string.\n\n",
        "type": "VegaLite.Operation -> String -> String -> VegaLite.Spec"
      },
      {
        "name": "opacity",
        "comment": " Encode an opacity channel.\n",
        "type": "List VegaLite.MarkChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "or",
        "comment": " Apply an 'or' Boolean operation as part of a logical composition.\n",
        "type": "VegaLite.BooleanOp -> VegaLite.BooleanOp -> VegaLite.BooleanOp"
      },
      {
        "name": "order",
        "comment": " Encode an order channel with a list of order field definitions.\n",
        "type": "List VegaLite.OrderChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "pAggregate",
        "comment": " Compute some aggregate summaray statistics for a field to be encoded with a\nposition channel. The type of aggregation is determined by the given operation\nparameter.\n",
        "type": "VegaLite.Operation -> VegaLite.PositionChannel"
      },
      {
        "name": "pAxis",
        "comment": " Axis properties used when encoding with a position channel. For no axis,\nprovide an empty list.\n",
        "type": "List VegaLite.AxisProperty -> VegaLite.PositionChannel"
      },
      {
        "name": "pBin",
        "comment": " Discretize numeric values into bins when encoding with a position channel.\n",
        "type": "List VegaLite.BinProperty -> VegaLite.PositionChannel"
      },
      {
        "name": "pBinned",
        "comment": " Indicate that data encoded with position are already binned.\n",
        "type": "VegaLite.PositionChannel"
      },
      {
        "name": "pHeight",
        "comment": " Set the position to the height of the enclosing data space. Useful for placing\na mark relative to the bottom edge of a view.\n",
        "type": "VegaLite.PositionChannel"
      },
      {
        "name": "pImpute",
        "comment": " Imputation rules for a position channel. See the\n[Vega-Lite impute documentation](https://vega.github.io/vega-lite/docs/impute.html)\n",
        "type": "List VegaLite.ImputeProperty -> VegaLite.PositionChannel"
      },
      {
        "name": "pMType",
        "comment": " Level of measurement when encoding with a position channel.\n",
        "type": "VegaLite.Measurement -> VegaLite.PositionChannel"
      },
      {
        "name": "pName",
        "comment": " Name of the field used for encoding with a position channel.\n",
        "type": "String -> VegaLite.PositionChannel"
      },
      {
        "name": "pRepeat",
        "comment": " Arrangement of views in a repeated composite view.\n",
        "type": "VegaLite.Arrangement -> VegaLite.PositionChannel"
      },
      {
        "name": "pScale",
        "comment": " Scaling applied to a field when encoding with a position channel.\nThe scale will transform a field's value into a position along one axis.\n",
        "type": "List VegaLite.ScaleProperty -> VegaLite.PositionChannel"
      },
      {
        "name": "pSort",
        "comment": " Sort order for field when encoding with a position channel.\n",
        "type": "List VegaLite.SortProperty -> VegaLite.PositionChannel"
      },
      {
        "name": "pStack",
        "comment": " Type of stacking offset for field when encoding with a position channel.\n",
        "type": "VegaLite.StackOffset -> VegaLite.PositionChannel"
      },
      {
        "name": "pTimeUnit",
        "comment": " Form of time unit aggregation of field values when encoding with a position channel.\n",
        "type": "VegaLite.TimeUnit -> VegaLite.PositionChannel"
      },
      {
        "name": "pTitle",
        "comment": " Title of a field when encoding with a position channel.\n",
        "type": "String -> VegaLite.PositionChannel"
      },
      {
        "name": "pWidth",
        "comment": " Set the position to the width of the enclosing data space. Useful for justifying\na mark to the right hand edge of a view. e.g. to position a mark at the right of\nthe data rectangle:\n\n    enc =\n        encoding\n            << position X [ pWidth ]\n\n",
        "type": "VegaLite.PositionChannel"
      },
      {
        "name": "paEdges",
        "comment": " Padding around a visualization in pixel units. The four parameters\nrefer to _left_, _top_, _right_, and _bottom_ edges respectively.\n",
        "type": "Float -> Float -> Float -> Float -> VegaLite.Padding"
      },
      {
        "name": "paSize",
        "comment": " Indicate uniform padding around a visualization in pixel units.\n",
        "type": "Float -> VegaLite.Padding"
      },
      {
        "name": "padding",
        "comment": " Padding around the visualization in pixel units. The way padding is interpreted\nwill depend on the `autosize` properties.\n",
        "type": "VegaLite.Padding -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "parse",
        "comment": " Parsing rules when processing some data text, specified as a list of tuples\nin the form (_fieldname_, _datatype_). If an empty list is provided, type inference\nis based on the data.\n",
        "type": "List ( String, VegaLite.DataType ) -> VegaLite.Format"
      },
      {
        "name": "pmMarker",
        "comment": " Properties of a point marker that is overlaid on a line or area mark.\n",
        "type": "List VegaLite.MarkProperty -> VegaLite.PointMarker"
      },
      {
        "name": "point",
        "comment": " [Point mark](https://vega.github.io/vega-lite/docs/point.html) for\nsymbolising a data point with a symbol.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "position",
        "comment": " Encode a position channel. The first parameter identifies the channel,\nthe second a list of encoding options.\n",
        "type": "VegaLite.Position -> List VegaLite.PositionChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "prCenter",
        "comment": " Projection’s center as longitude and latitude in degrees.\n",
        "type": "Float -> Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prClipAngle",
        "comment": " Projection’s clipping circle radius to the specified angle in degrees.\nA value of `Nothing` will switch to antimeridian cutting rather than small-circle\nclipping.\n",
        "type": "Maybe.Maybe Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prClipExtent",
        "comment": " Projection’s viewport clip extent to the specified bounds in pixels.\n",
        "type": "VegaLite.ClipRect -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prCoefficient",
        "comment": " 'Hammer' map projection coefficient.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prDistance",
        "comment": " 'Satellite' map projection distance.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prFraction",
        "comment": " `Bottomley` map projection fraction.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prLobes",
        "comment": " Number of lobes in lobed map projections such as the 'Berghaus star'.\n",
        "type": "Int -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prParallel",
        "comment": " Parallel for map projections such as the 'Armadillo'.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prPrecision",
        "comment": " Threshold for the projection’s adaptive resampling in pixels.\nCorresponds to the Douglas–Peucker distance. If precision is not specified, the\nprojection’s current resampling precision of 0.707 is used.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prRadius",
        "comment": " Radius value for map projections such as the 'Gingery'.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prRatio",
        "comment": " Ratio value for map projections such as the 'Hill'.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prRotate",
        "comment": " Projection’s three-axis rotation angle. This should be in order _lambda phi\ngamma_ specifying the rotation angles in degrees about each spherical axis.\n",
        "type": "Float -> Float -> Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prSpacing",
        "comment": " Spacing value for map projections such as the 'Lagrange'.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prTilt",
        "comment": " 'Satellite' map projection tilt.\n",
        "type": "Float -> VegaLite.ProjectionProperty"
      },
      {
        "name": "prType",
        "comment": " Type of global map projection.\n",
        "type": "VegaLite.Projection -> VegaLite.ProjectionProperty"
      },
      {
        "name": "projection",
        "comment": " Map projection used for geospatial coordinates.\n",
        "type": "List VegaLite.ProjectionProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "raName",
        "comment": " Name of a pre-defined scale range (e.g. `symbol` or `diverging`).\n",
        "type": "String -> VegaLite.ScaleRange"
      },
      {
        "name": "raNums",
        "comment": " Numeric scale range. Depending on the scaling this may be a [min, max]\npair, or a list of explicit numerical values.\n",
        "type": "List Float -> VegaLite.ScaleRange"
      },
      {
        "name": "raStrs",
        "comment": " Text scale range for discrete scales.\n",
        "type": "List String -> VegaLite.ScaleRange"
      },
      {
        "name": "racoCategory",
        "comment": " Default color scheme for categorical ranges.\n",
        "type": "String -> VegaLite.RangeConfig"
      },
      {
        "name": "racoDiverging",
        "comment": " Default diverging color scheme.\n",
        "type": "String -> VegaLite.RangeConfig"
      },
      {
        "name": "racoHeatmap",
        "comment": " Default 'heatmap' color scheme.\n",
        "type": "String -> VegaLite.RangeConfig"
      },
      {
        "name": "racoOrdinal",
        "comment": " Default ordinal color scheme.\n",
        "type": "String -> VegaLite.RangeConfig"
      },
      {
        "name": "racoRamp",
        "comment": " Default ramp (contnuous) color scheme.\n",
        "type": "String -> VegaLite.RangeConfig"
      },
      {
        "name": "racoSymbol",
        "comment": " Default color scheme symbols.\n",
        "type": "String -> VegaLite.RangeConfig"
      },
      {
        "name": "reAxis",
        "comment": " Indicate how a channel's axes should be resolved when defined in more than\none view in a composite visualization.\n",
        "type": "List ( VegaLite.Channel, VegaLite.Resolution ) -> VegaLite.Resolve"
      },
      {
        "name": "reLegend",
        "comment": " Indicate how a channel's legends should be resolved when defined in more\nthan one view in a composite visualization.\n",
        "type": "List ( VegaLite.Channel, VegaLite.Resolution ) -> VegaLite.Resolve"
      },
      {
        "name": "reScale",
        "comment": " Indicate how a channel's scales should be resolved when defined in more\nthan one view in a composite visualization.\n",
        "type": "List ( VegaLite.Channel, VegaLite.Resolution ) -> VegaLite.Resolve"
      },
      {
        "name": "rect",
        "comment": " [Rectangle mark](https://vega.github.io/vega-lite/docs/rect.html).\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "repeat",
        "comment": " Define the fields that will be used to compose rows and columns of a set of\nsmall multiples. Used when the encoding largely identical, but the data field used\nin each might vary. When a list of fields is identified with `repeat` you also\nneed to define a full specification to apply to each of those fields using `asSpec`.\n\n    spec = ...\n    toVegaLite\n        [ repeat [ columnFields [ \"Cat\", \"Dog\", \"Fish\" ] ]\n        , specification (asSpec spec)\n        ]\n\n",
        "type": "List VegaLite.RepeatFields -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "resolution",
        "comment": " Define a resolution option to be applied when scales, axes or legends in composite\nviews share channel encodings. This allows different color encodings to be created\nin a layered view, which would otherwise share color channels between layers. Each\nresolution rule should be in a tuple pairing the channel to which it applies and\nthe rule type. The first parameter identifies the type of resolution.\n\n    resolve\n        << resolution (reScale [ ( ChY, Independent ) ])\n\n",
        "type": "VegaLite.Resolve -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "resolve",
        "comment": " Determine whether scales, axes or legends in composite views should share channel\nencodings.\n",
        "type": "List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "rgb",
        "comment": " RGB color interpolation for continuous color scales using the given gamma\nvalue (anchored at 1).\n",
        "type": "Float -> VegaLite.CInterpolate"
      },
      {
        "name": "row",
        "comment": " Encode a new facet to be arranged in rows. The first parameter is a list of\nfacet properties that define the faceting channel.\n",
        "type": "List VegaLite.FacetChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "rowBy",
        "comment": " Tthe mapping between a row and its field definitions in a set of faceted\nsmall multiples.\n",
        "type": "List VegaLite.FacetChannel -> VegaLite.FacetMapping"
      },
      {
        "name": "rowFields",
        "comment": " Create a list of fields to use in set of repeated small multiples arranged in\nrows. The list of fields named here can be referenced in an encoding with\n`pRepeat Row`, `mRepeat Row` etc.\n",
        "type": "List String -> VegaLite.RepeatFields"
      },
      {
        "name": "rule",
        "comment": " [Rule line](https://vega.github.io/vega-lite/docs/rule.html) connecting\ntwo vertices.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "sacoBandPaddingInner",
        "comment": " Default inner padding for x and y band-ordinal scales.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoBandPaddingOuter",
        "comment": " Default outer padding for x and y band-ordinal scales.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoClamp",
        "comment": " Whether or not by default values that exceed the data domain are clamped to\nthe min/max range value.\n",
        "type": "Bool -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMaxBandSize",
        "comment": " Default maximum value for mapping quantitative fields to a bar's\nsize/bandSize.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMaxFontSize",
        "comment": " Default maximum value for mapping a quantitative field to a text\nmark's size.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMaxOpacity",
        "comment": " Default maximum opacity (in the range [0, 1]) for mapping a field\nto opacity.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMaxSize",
        "comment": " Default maximum size for point-based scales.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMaxStrokeWidth",
        "comment": " Default maximum stroke width for rule, line and trail marks.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMinBandSize",
        "comment": " Default minimum value for mapping quantitative fields to a bar's size/bandSize.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMinFontSize",
        "comment": " Default minimum value for mapping a quantitative field to a text mark's size.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMinOpacity",
        "comment": " Default minimum opacity (0 to 1) for mapping a field to opacity.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMinSize",
        "comment": " Default minimum size for point-based scales (when not forced to start at zero).\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoMinStrokeWidth",
        "comment": " Default minimum stroke width for rule, line and trail marks.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoPointPadding",
        "comment": " Default padding for point-ordinal scales.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoRangeStep",
        "comment": " Default range step for band and point scales when the mark is not text.\n",
        "type": "Maybe.Maybe Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoRound",
        "comment": " Whether or not numeric values are rounded to integers when scaling. Useful\nfor snapping to the pixel grid.\n",
        "type": "Bool -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoTextXRangeStep",
        "comment": " Default range step for x band and point scales of text marks.\n",
        "type": "Float -> VegaLite.ScaleConfig"
      },
      {
        "name": "sacoUseUnaggregatedDomain",
        "comment": " Whether or not to use the source data range before aggregation.\n",
        "type": "Bool -> VegaLite.ScaleConfig"
      },
      {
        "name": "sample",
        "comment": " Randomly sample rows from a data source up to a given maximum.\n",
        "type": "Float -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "scClamp",
        "comment": " Whether or not values outside the data domain are clamped to the minimum or\nmaximum value.\n",
        "type": "Bool -> VegaLite.ScaleProperty"
      },
      {
        "name": "scDomain",
        "comment": " Custom scaling domain.\n",
        "type": "VegaLite.ScaleDomain -> VegaLite.ScaleProperty"
      },
      {
        "name": "scInterpolate",
        "comment": " Interpolation method for scaling range values.\n",
        "type": "VegaLite.CInterpolate -> VegaLite.ScaleProperty"
      },
      {
        "name": "scNice",
        "comment": " 'Nice' minimum and maximum values in a scaling (e.g. multiples of 10).\n",
        "type": "VegaLite.ScaleNice -> VegaLite.ScaleProperty"
      },
      {
        "name": "scNiceInterval",
        "comment": " 'Nice' temporal interval values when scaling.\n",
        "type": "VegaLite.TimeUnit -> Int -> VegaLite.ScaleNice"
      },
      {
        "name": "scNiceTickCount",
        "comment": " Desired number of tick marks in a 'nice' scaling.\n",
        "type": "Int -> VegaLite.ScaleNice"
      },
      {
        "name": "scPadding",
        "comment": " Padding in pixels to apply to a scaling.\n",
        "type": "Float -> VegaLite.ScaleProperty"
      },
      {
        "name": "scPaddingInner",
        "comment": " Inner padding to apply to a band scaling.\n",
        "type": "Float -> VegaLite.ScaleProperty"
      },
      {
        "name": "scPaddingOuter",
        "comment": " Outer padding to apply to a band scaling.\n",
        "type": "Float -> VegaLite.ScaleProperty"
      },
      {
        "name": "scRange",
        "comment": " Range of a scaling. The type of range depends on the encoding channel.\n",
        "type": "VegaLite.ScaleRange -> VegaLite.ScaleProperty"
      },
      {
        "name": "scRangeStep",
        "comment": " Distance between the starts of adjacent bands in a band scaling. If\n`Nothing` is provided the distance is determined automatically.\n",
        "type": "Maybe.Maybe Float -> VegaLite.ScaleProperty"
      },
      {
        "name": "scReverse",
        "comment": " Reverse the order of a scaling.\n",
        "type": "Bool -> VegaLite.ScaleProperty"
      },
      {
        "name": "scRound",
        "comment": " Whether or not numeric values in a scaling are rounded to integers.\n",
        "type": "Bool -> VegaLite.ScaleProperty"
      },
      {
        "name": "scScheme",
        "comment": " Color scheme used by a color scaling. The first parameter is the name of the\nscheme (e.g. \"viridis\") and the second an optional specifiction of the number of\ncolors to use (list of one number), or the extent of the color range to use (list\nof two numbers between 0 and 1).\n",
        "type": "String -> List Float -> VegaLite.ScaleProperty"
      },
      {
        "name": "scType",
        "comment": " Type of scaling to apply.\n",
        "type": "VegaLite.Scale -> VegaLite.ScaleProperty"
      },
      {
        "name": "scZero",
        "comment": " Whether or not a numeric scaling should be forced to include a zero value.\n",
        "type": "Bool -> VegaLite.ScaleProperty"
      },
      {
        "name": "seBind",
        "comment": " Binding to some input elements as part of a named selection.\n",
        "type": "List VegaLite.Binding -> VegaLite.SelectionProperty"
      },
      {
        "name": "seEncodings",
        "comment": " Encoding channels that form a named selection.\n",
        "type": "List VegaLite.Channel -> VegaLite.SelectionProperty"
      },
      {
        "name": "seFields",
        "comment": " Field names for projecting a selection.\n",
        "type": "List String -> VegaLite.SelectionProperty"
      },
      {
        "name": "seNearest",
        "comment": " Whether or not a selection should capture nearest marks to a pointer\nrather than an exact position match.\n",
        "type": "Bool -> VegaLite.SelectionProperty"
      },
      {
        "name": "seOn",
        "comment": " [Vega event stream](https://vega.github.io/vega/docs/event-streams)\nthat triggers a selection.\n",
        "type": "String -> VegaLite.SelectionProperty"
      },
      {
        "name": "seResolve",
        "comment": " Strategy that determines how selections’ data queries are resolved when applied\nin a filter transform, conditional encoding rule, or scale domain.\n",
        "type": "VegaLite.SelectionResolution -> VegaLite.SelectionProperty"
      },
      {
        "name": "seSelectionMark",
        "comment": " Appearance of an interval selection mark (dragged rectangle).\n",
        "type": "List VegaLite.SelectionMarkProperty -> VegaLite.SelectionProperty"
      },
      {
        "name": "seToggle",
        "comment": " Predicate expression that determines a toggled selection. See the\n[Vega-Lite toggle documentation](https://vega.github.io/vega-lite/docs/toggle.html)\n",
        "type": "String -> VegaLite.SelectionProperty"
      },
      {
        "name": "seTranslate",
        "comment": " Translation selection transformation used for panning a view. See the\n[Vega-Lite translate documentation](https://vega.github.io/vega-lite/docs/translate.html)\n",
        "type": "String -> VegaLite.SelectionProperty"
      },
      {
        "name": "seZoom",
        "comment": " Zooming selection transformation used for zooming a view. See the\n[Vega-Lite zoom documentation](https://vega.github.io/vega-lite/docs/zoom.html)\n",
        "type": "String -> VegaLite.SelectionProperty"
      },
      {
        "name": "select",
        "comment": " Create a single named selection that may be applied to a data query or transformation.\nThe first two parameters specify the name to be given to the selection for later\nreference and the type of selection made. The third allows additional selection options to\nbe specified.\n",
        "type": "String -> VegaLite.Selection -> List VegaLite.SelectionProperty -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "selected",
        "comment": " Interactive selection that will be true or false as part of a logical composition.\ne.g., to filter a dataset so that only items selected interactively and that have\na weight of more than 30:\n\n    transform\n        << filter (fCompose (and (selected \"brush\") (expr \"datum.weight > 30\")))\n\n",
        "type": "String -> VegaLite.BooleanOp"
      },
      {
        "name": "selection",
        "comment": " Create a full selection specification from a list of selections.\n\n    sel =\n        selection\n            << select \"view\" Interval [ BindScales ] []\n            << select \"myBrush\" Interval []\n            << select \"myPaintbrush\" Multi [ On \"mouseover\", Nearest True ]\n\n",
        "type": "List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "selectionName",
        "comment": " Name a selection that is used as part of a conditional encoding.\n\n    color\n        [ mSelectionCondition ( selectionName \"myBrush\" )\n            [ mName \"myField\", mMType Nominal ]\n            [ mStr \"grey\" ]\n        ]\n\n",
        "type": "String -> VegaLite.BooleanOp"
      },
      {
        "name": "shape",
        "comment": " Encode a shape channel.\n",
        "type": "List VegaLite.MarkChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "size",
        "comment": " Encode a size channel with a list of mark channel properties.\n",
        "type": "List VegaLite.MarkChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "smFill",
        "comment": " Fill color of an interval selection mark (dragged rectangular area).\n",
        "type": "String -> VegaLite.SelectionMarkProperty"
      },
      {
        "name": "smFillOpacity",
        "comment": " Fill opacity of an interval selection mark in the range 0 to 1.\n",
        "type": "Float -> VegaLite.SelectionMarkProperty"
      },
      {
        "name": "smStroke",
        "comment": " Sroke color of the interval selection mark.\n",
        "type": "String -> VegaLite.SelectionMarkProperty"
      },
      {
        "name": "smStrokeDash",
        "comment": " Stroke dash style of the interval selection mark.\n",
        "type": "List Float -> VegaLite.SelectionMarkProperty"
      },
      {
        "name": "smStrokeDashOffset",
        "comment": " Stroke dash offset of the interval selection mark.\n",
        "type": "Float -> VegaLite.SelectionMarkProperty"
      },
      {
        "name": "smStrokeOpacity",
        "comment": " Stroke opacity of the interval selection mark in the range 0 to 1.\n",
        "type": "Float -> VegaLite.SelectionMarkProperty"
      },
      {
        "name": "smStrokeWidth",
        "comment": " Stroke width of the interval selection mark.\n",
        "type": "Float -> VegaLite.SelectionMarkProperty"
      },
      {
        "name": "soByField",
        "comment": " Sort by the aggregated summary of a given field using a given aggregation\noperation. e.g., sort the categorical data field `variety` by the mean age of\nthe data in each variety category:\n\n    position Y [ pName \"variety\"\n               , pMType Ordinal\n               , pSort [ soByField \"age\" Mean, Descending ]\n               ]\n\n",
        "type": "String -> VegaLite.Operation -> VegaLite.SortProperty"
      },
      {
        "name": "soByRepeat",
        "comment": " Sort by the aggregated summaries of the given fields (referenced by a repeat\niteration) using a given aggregation operation.\n",
        "type": "VegaLite.Arrangement -> VegaLite.Operation -> VegaLite.SortProperty"
      },
      {
        "name": "soCustom",
        "comment": " Custom sort order listing data values explicitly.\n",
        "type": "VegaLite.DataValues -> VegaLite.SortProperty"
      },
      {
        "name": "spacing",
        "comment": " Spacing between sub-views in a composition operator.\n",
        "type": "Float -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "spacingRC",
        "comment": " Similar to [spacing](#spacing) but with independent spacing for rows (first\nparameter) and columns (second parameter).\n",
        "type": "Float -> Float -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "specification",
        "comment": " Define a specification object for use with faceted and repeated small multiples.\n\n    spec = ...\n    toVegaLite\n        [ facet [ rowBy [ fName \"Origin\", fMType Nominal ] ]\n        , specifcation spec\n        ]\n\n",
        "type": "VegaLite.Spec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "square",
        "comment": " [Square mark](https://vega.github.io/vega-lite/docs/square.html) for symbolising\npoints.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "stAscending",
        "comment": " Indicate that the given field should be sorted in ascending order.\n",
        "type": "String -> VegaLite.SortField"
      },
      {
        "name": "stDescending",
        "comment": " Indicate that the given field should be sorted in descending order.\n",
        "type": "String -> VegaLite.SortField"
      },
      {
        "name": "stOffset",
        "comment": " Stack offset when applying a stack transformation.\n",
        "type": "VegaLite.StackOffset -> VegaLite.StackProperty"
      },
      {
        "name": "stSort",
        "comment": " Ordering within a stack when applying a stack transformation.\n",
        "type": "List VegaLite.SortField -> VegaLite.StackProperty"
      },
      {
        "name": "stack",
        "comment": " Apply a stack transform for positioning multiple values. This is an alternative\nto specifying stacking directly when encoding position. First parameter is the field\nto be stacked; the second the fields to group by; the third and fourth are the names\nto give the output field names; the fifth lists the optional offset and sort properties.\n",
        "type": "String -> List String -> String -> String -> List VegaLite.StackProperty -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "str",
        "comment": " A string data value.\n",
        "type": "String -> VegaLite.DataValue"
      },
      {
        "name": "stroke",
        "comment": " Encode a stroke channel. This acts in a similar way to encoding by `color` but\nonly affects the exterior boundary of marks.\n",
        "type": "List VegaLite.MarkChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "strs",
        "comment": " A list of string data values.\n",
        "type": "List String -> VegaLite.DataValues"
      },
      {
        "name": "symbolPath",
        "comment": " A custom symbol shape as an\n[SVG path description](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).\n",
        "type": "String -> VegaLite.Symbol"
      },
      {
        "name": "tAggregate",
        "comment": " Compute some aggregate summaray statistics for a field to be encoded with a\ntext channel. The type of aggregation is determined by the given operation\nparameter.\n",
        "type": "VegaLite.Operation -> VegaLite.TextChannel"
      },
      {
        "name": "tBin",
        "comment": " Discretize numeric values into bins when encoding with a text channel.\n",
        "type": "List VegaLite.BinProperty -> VegaLite.TextChannel"
      },
      {
        "name": "tBinned",
        "comment": " Indicate that data encoded with a text channel are already binned.\n",
        "type": "VegaLite.TextChannel"
      },
      {
        "name": "tDataCondition",
        "comment": " Make a text channel conditional on one or more predicate expressions. The first\nparameter is a list of tuples each pairing an expression to evaluate with the encoding\nif that expression is true. The second is the encoding if none of the expressions\nare evaluated as true.\n",
        "type": "List ( VegaLite.BooleanOp, List VegaLite.TextChannel ) -> List VegaLite.TextChannel -> VegaLite.TextChannel"
      },
      {
        "name": "tFormat",
        "comment": " [Formatting pattern](https://vega.github.io/vega-lite/docs/format.html)\nfor a field when encoding with a text channel.\n",
        "type": "String -> VegaLite.TextChannel"
      },
      {
        "name": "tMType",
        "comment": " Level of measurement when encoding with a text channel.\n",
        "type": "VegaLite.Measurement -> VegaLite.TextChannel"
      },
      {
        "name": "tName",
        "comment": " Name of the field used for encoding with a text channel.\n",
        "type": "String -> VegaLite.TextChannel"
      },
      {
        "name": "tRepeat",
        "comment": " Reference in a text channel to a field name generated by `repeat`. The\nparameter identifies whether reference is being made to fields that are to be\nlaid out in columns or in rows.\n",
        "type": "VegaLite.Arrangement -> VegaLite.TextChannel"
      },
      {
        "name": "tSelectionCondition",
        "comment": " Make a text channel conditional on interactive selection. The first parameter\nis a selection condition to evaluate; the second the encoding to apply if that\nselection is true; the third parameter is the encoding if the selection is false.\n",
        "type": "VegaLite.BooleanOp -> List VegaLite.TextChannel -> List VegaLite.TextChannel -> VegaLite.TextChannel"
      },
      {
        "name": "tTimeUnit",
        "comment": " Time unit aggregation of field values when encoding with a text channel.\n",
        "type": "VegaLite.TimeUnit -> VegaLite.TextChannel"
      },
      {
        "name": "tTitle",
        "comment": " Title of a field when encoding with a text or tooltip channel.\n",
        "type": "String -> VegaLite.TextChannel"
      },
      {
        "name": "text",
        "comment": " Encode a text channel.\n",
        "type": "List VegaLite.TextChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "textMark",
        "comment": " [Text mark](https://vega.github.io/vega-lite/docs/text.html) to be\ndisplayed at some point location.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "tick",
        "comment": " Short line ([tick](https://vega.github.io/vega-lite/docs/tick.html))\nmark for symbolising point locations.\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "ticoAnchor",
        "comment": " Default anchor position when placing titles.\n",
        "type": "VegaLite.APosition -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoAngle",
        "comment": " Default angle when orientating titles.\n",
        "type": "Float -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoBaseline",
        "comment": " Default vertical alignment when placing titles.\n",
        "type": "VegaLite.VAlign -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoColor",
        "comment": " Default color when showing titles.\n",
        "type": "String -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoFont",
        "comment": " Default font when showing titles.\n",
        "type": "String -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoFontSize",
        "comment": " Default font size when showing titles.\n",
        "type": "Float -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoFontWeight",
        "comment": " Default font weight when showing titles.\n",
        "type": "VegaLite.FontWeight -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoLimit",
        "comment": " Default maximim length in pixel units when showing titles.\n",
        "type": "Float -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoOffset",
        "comment": " Default offset in pixel units of titles relative to the chart body.\n",
        "type": "Float -> VegaLite.TitleConfig"
      },
      {
        "name": "ticoOrient",
        "comment": " Default placement of titles relative to the chart body.\n",
        "type": "VegaLite.Side -> VegaLite.TitleConfig"
      },
      {
        "name": "timeUnitAs",
        "comment": " Create a new data field based on the given temporal binning. Unlike the\ndirect encoding binning, this transformation is named and so can be referred\nto in multiple encodings. The first parameter is the width of each temporal bin,\nthe second is the field to bin and the third is name to give the newly binned\nfield.\n",
        "type": "VegaLite.TimeUnit -> String -> String -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "title",
        "comment": " Title to be displayed in the visualization.\n",
        "type": "String -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "toVegaLite",
        "comment": " Convert a list of Vega-Lite specifications into a single JSON object that may be\npassed to Vega-Lite for graphics generation. Commonly these will include at least\ndata, mark and encoding specifications.\n\nWhile simple functions like `bar` may be provided directly, it is usually clearer\nto label more complex ones such as encodings as separate expressions.\n\nSpecifications can be built up by chaining functions such as `dataColumn` or\n`position`. Functional composition using the `<<` operator allows this to be done\ncompactly.\n\n    let\n        data =\n            dataFromColumns []\n                << dataColumn \"a\" (strs [ \"C\", \"C\", \"D\", \"E\" ])\n                << dataColumn \"b\" (nums [ 2, 7, 1, 2 ])\n\n        enc =\n            encoding\n                << position X [ pName \"a\", pMType Nominal ]\n                << position Y [ pName \"b\", pMType Quantitative, pAggregate Mean ]\n    in\n    toVegaLite [ data [], bar [], enc [] ]\n\n",
        "type": "List ( VegaLite.VLProperty, VegaLite.Spec ) -> VegaLite.Spec"
      },
      {
        "name": "tooltip",
        "comment": " Encode a tooltip channel. To encode multiple tooltip values with a mark, use\n[tooltips](#tooltips).\n",
        "type": "List VegaLite.TextChannel -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "tooltips",
        "comment": " Encode a tooltip channel with multiple tooltips. The first parameter is a\nlist of the multiple tooltips, each of which is a list of text channel properties\nthat define the channel.\n",
        "type": "List (List VegaLite.TextChannel) -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      },
      {
        "name": "topojsonFeature",
        "comment": " A topoJSON feature format containing an object with the given name.\n",
        "type": "String -> VegaLite.Format"
      },
      {
        "name": "topojsonMesh",
        "comment": " A topoJSON mesh format containing an object with the given name. Unlike\n`topojsonFeature`, the corresponding geo data are returned as a single unified mesh,\nnot as individual GeoJSON features.\n",
        "type": "String -> VegaLite.Format"
      },
      {
        "name": "trail",
        "comment": " [Trail mark](https://vega.github.io/vega-lite/docs/trail.html) (line\nwith variable width along its length).\n",
        "type": "List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "transform",
        "comment": " Create a single transform from a list of transformation specifications. The\norder of transformations can be important, e.g. labels created with [calculateAs](#calculateas),\n[timeUnitAs](#timeUnitAs) and [binAs](#binAs) that are used in other transformations.\nUsing the functional composition pipeline idiom (as example below) allows you to\nprovide the transformations in the order intended in a clear manner.\n\n    trans =\n        transform\n            << filter (fiExpr \"datum.year == 2010\")\n            << calculateAs \"datum.sex == 2 ? 'Female' : 'Male'\" \"gender\"\n\n",
        "type": "List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "true",
        "comment": " A true value used for functions that can accept a Boolean literal or a reference\nto something that generates a Boolean value. Convenience function equivalent to `boo True`\n",
        "type": "VegaLite.DataValue"
      },
      {
        "name": "utc",
        "comment": " UTC version of a given a time (coordinated universal time, independent of local\ntime zones or daylight saving).\n",
        "type": "VegaLite.TimeUnit -> VegaLite.TimeUnit"
      },
      {
        "name": "vConcat",
        "comment": " Specifications to be juxtaposed vertically in a visualization.\n",
        "type": "List VegaLite.Spec -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "vicoClip",
        "comment": " Whether or not by default single views should be clipped.\n",
        "type": "Bool -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoFill",
        "comment": " Default fill color for single views.\n",
        "type": "Maybe.Maybe String -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoFillOpacity",
        "comment": " Default fill opacity for single views.\n",
        "type": "Float -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoHeight",
        "comment": " Default height of single views (e.g. each view in a trellis plot).\n",
        "type": "Float -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoStroke",
        "comment": " Default stroke color for single views. If `Nothing` is provided,\nno strokes are drawn around the view.\n",
        "type": "Maybe.Maybe String -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoStrokeDash",
        "comment": " Default stroke dash style for single views.\n",
        "type": "List Float -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoStrokeDashOffset",
        "comment": " Default stroke dash offset for single views.\n",
        "type": "Float -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoStrokeOpacity",
        "comment": " Default stroke opacity for single views.\n",
        "type": "Float -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoStrokeWidth",
        "comment": " Default stroke width of single views.\n",
        "type": "Float -> VegaLite.ViewConfig"
      },
      {
        "name": "vicoWidth",
        "comment": " Default width of single views (e.g. each view in a trellis plot).\n",
        "type": "Float -> VegaLite.ViewConfig"
      },
      {
        "name": "wiAggregateOp",
        "comment": " An aggregrate operation to be used in a window transformation.\n",
        "type": "VegaLite.Operation -> VegaLite.Window"
      },
      {
        "name": "wiAscending",
        "comment": " Indicate that the given field should be sorted in ascending order when performing\na window transform.\n",
        "type": "String -> VegaLite.SortField"
      },
      {
        "name": "wiDescending",
        "comment": " Indicate that the given field should be sorted in descending order when performing\na window transform.\n",
        "type": "String -> VegaLite.SortField"
      },
      {
        "name": "wiField",
        "comment": " Field for which to compute a window operation. Not needed for\noperations that do not apply to fields such as `Count`, `Rank` and `DenseRank`.\n",
        "type": "String -> VegaLite.Window"
      },
      {
        "name": "wiFrame",
        "comment": " Moving window for use by a window transform. The two parameters\nshould either be `Just` a number indicating the offset from the current data object,\nor `Nothing` to indicate unbounded rows preceding or following the current data object.\n",
        "type": "Maybe.Maybe Int -> Maybe.Maybe Int -> VegaLite.WindowProperty"
      },
      {
        "name": "wiGroupBy",
        "comment": " Fields for partioning data objects in a window transform into separate windows.\nIf unspecified, all points will be in a single group.\n",
        "type": "List String -> VegaLite.WindowProperty"
      },
      {
        "name": "wiIgnorePeers",
        "comment": " Whether or not the sliding window frame in a window transform should ignore\npeer values (those considered identical by the sort criteria).\n",
        "type": "Bool -> VegaLite.WindowProperty"
      },
      {
        "name": "wiOp",
        "comment": " Window-specific operation to be used in a window transformation.\n",
        "type": "VegaLite.WindowOperation -> VegaLite.Window"
      },
      {
        "name": "wiParam",
        "comment": " Numeric parameter for window-only operations that can be parameterised\n(`Ntile`, `Lag`, `Lead` and `NthValue`).\n",
        "type": "Int -> VegaLite.Window"
      },
      {
        "name": "wiSort",
        "comment": " Comparator for sorting data objects within a window transform.\n",
        "type": "List VegaLite.SortField -> VegaLite.WindowProperty"
      },
      {
        "name": "width",
        "comment": " Override the default width of the visualization. If not specified the width\nwill be calculated based on the content of the visualization.\n",
        "type": "Float -> ( VegaLite.VLProperty, VegaLite.Spec )"
      },
      {
        "name": "window",
        "comment": " Wwindow transform for performing calculations over sorted groups of\ndata objects such as ranking, lead/lag analysis, running sums and averages.\n\nThe first parameter is a list of tuples each comprising a window transform field\ndefinition and an output name. The second is the window transform definition.\n\n       trans =\n           transform\n               << window [ ( [ wiAggregateOp Sum, wiField \"Time\" ], \"TotalTime\" ) ]\n                   [ wiFrame Nothing Nothing ]\n\n",
        "type": "List ( List VegaLite.Window, String ) -> List VegaLite.WindowProperty -> List VegaLite.LabelledSpec -> List VegaLite.LabelledSpec"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  }
]