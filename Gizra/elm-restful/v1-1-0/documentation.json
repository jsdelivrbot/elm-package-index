[
  {
    "name": "Restful.Login",
    "comment": " This module models the state associated with the login process,\nbut not the UI -- the idea is that the UI will vary more than the basic logic\nof logging in does.\n\nOf course, this model will probably be supplied as a parameter to functions\nthat manipulate the UI, and those functions will probably return messages that\ncan be handled here.\n\n\n## Types\n\n@docs LoginStatus, Credentials, Login, LoginProgress, LoginError\n\n\n## Initialization\n\n@docs loggedOut, checkCachedCredentials\n\n\n## Actions\n\n@docs tryLogin, logout, accessTokenRejected, accessTokenAccepted\n\n\n## Integration with your app\n\n@docs Config, AppConfig, drupalConfig, Msg, update\n\n\n## Accessing the data associated with the login\n\n@docs maybeData, mapData, hasAccessToken, hasValidAccessToken, getError, isProgressing\n\n",
    "aliases": [
      {
        "name": "AppConfig",
        "comment": " The parts of `Config` that tend to vary from one app to the next.\n",
        "args": [
          "user",
          "data",
          "msg"
        ],
        "type": "{ decodeUser : Json.Decode.Decoder user , encodeUser : user -> Json.Encode.Value , initialData : user -> data , cacheCredentials : Restful.Endpoint.BackendUrl -> String -> Platform.Cmd.Cmd msg , tag : Restful.Login.Msg user -> msg }"
      },
      {
        "name": "Config",
        "comment": " Some static configuration which we need to integrate with your app.\nYou should be able to define this once, as a constant, and then use it\nwhere needed.\n\n  - user\n\n    The type you use for your user.\n\n  - data\n\n    The type of data that is only for users ... that is, which you'd like\n    to throw away upon logout.\n\n  - msg\n\n    Your Msg type.\n\n  - loginPath\n\n    Relative to a backendUrl, what's the path to the endpoint for getting an\n    access token? e.g. \"api/login-token\"\n\n  - logoutPath\n\n    Relative to a backendUrl, what's the path we can send a GET to in order\n    to logout? E.g. to destroy a session cookie, if it's HTTP only, so we can't\n    destroy it from Javascript.\n\n  - userPath\n\n    Once we have an access token, what's the path to the endpoint from which we\n    can request information about the current user?\n\n  - decodeAccessToken\n\n    A decoder for an access token, given the response from the loginPath\n\n  - decodeUser\n\n    A decoder for the `user` type, as send from userPath.\n\n  - encodeUser\n\n    A function that will produce JSON that `decodeUser` can decode.\n\n  - initialData\n\n    Given the newly logged-in user, what initial data should we store for that\n    user?\n\n  - cacheCredentials\n\n    A function which, when given a backendURL and a JSON string, will return a\n    command that caches that string. Exactly how you do that is up to you ... it\n    will probably be via ports.\n\n    We provide the backendUrl in case you want to store the credentials for multiple\n    backends and pick amongst them when needed. But you can ignore it if you like ...\n    the important part for us is the JSON string.\n\n    However you store the JSON string, you can provide it to `checkCachedCredentials`\n    and we'll use it.\n\n  - tag\n\n    What tag do you use in your `Msg` type to wrap our `Msg` type? This allows\n    our `update` function to work in the context of your `Msg` type ... in\n    effect, we'll do the mapping, rather than making you do it.\n\n",
        "args": [
          "user",
          "data",
          "msg"
        ],
        "type": "{ loginPath : String , logoutPath : Maybe.Maybe String , userPath : String , decodeAccessToken : Json.Decode.Decoder Restful.Endpoint.AccessToken , decodeUser : Json.Decode.Decoder user , encodeUser : user -> Json.Encode.Value , initialData : user -> data , cacheCredentials : Restful.Endpoint.BackendUrl -> String -> Platform.Cmd.Cmd msg , tag : Restful.Login.Msg user -> msg }"
      },
      {
        "name": "Credentials",
        "comment": " What a successful login ultimately results in is:\n\n-- an access token\n-- which is valid for a particular backend URL\n-- and some information about the logged-in user\n\nWe parameterize the user information, since it will vary from app to app.\n\nYou'll have to supply the backendUrl, of course, but it's handy to group it\nhere with the credentials, since you'll often want to supply the backend URL\nand access token together as a parameter. And, this accessToken is valid for\nthis backendUrl.\n\n",
        "args": [
          "user"
        ],
        "type": "{ accessToken : Restful.Endpoint.AccessToken , backendUrl : Restful.Endpoint.BackendUrl , user : user }"
      },
      {
        "name": "Login",
        "comment": " Represents the data we have if we're logged in.\n\n  - credentials\n\n    What credentials did we log in with?\n\n  - logout\n\n    Tracks a request-in-progress to logout. In some cases, we need to contact\n    the server in order to logout, because it maintains an HTTP-only session\n    cookie which we can only delete via an HTTP request.\n\n  - relogin\n\n    Do we need to re-login? If our credentials are rejected, we don't\n    transition back to `Anonymous` immediately, since that would prematurely\n    throw away some information that we may want to keep. Instead, we mark that\n    relogin is `Just LoginRequired`. We can then track the relogin process\n    without disturbing the other data.\n\n    Note that we shouldn't switch relogin to `Just` if there some kind of\n    transient network error ... only if our access token is definitely\n    rejected because it is permanently invalid.\n\n  - data\n\n    The app-specific data that only pertains to logged-in users, which we should\n    throw away when the user logs out.\n\n",
        "args": [
          "user",
          "data"
        ],
        "type": "{ credentials : Restful.Login.Credentials user , logout : RemoteData.WebData () , relogin : Maybe.Maybe Restful.Login.LoginProgress , data : data }"
      }
    ],
    "types": [
      {
        "name": "LoginError",
        "comment": " Represents an error which occured while trying to login.\n\n  - PasswordRejected\n\n    We successfully contacted the server, and it indicated that our username/password\n    combination was rejected.\n\n  - AccessTokenRejected\n\n    We successfully contacted the server, but it rejected our access token.\n\n  - Timeout\n\n    The login request timed out.\n\n  - NetworkError\n\n    There was some other kind of network error.\n\n  - InternalError\n\n    Some other kind of problem occurred, which probably represents a bug in the logic\n    of the app or the backend. We include the original `Http.Error` for further\n    diagnosis.\n\n",
        "args": [],
        "cases": [
          [
            "AccessTokenRejected",
            []
          ],
          [
            "InternalError",
            [
              "Http.Error"
            ]
          ],
          [
            "NetworkError",
            []
          ],
          [
            "PasswordRejected",
            []
          ],
          [
            "Timeout",
            []
          ]
        ]
      },
      {
        "name": "LoginProgress",
        "comment": " If we have no credentials, are we currently doing anything to get them?\n\n  - LoginRequired\n\n    Nothing is in progress ... if the user wants to login, they'll need\n    to enter a password.\n\n  - TryingPassword\n\n    We've sent a request to the backend with a password, and are waiting to\n    see if it succeeds.\n\n  - FailedPassword\n\n    We sent a request to the backend with a password, and it failed wih the\n    specified error. Note that the error may or may not mean that the password\n    is bad ... for instance, it might be a transient network error. So, you'll\n    need to interpret the error.\n\n  - FailedAccessToken\n\n    We sent a request to the backend with an access token, and it failed with\n    the specified error.\n\n",
        "args": [],
        "cases": [
          [
            "LoginFailed",
            [
              "Restful.Login.LoginError"
            ]
          ],
          [
            "LoginRequired",
            []
          ],
          [
            "TryingPassword",
            []
          ]
        ]
      },
      {
        "name": "LoginStatus",
        "comment": " Models the state of the login process, from beginning to end.\n\n  - `user` is the type we use to model information about the user\n    (e.g. name etc.). If we have a cached access token, we check whether\n    it's still valid by making a request for user data.\n\n  - `data` is a type for data that we only keep for logged-in users. It\n    facilitates forgetting that data when we logout ... it's baked into the type.\n    If you don't want to bother with that, you can use a Tuple0 here.\n\n  - CheckingCachedCredentials\n\n    We might have some cached credentials, and we're currently trying to\n    validate them against the backend.\n\n      - If we don't have any cached credentials, we'll transition to `Anonymous`\n\n      - If we have cached credentials, we'll transition to `LoggedIn` even if we\n        can't validate them with the backend. A validation failure will be reflected\n        in the `relogin` field.\n\n  - Anonymous\n\n    We don't have credentials. The `LoginProgress` parameter indicates whatever\n    progress we might be making towards having credentials.\n\n    We could parameterize this to add some data that only anonymous users use.\n    However, it's probably the case that any such data would also be relevant\n    for logged-in users, so it's probably not necessary -- it can be handled\n    at a higher level.\n\n  - LoggedIn\n\n    We've got credentials. In addition to the credentials themsevles, we track\n    what we know about the validity of the credentials, and any app-specific\n    data that only applies where we have credentials (i.e. that should be\n    thrown away upon logout).\n\n",
        "args": [
          "user",
          "data"
        ],
        "cases": [
          [
            "Anonymous",
            [
              "Restful.Login.LoginProgress"
            ]
          ],
          [
            "CheckingCachedCredentials",
            []
          ],
          [
            "LoggedIn",
            [
              "Restful.Login.Login user data"
            ]
          ]
        ]
      },
      {
        "name": "Msg",
        "comment": " An opaque type representing messages we handle. You can create\nthese messages with various functions (e.g. `tryLogin`, `logout`) and handle\nthem with the `update` function.\n",
        "args": [
          "user"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "accessTokenAccepted",
        "comment": " If you previously recorded `accessTokenRejected` but it was a transient\nproblem, and now it has been accepted, you can record that with this function.\n\nYou don't need to call this every time the access token is accepted (though\nit won't do any harm, either).\n\nNote that this doesn't switch our state from `Anonymous` to `LoggedIn` ...\nit only resets `LoggedIn` (if that's what we are) to show that `relogin`\nis not required.\n\n",
        "type": "Restful.Login.LoginStatus user data -> Restful.Login.LoginStatus user data"
      },
      {
        "name": "accessTokenRejected",
        "comment": " Record the fact that our access token was rejected.\n\nIf we're in a `LoggedIn` state, we'll stay in that state ... we'll\nmerely record that re-login is required.\n\n",
        "type": "Http.Error -> Restful.Login.LoginStatus user data -> Restful.Login.LoginStatus user data"
      },
      {
        "name": "checkCachedCredentials",
        "comment": " Initializes a LoginStatus by indicating that we're checking the cache for\ncredentials, and return a `Cmd` that will do that.\n\n  - BackendUrl is the backend to check the cached credentials against.\n\n  - Value is the JSON string which your `cacheCredentials` function (from Config)\n    has cached. So, it's up to you to fetch that value somehow, either via\n    flags at startup, or via ports. If you've cached credentials for multiple backends,\n    it's up to you to match your backendURL and your credentials.\n\nThe LoginStatus will start as `CheckingCachedCredentials`. At this point, your UI\nshould treat the login process as unresolved ... it will soon resolve one way\nor another. So, you might show a \"checking for cached login\" message, or just\nnothing.\n\n  - If we can decode the credentials, we'll try to use the access token against\n    the backend to get updated user information. Whether or not that succeeds,\n    we'll be in `LoggedIn` state ... the result of checking the credentials will\n    affect whether `relogin` is required.\n\n  - If we can't decode the credentials, we'll be in `Anonymous LoginRequired`\n    state.\n\n",
        "type": "Restful.Login.Config user data msg -> Restful.Endpoint.BackendUrl -> String -> ( Restful.Login.LoginStatus user data, Platform.Cmd.Cmd msg )"
      },
      {
        "name": "drupalConfig",
        "comment": " Make a `Config` that uses default values oriented towards Drupal's\nrestful implementation.\n",
        "type": "Restful.Login.AppConfig user data msg -> Restful.Login.Config user data msg"
      },
      {
        "name": "getError",
        "comment": " Do we have an error to report?\n",
        "type": "Restful.Login.LoginStatus user data -> Maybe.Maybe Restful.Login.LoginError"
      },
      {
        "name": "hasAccessToken",
        "comment": " Do we have an access token, whether or not we think it's valid?\n\nIf we're still checking, we say `False`.\n\n",
        "type": "Restful.Login.LoginStatus user data -> Bool"
      },
      {
        "name": "hasValidAccessToken",
        "comment": " As far as we know, do we have a still-valid access token?\n\nIf we don't know yet, we indicate `False`.\n\n",
        "type": "Restful.Login.LoginStatus user data -> Bool"
      },
      {
        "name": "isProgressing",
        "comment": " Is there currently something in progress to advance the\nlogin process, or are we at rest?\n",
        "type": "Restful.Login.LoginStatus user data -> Bool"
      },
      {
        "name": "loggedOut",
        "comment": " A constant which represents the state in which the user is logged out, and\nno progress is currently being made towards login.\n\nThis is one possible \"starting point\" for initializing the LoginStatus. The other\nmain starting point would be `checkCachedCredentials`.\n\nNote that you should use `logout` to actually perform the action of logging\nout, since that will also clear the cached credentials.\n\n",
        "type": "Restful.Login.LoginStatus user data"
      },
      {
        "name": "logout",
        "comment": " Message which will log out and clear cached credentials.\n",
        "type": "Restful.Login.Msg user"
      },
      {
        "name": "mapData",
        "comment": " Map over the data, if the user is logged in.\n",
        "type": "(data -> data) -> Restful.Login.LoginStatus user data -> Restful.Login.LoginStatus user data"
      },
      {
        "name": "maybeData",
        "comment": " Extract the data as a Maybe, which will be `Just` if the user is logged in.\n",
        "type": "Restful.Login.LoginStatus user data -> Maybe.Maybe data"
      },
      {
        "name": "tryLogin",
        "comment": " Message which will try logging in against the specified backendUrl\n",
        "type": "Restful.Endpoint.BackendUrl -> String -> String -> Restful.Login.Msg user"
      },
      {
        "name": "update",
        "comment": " Our update function. Note that the `Cmd` we return is in terms of\nyour own msg type. So, you can integrate it into your app roughly\nas follows:\n\n    ...\n\nThe third return parameter will be `True` at the very moment at which\na successful login has been made. But only at that very moment ... it's\nnot reflecting state, but instead a kind of notification that we've\njust logged in.\n\n",
        "type": "Restful.Login.Config user data msg -> Restful.Login.Msg user -> Restful.Login.LoginStatus user data -> ( Restful.Login.LoginStatus user data , Platform.Cmd.Cmd msg , Bool )"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Restful.Endpoint",
    "comment": " These functions and types are intended to facilitate CRUD operations upon\nbackend entities exposed through a Restful HTTP API.\n\n\n## Backends\n\n@docs Backend, backend, drupalBackend\n@docs withItems, withDrupalItems, withPlainItems\n@docs withCountDecoder, withDrupalCountDecoder\n@docs withOffsetParam, withRangeParam\n@docs withManyKeys\n@docs withTokenStrategy\n\n\n## Endpoints\n\n@docs ReadOnly, ReadWrite\n@docs EndPoint, ReadOnlyEndPoint, ReadWriteEndPoint\n@docs drupalEndpoint, endpoint\n@docs withBackend, withKeyEncoder, withValueEncoder, withCreatedEncoder, withParamsEncoder, withErrorDecoder, withPath\n\n\n## Access Tokens\n\n@docs AccessToken, TokenStrategy, tokenHeader, tokenUrlParam\n\n\n## CRUD Operations\n\n@docs BackendUrl, Offset, Range, QueryResult\n@docs get, getMany, select, selectRange, patch, patchAny, patchFull, post, put, delete\n@docs CrudOperations, applyBackendUrl, applyAccessToken\n\n\n# Requests\n\n@docs CrudRequest, withAccessToken, withoutDecoder, modifyRequest\n@docs toTask, toTaskMaybe, toCmd, toCmdMaybe\n\n\n## EntityId\n\n@docs EntityId, decodeEntityId, encodeEntityId, fromEntityId, toEntityId\n\n\n## EntityUuid\n\n@docs EntityUuid, decodeEntityUuid, encodeEntityUuid, fromEntityUuid, toEntityUuid\n\n\n## Helpers\n\n@docs (</>), decodeSingleDrupalEntity\n\n",
    "aliases": [
      {
        "name": "AccessToken",
        "comment": " An access token.\n",
        "args": [],
        "type": "String"
      },
      {
        "name": "BackendUrl",
        "comment": " The base URL for a backend (i.e. the part that doesn't vary from\none endpoint to another).\n",
        "args": [],
        "type": "String"
      },
      {
        "name": "CrudOperations",
        "comment": " A record with alll the functions for CRUD requests, with the `BackendUrl`\npartially applied (and, optionally, the `AccessToken`).\n\nSo, at the top of an `update` function, you might do something like:\n\n    let\n        ops =\n            applyBackendUrl backendUrl\n                |> applyAccessToken accessToken\n\nThen, in the rest of the `update` function, you can say thtings like:\n\n    ops.select ...\n\n... without having to supply the `backendUrl` over and over, and without having\nto say `withAccessToken accessToken` each time.\n\nOr, your `update` function might just ask for a `CrudOperations` as a parameter,\nrather than asking for a `BackendUrl` or `AccessToken` at all.\n\n",
        "args": [
          "w",
          "e",
          "k",
          "v",
          "c",
          "p"
        ],
        "type": "{ delete : Restful.Endpoint.EndPoint w e k v c p -> k -> Restful.Endpoint.CrudRequest e () , get : Restful.Endpoint.EndPoint w e k v c p -> k -> Restful.Endpoint.CrudRequest e v , getMany : Restful.Endpoint.EndPoint w e k v c p -> List k -> Restful.Endpoint.CrudRequest e (List ( k, v )) , patch : Restful.Endpoint.ReadWriteEndPoint e k v c p -> k -> v -> (v -> Json.Encode.Value) -> Restful.Endpoint.CrudRequest e v , patchAny : Restful.Endpoint.ReadWriteEndPoint e k v c p -> k -> Json.Encode.Value -> Restful.Endpoint.CrudRequest e v , patchFull : Restful.Endpoint.ReadWriteEndPoint e k v c p -> k -> v -> Restful.Endpoint.CrudRequest e v , post : Restful.Endpoint.ReadWriteEndPoint e k v c p -> c -> Restful.Endpoint.CrudRequest e ( k, v ) , put : Restful.Endpoint.ReadWriteEndPoint e k v c p -> k -> v -> Restful.Endpoint.CrudRequest e v , select : Restful.Endpoint.EndPoint w e k v c p -> p -> Restful.Endpoint.CrudRequest e (Restful.Endpoint.QueryResult k v p) , selectRange : Restful.Endpoint.EndPoint w e k v c p -> p -> Restful.Endpoint.Offset -> Maybe.Maybe Restful.Endpoint.Range -> Restful.Endpoint.CrudRequest e (Restful.Endpoint.QueryResult k v p) }"
      },
      {
        "name": "Offset",
        "comment": " A zero-based offset that you would like the backend to start from.\n",
        "args": [],
        "type": "Int"
      },
      {
        "name": "QueryResult",
        "comment": " When we're querying the backend, our result consists of a list of items,\nthe count of how many items there are on the backend, and the offset on the\nbackend that our list starts at. We also remember what params we supplied,\nsince that will affect the meaning of the total and the offset.\n",
        "args": [
          "key",
          "value",
          "params"
        ],
        "type": "{ params : params , offset : Int , items : List ( key, value ) , count : Int }"
      },
      {
        "name": "Range",
        "comment": " How many items would you like the backend to return?\n",
        "args": [],
        "type": "Int"
      },
      {
        "name": "ReadOnlyEndPoint",
        "comment": " A type alias which represents a read-only `EndPoint`.\n",
        "args": [
          "error",
          "key",
          "value",
          "params"
        ],
        "type": "Restful.Endpoint.EndPoint Restful.Endpoint.ReadOnly error key value value params"
      },
      {
        "name": "ReadWriteEndPoint",
        "comment": " A type alias which represents a read-write `EndPoint`.\n",
        "args": [
          "error",
          "key",
          "value",
          "created",
          "params"
        ],
        "type": "Restful.Endpoint.EndPoint Restful.Endpoint.ReadWrite error key value created params"
      }
    ],
    "types": [
      {
        "name": "Backend",
        "comment": " Common configuration for endpoints connected to a particular backend.\n\nYou might wonder why the `BackendUrl` could not be specified as part of the\n`Backend`, rather than asking for it with each CRUD request. The reason is\nthat, in our setups, the `BackendUrl` is typically provided a run-time,\nwhereas the rest of the information needed to construct the `Backend` (or an\n`EndPoint`) is known at compile-time. So, it's convenient to construct the\n`Backend` and `EndPoint` values statically, without requiring parameters.\n\nYou can pre-apply a `BackendUrl` (or `AccessToken`), once known, using\n`applyBackendUrl` and `applyAccessToken`.\n\n",
        "args": [
          "a"
        ],
        "cases": []
      },
      {
        "name": "CrudRequest",
        "comment": " A type representing a CRUD request. The `err` type is the kind of result you'll\nget back for errors. The `ok` type is the kind of result you'll get back if the\nrequest succeeds.\n\n  - You can construct requests with `select`, `get`, etc.\n\n  - You can use requests via `toTask` or `toCmd`.\n\n",
        "args": [
          "err",
          "ok"
        ],
        "cases": []
      },
      {
        "name": "EndPoint",
        "comment": " The `EndPoint` type represents a Restful JSON endpoint, with at least\na path for URLs, and a decoder for the JSON it emits.\n\nThe structure is somewhat specialized for a headless Drupal backend using its\nRestful module. However, it should be adaptable for use in other REST\nenvironments (let us know if any changes are needed to handle your case).\n\nThe type parameters have the following significance.\n\n| Type | Significance |\n| ---- | ------------ |\n| `writeable` | A type which flags whether this endpoint is read-only or read-write. |\n| `error` | Your error type. <p>If you don't want to do something special with errors, then it can just be `Http.Error` |\n| `key` | Your ID type. We usually use some kind of `EntityId`, but you can use something else if you like. |\n| `value` | Your value type. |\n| `created` | The type you would use in POST requests, when creating a new value. May be missing some information from `value` which the backend will supply. May be the same as `value` if POST isn't special. |\n| `params` | A type for the query params that this endpoint uses. <p>If your endpoint doesn't take params, just use `()` (or, a phantom type variable, if you like). |\n\nIn function signatures, we sometimes abbreviate these type parameters to something like\n`EndPoint w e p k v c` ... at least, for the type parameters that aren't relevant to\nthat particular function. Also, we use the type aliases `ReadOnlyEndPoint` and `ReadWriteEndPoint`\nto simplify some function signatures.\n\nTo create an `EndPoint`, start with `drupalEndpoint` (or `endpoint`), and then use the various\n`with...` functions to customize it as needed.\n\nTo use your endpoint, see functions like `get`, `put`, `post`, `delete`, etc.\n\n",
        "args": [
          "writeable",
          "error",
          "key",
          "value",
          "created",
          "params"
        ],
        "cases": []
      },
      {
        "name": "EntityId",
        "comment": " This is a wrapper for an `Int` id. It takes a \"phantom\" type variable\nin order to gain type-safety about what kind of entity it is an ID for.\nSo, to specify that you have an id for a clinic, you would say:\n\n    type ClinicId\n        = ClinicId\n\n    clinidId : EntityId ClinicId\n\n",
        "args": [
          "a"
        ],
        "cases": []
      },
      {
        "name": "EntityUuid",
        "comment": " This is a wrapper for an UUID.\n",
        "args": [
          "a"
        ],
        "cases": []
      },
      {
        "name": "ReadOnly",
        "comment": " A type which flags an `EndPoint` as being read-only.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ReadWrite",
        "comment": " A type which flags an `EndPoint` as being read-only.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "TokenStrategy",
        "comment": " We can use two strategies to send an `AccessToken` to the backend -- either an\nHTTP header (with a key and value), or a param for the URL (with key and value).\nUse `tokenHeader` or `tokenUrlParam` to construct.\n",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "</>",
        "comment": " Appends the second parameter to the first, joining them with a \"/\", but avoiding \"//\".\n\n    \"http://www.apple.com\"  </> \"path\"  --> \"http://www.apple.com/path\"\n\n    \"http://www.apple.com\"  </> \"/path\" --> \"http://www.apple.com/path\"\n\n    \"http://www.apple.com/\" </> \"path\"  --> \"http://www.apple.com/path\"\n\n    \"http://www.apple.com/\" </> \"/path\" --> \"http://www.apple.com/path\"\n\n",
        "type": "String -> String -> String"
      },
      {
        "name": "applyAccessToken",
        "comment": " Applies the given `AccessToken` to each of the functions, so you don't need\nto do it every time.\n",
        "type": "Restful.Endpoint.AccessToken -> Restful.Endpoint.CrudOperations w e k v c p -> Restful.Endpoint.CrudOperations w e k v c p"
      },
      {
        "name": "applyBackendUrl",
        "comment": " Returns a `CrudOperations` record that has the `BackendUrl` applied to each function.\n",
        "type": "Restful.Endpoint.BackendUrl -> Restful.Endpoint.CrudOperations w e k v c p"
      },
      {
        "name": "backend",
        "comment": " Constructs a default `Backend`.\n\nThis is a starting point for further configuration -- it won't\nwork for your backend out of the box.\n\nFor use with Drupal's Restful module, you can use `drupalBackend` (or simply\nuse `drupalEndpoint`).\n\n",
        "type": "Restful.Endpoint.Backend a"
      },
      {
        "name": "decodeEntityId",
        "comment": " Decodes a EntityId.\n\nThis just turns JSON int (or string that is an int) to an `EntityId`. You need\nto supply the `field \"id\"` yourself, if necessary, since id's could be present\nin other fields as well.\n\nThis decodes any kind of `EntityId` you like (since there is fundamentally no type\ninformation in the JSON iself, of course). So, you need to verify that the type\nis correct yourself.\n\n",
        "type": "Json.Decode.Decoder (Restful.Endpoint.EntityId a)"
      },
      {
        "name": "decodeEntityUuid",
        "comment": " Decodes an `EntityUuid`.\n",
        "type": "Json.Decode.Decoder (Restful.Endpoint.EntityUuid a)"
      },
      {
        "name": "decodeSingleDrupalEntity",
        "comment": " Given a decoder for an item, applies that decoder to the kind of\nresponse Drupal sends for a single item (as the only element in a JSON\narray in a \"data\" field).\n",
        "type": "Json.Decode.Decoder a -> Json.Decode.Decoder a"
      },
      {
        "name": "delete",
        "comment": " Delete entity.\n\nIf you want to treat a 404 result as a success, use `toTaskMaybe` or `toCmdMaybe`\non the resulting `CrudRequest`.\n\n",
        "type": "Restful.Endpoint.BackendUrl -> Restful.Endpoint.EndPoint w error key v c p -> key -> Restful.Endpoint.CrudRequest error ()"
      },
      {
        "name": "drupalBackend",
        "comment": " A `Backend` which decodes the kind of responses a Drupal backend sends\nwhen using the Restful module.\n",
        "type": "Restful.Endpoint.Backend a"
      },
      {
        "name": "drupalEndpoint",
        "comment": " Construct a Drupal-oriented endpoint, with as many defaults filled in as possible.\n\n  - The first parameter is the `path` to the endpoint (which will be appended to the\n    `BackendUrl` you provide for requests).\n\n  - The second parameter is a decoder for your `value` type.\n\nYes, just two parameters! We'll supplement that with various Drupal-oriented defaults:\n\n  - The `key` is some kind of `EntityId`, and it can be found in an `id` field\n    in the JSON.\n\n  - Multiple values are returned as a JSON array inside a `data` field.\n    But you can change that using `withBackend`.\n\n  - Single values are returned as a single-elmeent JSON array, inside a `data` field.\n    But you can change that using `withBackend`.\n\n  - Your endpoint doesn't use any URL params.\n    But you can change that using `withParamsEncoder`.\n\n  - You're not using a custom error type.\n    But you can change that using `withErrorDecoder`.\n\nIf you need a different `key` type, you can start with `endpoint` instead, and supply\n`drupalBackend` to it as a parameter to get the rest of the defaults.\n\nThis initially produces a `ReadOnlyEndPoint`. To obtain a `ReadWriteEndpoint`,\napply `withValueEncoder` to the result.\n\n",
        "type": "String -> Json.Decode.Decoder value -> Restful.Endpoint.ReadOnlyEndPoint Http.Error (Restful.Endpoint.EntityId a) value p"
      },
      {
        "name": "encodeEntityId",
        "comment": " Encodes any kind of `EntityId` as a JSON int.\n",
        "type": "Restful.Endpoint.EntityId a -> Json.Encode.Value"
      },
      {
        "name": "encodeEntityUuid",
        "comment": " Encodes any kind of `EntityUuid` as a JSON string.\n",
        "type": "Restful.Endpoint.EntityUuid a -> Json.Encode.Value"
      },
      {
        "name": "endpoint",
        "comment": " Produces an `EndPoint` which you may then customize further.\n\n  - The first parameter is the `path` to the endpoint (which will be appended\n    to the `BackendUrl` you provide for requests).\n\n  - The second parameter is a decoder for your `key` type.\n\n  - The third parameter is a decoder for your `value` type.\n\n  - The fourth parameter is your backend.\n\nTo turn this into a `ReadWriteEndpoint`, apply `withValueEncoder` to the result.\n\n",
        "type": "String -> Json.Decode.Decoder key -> Json.Decode.Decoder value -> Restful.Endpoint.Backend ( key, value ) -> Restful.Endpoint.ReadOnlyEndPoint Http.Error key value p"
      },
      {
        "name": "fromEntityId",
        "comment": " This is how you get an `Int` back from a `EntityId`. You should only use\nthis in boundary situations, where you need to send the id out in an untyped\nway. Normally, you should just pass around the `EntityId` itself, to retain\ntype-safety.\n",
        "type": "Restful.Endpoint.EntityId a -> Int"
      },
      {
        "name": "fromEntityUuid",
        "comment": " This is how you get a `String` back from an `EntityUuid`. You should only use\nthis in boundary situations, where you need to send the UUID out in an untyped\nway. Normally, you should just pass around the `EntityUuid` itself, to retain\ntype-safety.\n",
        "type": "Restful.Endpoint.EntityUuid a -> String"
      },
      {
        "name": "get",
        "comment": " Gets a entity from the backend via its `key`.\n\nSometimes you'd like to treat a 404 error specially, since the request\nessentially succeeded ... it's just that there was no result. To do that, you\ncan use `toTaskMaybe` or `toCmdMaybe` with the resulting `CrudRequest`.\n\n",
        "type": "Restful.Endpoint.BackendUrl -> Restful.Endpoint.EndPoint w error key value c p -> key -> Restful.Endpoint.CrudRequest error value"
      },
      {
        "name": "getMany",
        "comment": " Gets several entities from the backend via multiple `key`s.\n",
        "type": "Restful.Endpoint.BackendUrl -> Restful.Endpoint.EndPoint w error key value c p -> List key -> Restful.Endpoint.CrudRequest error (List ( key, value ))"
      },
      {
        "name": "modifyRequest",
        "comment": " Despite all the fine work and careful thought which has gone into this\npackage, perhaps there is some modification you'd like to make to the HTTP\nrequest before you send it. Under the hood, we're using the very fine\n`RequestBuilder` from\n[`lukewestby/elm-http-builder`](http://package.elm-lang.org/packages/lukewestby/elm-http-builder/5.1.0)\nto construct the HTTP requests. So, once you're got a `CrudRequest`, you\ncan use `modifyRequest` to alter the request. But consider filing a bug\nreport if it's something we could handle in the package itself!\n",
        "type": "(HttpBuilder.RequestBuilder a -> HttpBuilder.RequestBuilder b) -> Restful.Endpoint.CrudRequest e a -> Restful.Endpoint.CrudRequest e b"
      },
      {
        "name": "patch",
        "comment": " Sends a `PATCH` request for the specified key and value, using the encoder\nyou supply.\n\n  - If you want to send a `PATCH` with your usual encoder, then you can use\n    `patchFull` insteed. (The result will be just like `put`, but it will use\n    a PATCH request instead of PUT).\n\n  - If you want to send an arbitrary JSON `Value` that doesn't depend on your\n    `value`, then you can use `patchAny`.\n\nIf you want to ignore the JSON the server sends back for the value, you\ncan apply `withoutDecoder` to the result.\n\n",
        "type": "Restful.Endpoint.BackendUrl -> Restful.Endpoint.ReadWriteEndPoint error key value c p -> key -> value -> (value -> Json.Encode.Value) -> Restful.Endpoint.CrudRequest error value"
      },
      {
        "name": "patchAny",
        "comment": " Sends a `PATCH` request for the specified key, using an arbitrary JSON `Value`\nthat you supply.\n\n  - If you have one of your `value` entities, and an encoder, you can use\n    `patch` instead.\n\n  - If you want to send a `PATCH` with your usual encoder, then you can use\n    `patchFull` insteed. (The result will be just like `put`, but it will use\n    a PATCH request instead of PUT).\n\nIf you want to ignore the JSON the server sends back for the value, you\ncan apply `withoutDecoder` to the result.\n\n",
        "type": "Restful.Endpoint.BackendUrl -> Restful.Endpoint.ReadWriteEndPoint error key value c p -> key -> Json.Encode.Value -> Restful.Endpoint.CrudRequest error value"
      },
      {
        "name": "patchFull",
        "comment": " Sends a `PATCH` request for the specified key and value, using the encoder\ndefined for this endpoint. So, this is just like a `put`, except it uses an\nHTTP PATCH request.\n\n  - If you want to send a `PATCH` with just some fields, you can use `patch`\n    instead, and provide an alternate encoder for your `value`.\n\n  - If you want to send an arbitrary JSON `Value` that doesn't depend on your\n    `value`, then you can use `patchAny`.\n\nIf you want to ignore the JSON the server sends back for the value, you\ncan apply `withoutDecoder` to the result.\n\n",
        "type": "Restful.Endpoint.BackendUrl -> Restful.Endpoint.ReadWriteEndPoint error key value c p -> key -> value -> Restful.Endpoint.CrudRequest error value"
      },
      {
        "name": "post",
        "comment": " Sends a `POST` request to create the specified value.\n",
        "type": "Restful.Endpoint.BackendUrl -> Restful.Endpoint.ReadWriteEndPoint error key value created p -> created -> Restful.Endpoint.CrudRequest error ( key, value )"
      },
      {
        "name": "put",
        "comment": " Sends a `PUT` request to create the specified value.\n\nIf you want to ignore the JSON the server sends back for the value, you\ncan apply `withoutDecoder` to the result.\n\nIf you want to send the full value, but use the `PATCH` HTTP method, see\n`patchFull`.\n\n",
        "type": "Restful.Endpoint.BackendUrl -> Restful.Endpoint.ReadWriteEndPoint error key value c p -> key -> value -> Restful.Endpoint.CrudRequest error value"
      },
      {
        "name": "select",
        "comment": " Select entities from an endpoint.\n",
        "type": "Restful.Endpoint.BackendUrl -> Restful.Endpoint.EndPoint w error key value c params -> params -> Restful.Endpoint.CrudRequest error (Restful.Endpoint.QueryResult key value params)"
      },
      {
        "name": "selectRange",
        "comment": " Like `select`, but you specify an offset and the number of items you want to fetch at once.\n\nIf you don't supply the range, we'll start at the offset, but not specify any particular number\nof items to fetch.\n\n",
        "type": "Restful.Endpoint.BackendUrl -> Restful.Endpoint.EndPoint w error key value c params -> params -> Restful.Endpoint.Offset -> Maybe.Maybe Restful.Endpoint.Range -> Restful.Endpoint.CrudRequest error (Restful.Endpoint.QueryResult key value params)"
      },
      {
        "name": "toCmd",
        "comment": " Convert a `CrudRequest` into a `Cmd`. You provide a tagger which indicates\nwhich `Msg` should handle the result.\n\nIf you'd prefer to get a `Task`, you can use `toTask` instead.\n\n",
        "type": "(Result.Result err ok -> msg) -> Restful.Endpoint.CrudRequest err ok -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "toCmdMaybe",
        "comment": " Like `toCmd`, but treats a 404 error specially. Instead of handling it as\nan error, it is treating as a successful result, returning `Nothing`. So, the\nsuccess type is now wrapped in a `Maybe`. Other errors are still treated as an\nerror.\n",
        "type": "(Result.Result err (Maybe.Maybe ok) -> msg) -> Restful.Endpoint.CrudRequest err ok -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "toEntityId",
        "comment": " This is how you create an `EntityId`, if you have an `Int`. You can create\nany kind of `EntityId` this way ... so you would normally only do this in\nsituations that are fundamentally untyped, such as when you are decoding\nJSON data. Except in those kind of \"boundary\" situations, you should be\nworking with the typed `EntityIds`.\n",
        "type": "Int -> Restful.Endpoint.EntityId a"
      },
      {
        "name": "toEntityUuid",
        "comment": " This is how you create a `EntityUuid`, if you have a `String`. You can create\nany kind of `EntityUuid` this way ... so you would normally only do this in\nsituations that are fundamentally untyped, such as when you are decoding\nJSON data. Except in those kind of \"boundary\" situations, you should be\nworking with the typed `EntityUuid`s.\n",
        "type": "String -> Restful.Endpoint.EntityUuid a"
      },
      {
        "name": "toTask",
        "comment": " Convert a `CrudRequest` into a `Task`.\n\nIf you'd prefer to go directly to a `Cmd`, see `toCmd`.\n\n",
        "type": "Restful.Endpoint.CrudRequest err ok -> Task.Task err ok"
      },
      {
        "name": "toTaskMaybe",
        "comment": " Like `toTask`, but treats a 404 error specially. Instead of handling it as\nan error, it is treating as a successful result, returning `Nothing`. So, the\nsuccess type is now wrapped in a `Maybe`. Other errors are still treated as an\nerror.\n",
        "type": "Restful.Endpoint.CrudRequest err ok -> Task.Task err (Maybe.Maybe ok)"
      },
      {
        "name": "tokenHeader",
        "comment": " Send an `AccessToken` to the backend using the specified HTTP header.\n",
        "type": "String -> Restful.Endpoint.TokenStrategy"
      },
      {
        "name": "tokenUrlParam",
        "comment": " Send an `AccessToken` to the backend using the specified parameter in the URL.\n",
        "type": "String -> Restful.Endpoint.TokenStrategy"
      },
      {
        "name": "withAccessToken",
        "comment": " Supply an `AccessToken` to be used with the request.\n",
        "type": "Restful.Endpoint.AccessToken -> Restful.Endpoint.CrudRequest err ok -> Restful.Endpoint.CrudRequest err ok"
      },
      {
        "name": "withBackend",
        "comment": " Use the supplied backend with the endpoint.\n",
        "type": "Restful.Endpoint.Backend ( k, v ) -> Restful.Endpoint.EndPoint w e k v c p -> Restful.Endpoint.EndPoint w e k v c p"
      },
      {
        "name": "withCountDecoder",
        "comment": " Given the JSON your backend returns for queries, how can we decode the\ntotal count of all the items on the backend? (They may not all necessarily have\nbeen returned, due to paging).\n",
        "type": "Json.Decode.Decoder Int -> Restful.Endpoint.Backend a -> Restful.Endpoint.Backend a"
      },
      {
        "name": "withCreatedEncoder",
        "comment": " Use the supplied function to encode new `created` values for the endpoint,\nfor use in POST requests.\n\nThis is for cases where some values are supplied by the backend after the\nentity is created. So, they are part of your `value` type, but you can't send\nthem as part of a POST request.\n\nIf you don't use a special `created` type, then we'll POST with your `value`\nencoder.\n\n",
        "type": "(created -> Json.Encode.Value) -> Restful.Endpoint.ReadWriteEndPoint e k v c p -> Restful.Endpoint.ReadWriteEndPoint e k v created p"
      },
      {
        "name": "withDrupalCountDecoder",
        "comment": " Decode the item count the Drupal way, by looking at a field named `count`.\n",
        "type": "Restful.Endpoint.Backend a -> Restful.Endpoint.Backend a"
      },
      {
        "name": "withDrupalItems",
        "comment": " Unwrap items the Drupal way, as sent by its Restful module.\n\n  - Single items are sent as the first element of a JSON array, inside a\n    field called \"data\".\n\n  - Multiple items are sent as a JSON array, inside a field called \"data\".\n\nSo, this is equivalent to something like:\n\n    withItems\n        (field \"data\" << index 0)\n        (field \"data\" << list)\n\n",
        "type": "Restful.Endpoint.Backend a -> Restful.Endpoint.Backend b"
      },
      {
        "name": "withErrorDecoder",
        "comment": " Use the supplied function to convert an `Http.Error` to your desired\n`error` type.\n\nBy default, we use `identity` (that is, by default, our error type is\n`Http.Error`). However, you may have a way to turn that into a more\nhelpful type.\n\n",
        "type": "(Http.Error -> error) -> Restful.Endpoint.EndPoint w e k v c p -> Restful.Endpoint.EndPoint w error k v c p"
      },
      {
        "name": "withItems",
        "comment": " Specify how to unwrap items sent by the backend, before applying the\ndecoders for the `key` and `value`.\n\n  - The first parameter is used for functions like `get`, which return only one\n    value. So, the question is: given what the backend sends, what do we need to\n    decode to get an item to which we can apply the `key` or `value` decoders?\n\n    If the decoders actually operate on exactly what the backend returns, you\n    could supply `identity`.\n\n  - The second parameter is used for functions like `select`, which return a\n    list of values. So, the question is: given what the backend sends, what do\n    we need to decode to get a list of items to which we can apply the `key` or\n    `value` decoders?\n\n    If the backend actually returns just a JSON array of the things the decoders\n    can handle, you could just supply `Json.Decode.list`.\n\nFor a pre-built version that handles how Drupal sends responses with its\nRestful module, see `withDrupalItems`.\n\n",
        "type": "(Json.Decode.Decoder a -> Json.Decode.Decoder a) -> (Json.Decode.Decoder a -> Json.Decode.Decoder (List a)) -> Restful.Endpoint.Backend b -> Restful.Endpoint.Backend a"
      },
      {
        "name": "withKeyEncoder",
        "comment": " Use the supplied function to convert your `key` type to a string we can append\nto the URL for a `get` request. By default, we just use `toString`, but you may need\nto something else, depending on your `key` type.\n",
        "type": "(key -> String) -> Restful.Endpoint.EndPoint w e key v c p -> Restful.Endpoint.EndPoint w e key v c p"
      },
      {
        "name": "withManyKeys",
        "comment": " When doing a GET via `getMany`, for multiple keys, how do we combine the\nkeys for the URL?\n\nBy default, an `endpoint` combines keys using `String.join \",\"` ... that is, by\nputting a comma between each key.\n\n",
        "type": "(List String -> String) -> Restful.Endpoint.Backend a -> Restful.Endpoint.Backend a"
      },
      {
        "name": "withOffsetParam",
        "comment": " What is the name of the query parameter this backend uses to specify an\noffset for queries?\n\nBy default, we use \"offset\".\n\n",
        "type": "String -> Restful.Endpoint.Backend a -> Restful.Endpoint.Backend a"
      },
      {
        "name": "withParamsEncoder",
        "comment": " Use the supplied function to convert your `params` type into something we can feed to\n`HttpBuilder.withQueryParams`. So, you get type-safety for the params!\n\nThis is how you would implement sorting or filtering, by:\n\n  - making up a type which describes the query\n  - telling us how to convert that to parameters for the URL\n\n`endpoint` and `drupalEndpoint` both default this to `always []` (i.e. no params)\n\n",
        "type": "(params -> List ( String, String )) -> Restful.Endpoint.EndPoint w e k v c p -> Restful.Endpoint.EndPoint w e k v c params"
      },
      {
        "name": "withPath",
        "comment": " Use the supplied `path` for this endpoint.\n\nThe path is appenend to whatever you supply for the `BackendUrl` for a request.\n\n",
        "type": "String -> Restful.Endpoint.EndPoint w e k v c p -> Restful.Endpoint.EndPoint w e k v c p"
      },
      {
        "name": "withPlainItems",
        "comment": " Unwrap items in the simplest possible way:\n\n  - Single items are sent in a way that your decoders can handle directly.\n\n  - Multiple items are sent as a JSON array of things your decoders can\n    handle directly.\n\nSo, this is equivalent to:\n\n    withItems identity Json.Decode.list\n\n",
        "type": "Restful.Endpoint.Backend a -> Restful.Endpoint.Backend b"
      },
      {
        "name": "withRangeParam",
        "comment": " What is the name of the query parameter this backend uses to specify how\nmany items you want at once?\n\nBy default, we use \"range\".\n\n",
        "type": "String -> Restful.Endpoint.Backend a -> Restful.Endpoint.Backend a"
      },
      {
        "name": "withTokenStrategy",
        "comment": " Use the supplied token strategy for this backend.\n\nYou can use `tokenHeader` or `tokenUrlParam` to construct a `TokenStrategy`.\n\n",
        "type": "Restful.Endpoint.TokenStrategy -> Restful.Endpoint.Backend a -> Restful.Endpoint.Backend a"
      },
      {
        "name": "withValueEncoder",
        "comment": " Use the supplied function to encode your `value` type when writing to the backend.\n\nIf you need a special `created` type for `POST` requests, apply `withCreatedEncoder`\nafter this function. Otherwise, we'll use this function for both `PUT` and `POST`.\n\n",
        "type": "(value -> Json.Encode.Value) -> Restful.Endpoint.ReadOnlyEndPoint e k value p -> Restful.Endpoint.ReadWriteEndPoint e k value value p"
      },
      {
        "name": "withoutDecoder",
        "comment": " Sometimes we want to send a request, but we're not interested in the\nresponse, just whether there was an error. In that case, you can use\n`withoutDecoder` to omit parsing the response.\n",
        "type": "Restful.Endpoint.CrudRequest e a -> Restful.Endpoint.CrudRequest e ()"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  }
]