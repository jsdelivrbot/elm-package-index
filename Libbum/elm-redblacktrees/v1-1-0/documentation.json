[{"name":"RedBlackTrees","comment":" Red Black Trees are self-balancing binary seach trees which add one bit of\nmemory to the standard BST (usually denoted by the colours red and black). With\nthis additional tracking information; the worst case search, insert and delete\ntime complexity drops to O(log N) [from O(N) in the BST case].\n\n\n# Types\n\n@docs RedBlackTree, Colour\n\n\n# Building\n\n@docs empty, singleton, fromList, insert\n\n\n# Utilities\n\n@docs isMember, size, blackHeight, height, flatten\n\n\n# Validation\n\n@docs isValid\n\n","unions":[{"name":"Colour","comment":" Since this is a red black tree representation, we ignore the green brown convention.\n","args":[],"cases":[["Red",[]],["Black",[]]]},{"name":"RedBlackTree","comment":" Trees can be comprised of either empty leaves or nodes containing a value,\na represesentative colour and two child branches.\n","args":["comparable"],"cases":[]}],"aliases":[],"values":[{"name":"blackHeight","comment":" Every path from the root to the leaves of a red black tree must contain\nthe same number of black nodes. The `blackHeight` is the value of this path length.\nNotably, this is also the shortest path from root to leaf.\n\n    fromList [ 2, 7, 4, 9, 1, 3, 18, 10 ] |> blackHeight == Just 2\n\nCalling `blackHeight` on a valid red black tree will return a count, but if\nthe tree is not correctly balanced, this function will return `Nothing`.\n\n","type":"RedBlackTrees.RedBlackTree comparable -> Maybe.Maybe Basics.Int"},{"name":"empty","comment":" An empty tree for ease of use when constructing trees.\n\n    empty == Empty\n\n","type":"RedBlackTrees.RedBlackTree comparable"},{"name":"flatten","comment":" Generate a list of values contained in the tree. Since\nRed Black trees are an extention of Binary Search Trees, the\nresultant list will be sorted. Colour is ignored in this operation.\n\n    tree = fromList [ 8, 1, 2, 6, 29, 42, 7, 22, 18, 36 ] == Node 7 Black (Node 2 Black (Node 1 Black Empty Empty) (Node 6 Black Empty Empty)) (Node 29 Black (Node 18 Red (Node 8 Black Empty Empty) (Node 22 Black Empty Empty)) (Node 42 Black (Node 36 Red Empty Empty) Empty))\n\n    flatten tree == [ 1, 2, 6, 7, 8, 18, 22, 29, 36, 42 ]\n\n","type":"RedBlackTrees.RedBlackTree comparable -> List.List comparable"},{"name":"fromList","comment":" Generate a Red Black representation of a list.\n\n    fromList [ 2, 7, 8, 3, 9, 1, 5, 10 ] == Node 7 Black (Node 3 Red (Node 2 Black (Node 1 Red Empty Empty) Empty) (Node 5 Black Empty Empty)) (Node 9 Red (Node 8 Black Empty Empty) (Node 10 Black Empty Empty))\n\n","type":"List.List comparable -> RedBlackTrees.RedBlackTree comparable"},{"name":"height","comment":" Calculate the height of the tree.\n\n    fromList [ 8, 24, 17, 32, 9, 1, 12, 7 ] |> height == 4\n\nThe longest path from the root to a leaf is at most twice the length of\nthe shortest path.\n\n    height tree <= 2 * (Maybe.withDefault 0 <| blackHeight tree) == True\n\n","type":"RedBlackTrees.RedBlackTree comparable -> Basics.Int"},{"name":"insert","comment":" Adds a new value to the tree. Since this may cause on of the four\nred black constraints to be broken, there may be a need to recolour nodes\nor rebalance the tree.\n\n    singleton 8 |> insert 1 == Node 8 Black (Node 1 Red Empty Empty) Empty\n\n","type":"comparable -> RedBlackTrees.RedBlackTree comparable -> RedBlackTrees.RedBlackTree comparable"},{"name":"isMember","comment":" Check if a value currently exists within in a tree.\n\n    fromList [ 1, 2, 3 ] |> isMember 72 == False\n\n","type":"comparable -> RedBlackTrees.RedBlackTree comparable -> Basics.Bool"},{"name":"isValid","comment":" Verifies that a given tree is a valid red black tree by checking\n\n1.  It satisfies the binary search order property\n2.  The root node is coloured `Black`\n3.  No red node has a child node that is also red\n4.  Every path from the root to a leaf contains the same number of black nodes\n\n```\nfromList [ 1, 2, 3, 4 ] |> isValid == True\n```\n\n","type":"RedBlackTrees.RedBlackTree comparable -> Basics.Bool"},{"name":"singleton","comment":" A tree with a single value inserted into it. Since this\nis a single node tree, it's colour is black by definition.\n\n    singleton 5 == Node 5 Black Empty Empty\n\n","type":"comparable -> RedBlackTrees.RedBlackTree comparable"},{"name":"size","comment":" Count the number of elements in the tree.\n\n    fromList [ 3, 8, 16 ] |> size == 3\n\n","type":"RedBlackTrees.RedBlackTree comparable -> Basics.Int"}],"binops":[]}]