[{"name":"Partition","comment":" The partition problem is a mathematically [NP-complete](https://en.wikipedia.org/wiki/NP-completeness) task\nwhich splits a set of numbers _S_ into two subsets, where the sum of these subsets is equal.\n\n\n# Methods\n\n@docs bruteForce\n\n\n# Utilities\n\n@docs allPartitions, objective\n\n","unions":[],"aliases":[],"values":[{"name":"allPartitions","comment":" Generates all possible partitions of a given set of numbers.\n\n    allPartitions [ 3, 15 ] == [ ( [ 3, 15 ], [] ), ( [ 3 ], [ 15 ] ), ( [ 15 ], [ 3 ] ), ( [], [ 3, 15 ] ) ]\n\n    Note that this function scales as `O(2ᴺ)`, where `N` is the length of your list.\n\n","type":"List.List number -> List.List ( List.List number, List.List number )"},{"name":"bruteForce","comment":" Directly partition your set by checking all possible permutations.\nThis method is best used on small sets where the solution must be accurate.\n\n    bruteForce [ 1, 1, 1, 1, 1, 1, 6 ] == ( [ 1, 1, 1, 1, 1, 1 ], [ 6 ] )\n\nA greedy method would distribute some ones into the second subset in the above example,\nbut `bruteForce` will obtain the optimal solution.\n\nSince all possible partitons must be calculated, this is an `O(2ᴺ)` operation.\n\n    bruteForce (List.range 0 22)\n\nEmits a heap limit allocation failure and sets with smaller lengths take some time to compute.\nSo alternate methods are best once your sets get large.\n\n","type":"List.List number -> ( List.List number, List.List number )"},{"name":"objective","comment":" The objective for our partitioning is to minimise the difference between the sum of each subset.\nMathematically stated: `min |&sum;S₁-&sum;S₂| : S₁,S₂&sub;S`.\n\n    objective ( [ 22, 5, 15, 3 ], [ 9, 12, 7, 11, 5, 2 ] ) == 1\n\n    objective ( [ 7, 3, 2 ], [ 22, 5, 15, 9, 12, 11, 5 ] ) == 67\n\nThese examples are partitions from the same set. The first is a far better solution than the second.\n\n","type":"( List.List number, List.List number ) -> number"}],"binops":[]}]