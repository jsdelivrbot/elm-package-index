[{"name":"Mark","comment":"\n\n@docs parse, parseWith\n\n@docs Options, Styling, default, defaultStyling, defaultBlocks\n\n@docs Cursor, ListIcon\n\n","unions":[{"name":"ListIcon","comment":" ","args":[],"cases":[["Bullet",[]],["Number",[]],["Arrow",[]]]}],"aliases":[{"name":"Cursor","comment":" A Cursor which represents a position in a nested list.\n\n`Level`\n\n","args":[],"type":"( Basics.Int, List.List Basics.Int )"},{"name":"Options","comment":" ","args":["model","styling","msg"],"type":"Internal.Model.Options model styling msg"},{"name":"Styling","comment":" Styling options for the default blocks.\n\nIf you add custom `blocks` or `inlines`, you'll probably want to define a new `Styling` type.\n\n","args":["msg"],"type":"{ link : List.List (Element.Attribute msg), token : List.List (Element.Attribute msg), list : List.List (Element.Attribute msg), listIcons : Mark.Cursor -> Mark.ListIcon -> Element.Element msg, title : List.List (Element.Attribute msg), header : List.List (Element.Attribute msg), monospace : List.List (Element.Attribute msg), root : List.List (Element.Attribute msg), block : List.List (Element.Attribute msg) }"}],"values":[{"name":"default","comment":" A default set of block and inline elements as well as some `defaultStyling` to style them.\n","type":"Mark.Options model (Mark.Styling msg) msg"},{"name":"defaultBlocks","comment":" A set of common default blocks.\n\n  - `title` - The title of your document. This is equivalent to an `h1`. You should only have one of them.\n  - `header` - A header in your document, which is equivalent to `h2`.\n  - `list` - A nested list with an expected indentation of 4 spaces per level. As far as icons:\n      - `-` indicates a bullet\n      - `->` indicates an arrow\n      - `1.` indicates it should be numbered. Any number can work.\n  - `image` - Expects two strings, first the src, and then a description of the image.\n  - `monospace` - Basically a code block without syntax highlighting.\n\n**Note** none of these are special, they're all defined in terms of `Mark.Custom`.\n\n","type":"List.List (Internal.Model.Block model { a | title : List.List (Element.Attribute msg), header : List.List (Element.Attribute msg), link : List.List (Element.Attribute msg), list : List.List (Element.Attribute msg), root : List.List (Element.Attribute msg), monospace : List.List (Element.Attribute msg), block : List.List (Element.Attribute msg), listIcons : Mark.Cursor -> Mark.ListIcon -> Element.Element msg, token : List.List (Element.Attribute msg) } msg)"},{"name":"defaultStyling","comment":" ","type":"Mark.Styling msg"},{"name":"parse","comment":" ","type":"String.String -> Result.Result (List.List Parser.DeadEnd) (Element.Element msg)"},{"name":"parseWith","comment":" ","type":"Mark.Options model { a | link : List.List (Element.Attribute msg), token : List.List (Element.Attribute msg), list : List.List (Element.Attribute msg), root : List.List (Element.Attribute msg), block : List.List (Element.Attribute msg) } msg -> String.String -> Result.Result (List.List Parser.DeadEnd) (model -> Element.Element msg)"}],"binops":[]},{"name":"Mark.Custom","comment":"\n\n@docs Inline, inline\n\n\n## Block functions with arguments\n\n@docs Block, block, block1, block2, block3\n\n\n## Parameters\n\n@docs Param, bool, int, float, string, oneOf\n\n\n## Styled\n\n@docs paragraph, section, indented\n\n\n## Advanced\n\n@docs parser\n\n","unions":[{"name":"Param","comment":" A parameter to use with `block1` or `block2`.\n","args":["arg"],"cases":[]}],"aliases":[{"name":"Block","comment":" ","args":["model","style","msg"],"type":"Internal.Model.Block model style msg"},{"name":"Inline","comment":" ","args":["model","style","msg"],"type":"Internal.Model.Inline model style msg"}],"values":[{"name":"block","comment":" A simple block that will insert Elm html.\n\n    import Element\n    import Element.Font as Font\n    import Mark.Custom as Custom\n\n    myParser =\n        Mark.parseWith\n            { styling = Mark.defaultStyling\n            , inlines = []\n            , blocks =\n                [ Custom.block \"red\"\n                    (\\styling model ->\n                        Element.el\n                            [ Font.color (Element.rgb 1 0 0) ]\n                            (Element.text \"Some statically defined, red text!\")\n                    )\n                ]\n            }\n\nWhich can then be used in your markup like so:\n\n    | red\n\nThe element you defined will show up there.\n\n","type":"String.String -> (style -> model -> Element.Element msg) -> Mark.Custom.Block model style msg"},{"name":"block1","comment":" Same as `block`, but you can parse one parameter as well.\n\nFor example, here's how the builtin block, `image`, using `block2` and two `Custom.string` parameters.\n\n    Custom.block2 \"image\"\n        (\\src description styling ->\n            Element.image\n                []\n                { src = String.trim src\n                , description = String.trim description\n                }\n        )\n        Custom.string\n        Custom.string\n\nWhich can then be used in your markup:\n\n    | image \"http://placekitten/200/500\"\n        \"Here's a great picture of my cat, pookie.\"\"\n\nor as\n\n    | image\n        \"http://placekitten/200/500\"\n        \"Here's a great picture of my cat, pookie.\"\"\n\n","type":"String.String -> (arg -> style -> model -> Element.Element msg) -> Mark.Custom.Param arg -> Mark.Custom.Block model style msg"},{"name":"block2","comment":" ","type":"String.String -> (arg -> arg2 -> style -> model -> Element.Element msg) -> Mark.Custom.Param arg -> Mark.Custom.Param arg2 -> Mark.Custom.Block model style msg"},{"name":"block3","comment":" ","type":"String.String -> (arg -> arg2 -> arg3 -> style -> model -> Element.Element msg) -> Mark.Custom.Param arg -> Mark.Custom.Param arg2 -> Mark.Custom.Param arg3 -> Mark.Custom.Block model style msg"},{"name":"bool","comment":" ","type":"Mark.Custom.Param Basics.Bool"},{"name":"float","comment":" ","type":"Mark.Custom.Param Basics.Float"},{"name":"indented","comment":" Parse a 4-space-indented, unstyled block of text.\n\nIt ends after three consecutive newline characters.\n\n","type":"String.String -> (String.String -> style -> model -> Element.Element msg) -> Mark.Custom.Block model style msg"},{"name":"inline","comment":" Create a custom inline styler.\n\n    Custom.inline \"intro\"\n        (\\string styling ->\n            let\n                txt =\n                    String.trim string\n            in\n            if txt == \"\" then\n                []\n\n            else\n                [ Element.el [ Element.alignLeft, Font.size 48 ]\n                    (Element.text (String.toUpper (String.slice 0 1 txt)))\n                , Element.el [ Font.size 24 ]\n                    (Element.text (String.toUpper (String.dropLeft 1 txt)))\n                ]\n        )\n\nWhen applied via `parseWith`, can then be used in markup like the following\n\n    {drop| Lorem Ipsum is simply dummy text } of the printing and...\n\nIt will turn the first letter into a [dropped capital](https://en.wikipedia.org/wiki/Initial) and lead in with [small caps](https://practicaltypography.com/small-caps.html)\n\n**styling** is the `styling` record that is passed in the options of `parseWith`. This means you can make an inline element that can be paragraph via the options.\n\n","type":"String.String -> (String.String -> style -> model -> List.List (Element.Element msg)) -> Mark.Custom.Inline model style msg"},{"name":"int","comment":" ","type":"Mark.Custom.Param Basics.Int"},{"name":"oneOf","comment":" Define a list of options. Useful for working with custom types.\n","type":"List.List ( String.String, value ) -> Mark.Custom.Param value"},{"name":"paragraph","comment":" A block that expects a single paragraph of styled text as input. The `header` block that is built in uses this.\n\n    | header\n        My super sweet, /styled/ header.\n\n**Note** The actual paragraph text is required to be on the next line and indented four spaces.\n\n","type":"String.String -> (List.List (Element.Element msg) -> { a | link : List.List (Element.Attribute msg), token : List.List (Element.Attribute msg), root : List.List (Element.Attribute msg), block : List.List (Element.Attribute msg) } -> model -> Element.Element msg) -> Mark.Custom.Block model { a | link : List.List (Element.Attribute msg), token : List.List (Element.Attribute msg), root : List.List (Element.Attribute msg), block : List.List (Element.Attribute msg) } msg"},{"name":"parser","comment":" Run a parser created with [elm/parser](https://package.elm-lang.org/packages/elm/parser/latest/) where you can parse whatever you'd like. This is actually how the `list` block is implemented.\n\nI highly recommend using the other `Custom` parsers if possible as this is the only one that can \"break\" an elm-markup file.\n\nYou're in charge of defining when this parser will stop parsing.\n\nCurrent conventions:\n\n  - stop parsing after three consecutive newlines\n  - blocks should be indented 4 spaces\n\nThese conventions may be enforced in the future.\n\nHere's a terrible example.\n\n    Custom.parser \"bananaTree\"\n        (\\inlines ->\n            -- `inlines` is a parser for styled text which you may or maynot need,\n            Parser.succeed identity\n                |. Parser.token  \" \"\n                |= (Parser.map\n                        -- the result of our parser should be a function that\n                        -- takes a `styling` and a `model` and returns `Element msg`\n                        (\\_ styling model ->\n                                Element.el [] (Element.text \"bananas\"\n                        )\n                        (Parser.token \"bananas\")\n                    )\n                |. Parser.token \"\\n\"\n        )\n\nIt parses bananas and then says `bananas`. If you wanted to do exactly this in real life, you would probably use some form of `Custom.block`.\n\n","type":"String.String -> (Parser.Parser (style -> model -> List.List (Element.Element msg)) -> Parser.Parser (style -> model -> Element.Element msg)) -> Mark.Custom.Block model style msg"},{"name":"section","comment":" Like `Custom.paragraph`, but parses many styled paragraphs.\n\n**Note** Parsing ends when there are three consecutive newlines.\n\n","type":"String.String -> (List.List (Element.Element msg) -> { a | link : List.List (Element.Attribute msg), token : List.List (Element.Attribute msg), root : List.List (Element.Attribute msg), block : List.List (Element.Attribute msg) } -> model -> Element.Element msg) -> Mark.Custom.Block model { a | link : List.List (Element.Attribute msg), token : List.List (Element.Attribute msg), root : List.List (Element.Attribute msg), block : List.List (Element.Attribute msg) } msg"},{"name":"string","comment":" Parse a double quoted string.\n","type":"Mark.Custom.Param String.String"}],"binops":[]}]