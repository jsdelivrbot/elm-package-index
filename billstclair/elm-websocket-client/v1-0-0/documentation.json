[{"name":"WebSocketClient","comment":" Web sockets make it cheaper to talk to your servers.\n\nConnecting to a server takes some time, so with web sockets, you make that\nconnection once and then keep using. The major benefits of this are:\n\n1.  It faster to send messages. No need to do a bunch of work for every single\n    message.\n\n2.  The server can push messages to you. With normal HTTP you would have to\n    keep _asking_ for changes, but a web socket, the server can talk to you\n    whenever it wants. This means there is less unnecessary network traffic.\n\n\n# Web Sockets\n\n\n## Types\n\n@docs Config, State, Response, Error, ClosedCode\n\n\n## State\n\n@docs makeConfig, makeState\n@docs getKeyUrl, getConfig, setConfig\n\n\n## API\n\n@docs open, keepAlive, send, close, process\n@docs openWithKey, keepAliveWithKey\n\n\n## Simulator\n\n@docs makeSimulatorConfig\n\n\n## Printing errors\n\n@docs errorToString, closedCodeToString\n\n","unions":[{"name":"ClosedCode","comment":" <https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent>\n","args":[],"cases":[["NormalClosure",[]],["GoingAwayClosure",[]],["ProtocolErrorClosure",[]],["UnsupprtedDataClosure",[]],["NoStatusRecvdClosure",[]],["AbnormalClosure",[]],["InvalidFramePayloadDataClosure",[]],["PolicyViolationClosure",[]],["MessageTooBigClosure",[]],["MissingExtensionClosure",[]],["InternalErrorClosure",[]],["ServiceRestartClosure",[]],["TryAgainLaterClosure",[]],["BadGatewayClosure",[]],["TLSHandshakeClosure",[]],["UnknownClosure",[]]]},{"name":"Config","comment":" Packages up your ports to put inside a `State`.\n\nOpaque type, created by `makeConfig`.\n\n","args":["msg"],"cases":[]},{"name":"Error","comment":" All the errors that can be returned in a Response.ErrorResponse.\n\nIf an error tag has a single `String` arg, that string is a socket `key`.\n\n","args":[],"cases":[["UnimplementedError",["{ function : String.String }"]],["SocketAlreadyOpenError",["String.String"]],["SocketConnectingError",["String.String"]],["SocketClosingError",["String.String"]],["SocketNotOpenError",["String.String"]],["PortDecodeError",["{ error : String.String }"]],["UnexpectedConnectedError",["{ key : String.String, description : String.String }"]],["UnexpectedMessageError",["{ key : String.String, message : String.String }"]],["LowLevelError",["{ key : Maybe.Maybe String.String, code : String.String, description : String.String, name : Maybe.Maybe String.String }"]],["InvalidMessageError",["{ json : String.String }"]]]},{"name":"Response","comment":" A response that your code must process to update your model.\n\n`NoResponse` means there's nothing to do.\n\n`CmdResponse` is a `Cmd` that you must return from your `update` function. It will send something out the `sendPort` in your `Config`.\n\n`ConnectedReponse` tells you that an earlier call to `send` or `keepAlive` has successfully connected. You can usually ignore this.\n\n`MessageReceivedResponse` is a message from one of the connected sockets.\n\n`ClosedResponse` tells you that an earlier call to `close` has completed. Its `code`, `reason`, and `wasClean` fields are as passed by the JavaScript `WebSocket` interface. Its `expected` field will be `True`, if the response is to a `close` call on your part. It will be `False` if the close was unexpected. Unexpected closes will eventually be handled be trying to reconnect, but that isn't implemented yet.\n\n`ErrorResponse` means that something went wrong. This will eventually have more structure. It is the raw data from the port code now.\n\n","args":["msg"],"cases":[["NoResponse",[]],["CmdResponse",["Platform.Cmd.Cmd msg"]],["ConnectedResponse",["{ key : String.String, description : String.String }"]],["MessageReceivedResponse",["{ key : String.String, message : String.String }"]],["ClosedResponse",["{ key : String.String, code : WebSocketClient.ClosedCode, reason : String.String, wasClean : Basics.Bool, expected : Basics.Bool }"]],["ErrorResponse",["WebSocketClient.Error"]]]},{"name":"State","comment":" Internal state of the WebSocketClient module.\n\nCreate one with `makeState`, passed to most of the other functions.\n\n","args":["msg"],"cases":[]}],"aliases":[],"values":[{"name":"close","comment":" Close a WebSocket opened by `open` or `keepAlive`.\n\n    close state key\n\nThe `key` arg is either they `key` arg to `openWithKey` or\n`keepAliveWithKey` or the `url` arg to `open` or `keepAlive`.\n\n","type":"WebSocketClient.State msg -> String.String -> ( WebSocketClient.State msg, WebSocketClient.Response msg )"},{"name":"closedCodeToString","comment":" Turn a `ClosedCode` into a `String`, for debugging.\n","type":"WebSocketClient.ClosedCode -> String.String"},{"name":"errorToString","comment":" Convert an `Error` to a string, for simple reporting.\n","type":"WebSocketClient.Error -> String.String"},{"name":"getConfig","comment":" Get a State's Config\n","type":"WebSocketClient.State msg -> WebSocketClient.Config msg"},{"name":"getKeyUrl","comment":" Get the URL for a key.\n","type":"String.String -> WebSocketClient.State msg -> Maybe.Maybe String.String"},{"name":"keepAlive","comment":" Keep a connection alive, but do not report any messages. This is useful\nfor keeping a connection open for when you only need to `send` messages. So\nyou might say something like this:\n\n    let (state2, response) =\n        keepAlive state \"ws://echo.websocket.org\"\n    in\n        ...\n\n**Note:** If the connection goes down, the effect manager tries to reconnect\nwith an exponential backoff strategy. Any messages you try to `send` while the\nconnection is down are queued and will be sent as soon as possible.\n\n","type":"WebSocketClient.State msg -> String.String -> ( WebSocketClient.State msg, WebSocketClient.Response msg )"},{"name":"keepAliveWithKey","comment":" Like `keepAlive`, but allows matching a unique key to the connection.\n\n    keeAliveWithKey state key url\n\n","type":"WebSocketClient.State msg -> String.String -> String.String -> ( WebSocketClient.State msg, WebSocketClient.Response msg )"},{"name":"makeConfig","comment":" Make a real configuration, with your input and output ports.\n\nThe parameters are:\n\n    makeConfig sendPort\n\nWhere `sendPort` is your output (`Cmd`) port.\n\nYour input (`Sub`) port should wrap a `Json.Encode.Value` with a message,\nand when your `update` function gets that message, it should pass it to\n`process`, and then store the returned `State` in your model, and handle\nthe returned `Response`.\n\n","type":"(Json.Encode.Value -> Platform.Cmd.Cmd msg) -> WebSocketClient.Config msg"},{"name":"makeSimulatorConfig","comment":" Make a `Config` that enables running your code in `elm reactor`.\n\nThe arg is a server simulator, which translates a message sent with `send`\nto a response.\n\n","type":"(String.String -> Maybe.Maybe String.String) -> WebSocketClient.Config msg"},{"name":"makeState","comment":" Make state to store in your model.\n\nThe `Config` arg is the result of `makeConfig` or `makeSimulatorConfig`.\n\n","type":"WebSocketClient.Config msg -> WebSocketClient.State msg"},{"name":"open","comment":" Subscribe to any incoming messages on a websocket. You might say something\nlike this:\n\n    type Msg = Echo String | ...\n\n    subscriptions model =\n      open \"ws://echo.websocket.org\" Echo\n\n**Note:** If the connection goes down, the effect manager tries to reconnect\nwith an exponential backoff strategy. Any messages you try to `send` while the\nconnection is down are queued and will be sent as soon as possible.\n\n    open state url\n\n","type":"WebSocketClient.State msg -> String.String -> ( WebSocketClient.State msg, WebSocketClient.Response msg )"},{"name":"openWithKey","comment":" Like `open`, but allows matching a unique key to the connection.\n\n`open` uses the url as the key.\n\n    openWithKey state key url\n\n","type":"WebSocketClient.State msg -> String.String -> String.String -> ( WebSocketClient.State msg, WebSocketClient.Response msg )"},{"name":"process","comment":" Process a Value that comes in over the subscription port.\n","type":"WebSocketClient.State msg -> Json.Encode.Value -> ( WebSocketClient.State msg, WebSocketClient.Response msg )"},{"name":"send","comment":" Send a message to a particular address. You might say something like this:\n\n    send state \"ws://echo.websocket.org\" \"Hello!\"\n\nYou must call `open` or `openWithKey` before calling `send`.\n\n","type":"WebSocketClient.State msg -> String.String -> String.String -> ( WebSocketClient.State msg, WebSocketClient.Response msg )"},{"name":"setConfig","comment":" Get a State's Config\n","type":"WebSocketClient.Config msg -> WebSocketClient.State msg -> WebSocketClient.State msg"}],"binops":[]}]