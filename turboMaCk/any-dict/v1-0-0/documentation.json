[
  {
    "name": "Dict.Any",
    "comment": " A dictionary mapping unique keys to values.\nSimilar and based on Dict but without restriction on comparable keys.\n\nInsert, remove, and query operations all take O(log n) time.\n\n# Converting Types to Comparable\n\nWhen writing a function for conversion from the type you want to use for keys to comparable\nit's very important to make sure every distinct member of type k produces different value in set o of comparables.\n\nTake for instance those two examples:\n\nWe can use Bool as a key for our Dict (No matter how unpractical it might seem)\n\n    boolToInt : Bool -> Int\n    boolToInt bool =\n        case bool of\n            False -> 0\n            True -> 1\n\n    empty boolToInt\n    |> insert True \"foo\"\n    |> get True\n    --> Just \"foo\"\n\nor Maybe String.\n\n    comparableKey : Maybe String -> (Int, String)\n    comparableKey maybe =\n        case maybe of\n            Nothing -> (0, \"\")\n            Just str -> (1, str)\n\n    empty comparableKey\n        |> insert (Just \"foo\") 42\n        |> get (Just \"foo\")\n    --> Just 42\n\nNote that we give Int code to either constructor and in Case of Nothing we default to `\"\"` (empty string).\nThere is still a difference between `Nothing` and `Just \"\"` (`Int` value in the pair is different).\nIn fact, you can \"hardcode\" any value as the second member of the pair\nin case of nothing but empty string seems like a reasonable option for this case.\nGenerally, this is how I would implement `toComparable` function for most of your custom data types.\nHave a look at the longest constructor,\nDefine tuple where the first key is int (number of the constructor)\nand other are types within the constructor and you're good to go.\n\n# Dictionaries\n\n@docs AnyDict\n\n\n# Build\n\n@docs empty, singleton, insert, update, remove\n\n\n# Query\n\n@docs isEmpty, member, get, size\n\n\n# Lists\n\n@docs keys, values, toList, fromList\n\n\n# Transform\n\n@docs map, foldl, foldr, filter, partition\n\n\n# Combine\n\n@docs union, intersect, diff, merge\n\n\n# Dict\n\n@docs toDict\n\n",
    "aliases": [],
    "types": [
      {
        "name": "AnyDict",
        "comment": " ",
        "args": [
          "comparable",
          "k",
          "v"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "diff",
        "comment": " Keep a key-value pair when its key does not appear in the second dictionary.\n",
        "type": "Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v"
      },
      {
        "name": "empty",
        "comment": " Create an empty dictionary by suppling function used for comparing keys.\n\n** Note that it's important to make sure every key is turned to different comparable.\nOtherwise keys would conflict and overwritede each other.**\n\n",
        "type": "(k -> comparable) -> Dict.Any.AnyDict comparable k v"
      },
      {
        "name": "filter",
        "comment": " Keep a key-value pair when it satisfies a predicate.\n",
        "type": "(k -> v -> Bool) -> Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v"
      },
      {
        "name": "foldl",
        "comment": " Fold over the key-value pairs in a dictionary, in order from lowest key to highest key.\n",
        "type": "(k -> v -> b -> b) -> b -> Dict.Any.AnyDict comparable k v -> b"
      },
      {
        "name": "foldr",
        "comment": " Fold over the key-value pairs in a dictionary, in order from highest key to lowest key.\n",
        "type": "(k -> v -> b -> b) -> b -> Dict.Any.AnyDict comparable k v -> b"
      },
      {
        "name": "fromList",
        "comment": " Convert an association list into a dictionary.\n\n** Note that it's important to make sure every key is turned to different comparable.\nOtherwise keys would conflict and overwritede each other.**\n\n",
        "type": "(k -> comparable) -> List ( k, v ) -> Dict.Any.AnyDict comparable k v"
      },
      {
        "name": "get",
        "comment": " Get the value associated with a key.\nIf the key is not found, return Nothing.\nThis is useful when you are not sure\nif a key will be in the dictionary.\n\n    type Animal = Cat | Mouse | Dog\n\n    animalToInt : Animal -> Int\n    animalToInt animal =\n        case animal of\n            Cat -> 0\n            Mouse -> 1\n            Dog -> 2\n\n    animals : AnyDict Int Animal String\n    animals =\n        [ (Cat, \"Tom\"), (Mouse, \"Jerry\") ]\n            |> fromList animalToInt\n\n    get Cat animals\n    -> Just \"Tom\"\n\n    get Mouse animals\n    --> Just \"Jerry\"\n\n    get Dog animals\n    --> Nothing\n\n",
        "type": "k -> Dict.Any.AnyDict comparable k v -> Maybe.Maybe v"
      },
      {
        "name": "insert",
        "comment": " Insert a key-value pair into a dictionary. Replaces value when there is a collision.\n",
        "type": "k -> v -> Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v"
      },
      {
        "name": "intersect",
        "comment": " Keep a key-value pair when its key appears in the second dictionary.\nPreference is given to values in the first dictionary.\n",
        "type": "Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v"
      },
      {
        "name": "isEmpty",
        "comment": " Determine if a dictionary is empty.\n\n    isEmpty (empty identity)\n    --> True\n\n    singleton 1 \"foo\" identity\n        |> isEmpty\n    --> False\n\n",
        "type": "Dict.Any.AnyDict comparable k v -> Bool"
      },
      {
        "name": "keys",
        "comment": " Get all of the keys in a dictionary, sorted from lowest to highest.\n",
        "type": "Dict.Any.AnyDict comparable k v -> List k"
      },
      {
        "name": "map",
        "comment": " Apply a function to all values in a dictionary.\n",
        "type": "(a -> b -> c) -> Dict.Any.AnyDict comparable a b -> Dict.Any.AnyDict comparable a c"
      },
      {
        "name": "member",
        "comment": " Determine if a key is in a dictionary.\n",
        "type": "k -> Dict.Any.AnyDict comparable k v -> Bool"
      },
      {
        "name": "merge",
        "comment": " The most general way of combining two dictionaries.\nYou provide three accumulators for when a given key appears:\n\n1.  Only in the left dictionary.\n2.  In both dictionaries.\n3.  Only in the right dictionary.\n\nOnly in the left dictionary.\nIn both dictionaries.\nOnly in the right dictionary.\n\n",
        "type": "(k -> a -> result -> result) -> (k -> a -> b -> result -> result) -> (k -> b -> result -> result) -> Dict.Any.AnyDict comparable k a -> Dict.Any.AnyDict comparable k b -> result -> result"
      },
      {
        "name": "partition",
        "comment": " Partition a dictionary according to a predicate.\nThe first dictionary contains all key-value pairs which satisfy the predicate,\nand the second contains the rest.\n",
        "type": "(k -> v -> Bool) -> Dict.Any.AnyDict comparable k v -> ( Dict.Any.AnyDict comparable k v , Dict.Any.AnyDict comparable k v )"
      },
      {
        "name": "remove",
        "comment": " Remove a key-value pair from a dictionary.\nIf the key is not found, no changes are made.\n",
        "type": "k -> Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v"
      },
      {
        "name": "singleton",
        "comment": " Create a dictionary with one key-value pair.\n\n** Note that it's important to make sure every key is turned to different comparable.\nOtherwise keys would conflict and overwritede each other.**\n\n",
        "type": "k -> v -> (k -> comparable) -> Dict.Any.AnyDict comparable k v"
      },
      {
        "name": "size",
        "comment": " Determine the number of key-value pairs in the dictionary.\n",
        "type": "Dict.Any.AnyDict comparable k v -> Int"
      },
      {
        "name": "toDict",
        "comment": " Convert `AnyDict` to plain dictionary with comparable keys.\n",
        "type": "Dict.Any.AnyDict comparable k v -> Dict.Dict comparable v"
      },
      {
        "name": "toList",
        "comment": " Convert a dictionary into an association list of key-value pairs,\nsorted by keys.\n",
        "type": "Dict.Any.AnyDict comparable k v -> List ( k, v )"
      },
      {
        "name": "union",
        "comment": " Combine two dictionaries. If there is a collision, preference is given to the first dictionary.\n",
        "type": "Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v"
      },
      {
        "name": "update",
        "comment": " Update the value of a dictionary for a specific key with a given function.\n",
        "type": "k -> (Maybe.Maybe v -> Maybe.Maybe v) -> Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v"
      },
      {
        "name": "values",
        "comment": " Get all of the values in a dictionary, in the order of their keys.\n",
        "type": "Dict.Any.AnyDict comparable k v -> List v"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  }
]