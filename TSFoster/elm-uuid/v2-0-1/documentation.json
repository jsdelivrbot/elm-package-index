[{"name":"UUID","comment":" A UUID looks something like `e1631449-6321-4a58-920c-5440029b092e`, and can\nbe used as an identifier for anything. Each 128-bit number, usually represented\nas 32 hexadecimal digits, is generally assumed to be Universally Unique (hence\nthe name).\n\n@docs UUID\n\n\n## Creating UUIDs\n\nUUIDs have version numbers (1-5), which describe how they were created, and\nvariant numbers (1-2) which describes how they are stored. This module can read\nall UUIDs, but can only currently create versions 3 (a namespaced, heirarchical\nsystem) and 4 (a randomly-generated UUID). It creates variant 1 UUIDs (probably\nthe best choice if you don't have a specific need for variant 2), but can\nconvert them to variant 2.\n\n\n### Nil UUID\n\n@docs nil\n\n\n### Random UUIDs (Version 4)\n\nRandomly-generated UUIDs are called version 4 UUIDs. This package provides a\n`Random.Generator` for the [`elm/random`][elm-random] library.\n\n[elm-random]: https://package.elm-lang.org/packages/elm/random/latest/\n\n@docs generator\n\n\n### Hierarchical, namespaced UUIDs (Version 3, Version 5)\n\nUUIDs can be created using a namespace UUID and a name, which is then hashed to\ncreate a new UUID. The hash function used depends on the version of UUID:\nverison 3 UUIDs use MD5, and version 5 UUIDs use SHA-1. **Currently, this\npackage can only create version 3 UUIDs.**\n\nOnce generated, these UUIDs can then be used as a namespace, making a hierarchy!\nI think this is pretty cool! You can use this method for making predictable\nUUIDs from data, and it also has the added bonus that you don't have to deal\nwith random generators/seeds.\n\n@docs v3ChildNamed\n\nThe [RFC defining UUIDs][rfc] defines some [base UUIDs][appendix-c] to start\nyour hierarchy.\n\n[rfc]: https://tools.ietf.org/html/rfc4122\n[appendix-c]: https://tools.ietf.org/html/rfc4122#appendix-C\n\n@docs dns, url, oid, x500\n\n\n### Making variant 2 UUIDs\n\nYou may have noticed that `generator` and `v3ChildNamed` make variant 1\nUUIDs. If you need to create a variant 2 UUID, any UUID can be converted to a\nvariant 2 UUID with `toVariant2`. Note that variant 2 UUIDs cannot be converted\nto variant 1 UUIDs.\n\n@docs toVariant2\n\n\n### Existing UUIDs\n\n@docs fromString\n\n\n## Formatting\n\nUUIDs are generally represented by 32 hexadecimal digits in the form\n`00112233-4455-M677-N899-aabbccddeeff`, where the four bits at position `M`\ndenote the UUID version, and the first two or three bits at position `N` denote\nthe variant. This is the \"canonical\" representation, but there is also a\nMicrosoft GUID representation and a URN representation.\n\n@docs toString, canonical, microsoftGUID, urn\n\n\n## Inspecting UUIDs\n\nSometimes you may need to check a UUID's version, variant, or whether it's nil.\n\n@docs isNil, version, isVersion, variant, isVariant\n\nSometimes you may need to ensure that a UUID is definitely a certain version or\nvariant. If you're decoding from JSON, you may find the following functions\nuseful in conjunction with [json-extra's fromResult function][fromResult].\n\n[fromResult]: https://package.elm-lang.org/packages/elm-community/json-extra/latest/Json-Decode-Extra#fromResult\n\n    uuidDecoder =\n        Json.Decode.string\n            |> Json.Decode.andThen (Json.Decode.Extra.fromResult << UUID.fromString)\n            |> Json.Decode.andThen (Json.Decode.Extra.fromResult << UUID.checkVersion 4)\n            |> Json.Decode.andThen (Json.Decode.Extra.fromResult << UUID.checkVariant 1)\n\n@docs checkVersion, checkVariant, checkNotNil\n\n","unions":[{"name":"UUID","comment":" This modules provides a UUID type, and functions to work with them. It is an\n[opaque type], which basically means you have to use the provided functions if\nyou want to do anything with it!\n\n[opaque type]: https://medium.com/@ckoster22/advanced-types-in-elm-opaque-types-ec5ec3b84ed2\n\nHere is an example of a `Book` model, which uses UUIDs to identify both the book\nand its authors:\n\n    type alias Book =\n        { title : String\n        , uuid : UUID\n        , published : Maybe Date\n        , authors : List UUID\n        }\n\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"canonical","comment":" Convert UUID to [canonical textual representation](https://en.wikipedia.org/wiki/Universally_unique_identifier#Format)\n\n    canonical nil == \"00000000-0000-0000-0000-000000000000\"\n\n","type":"UUID.UUID -> String.String"},{"name":"checkNotNil","comment":" A simple function to use while chaining `Result`s. Makes sure the UUID\nyou're dealing with isn't the Nil UUID!\n\n    uuid =\n        someString\n            |> UUID.fromString\n            |> Result.andThen (UUID.checkNotNil 4)\n\n","type":"UUID.UUID -> Result.Result String.String UUID.UUID"},{"name":"checkVariant","comment":" Check which variant a UUID is, and if it's not the right one, return an `Err`.\n\n    (nil |> v3ChildNamed \"hello\" |> checkVariant 2) == Err \"UUID is not variant 2\"\n\n    (nil |> checkVariant 2) == Err \"UUID does not define a valid variant\"\n\n    (someVariant1UUID |> checkVariant 1) == Ok someVariant1UUID\n\n","type":"Basics.Int -> UUID.UUID -> Result.Result String.String UUID.UUID"},{"name":"checkVersion","comment":" Check which version a UUID is, and if it's not the right one, return an `Err`.\n\n    (nil |> v3ChildNamed \"hello\" |> checkVersion 4) == Err \"UUID is not Version 4\"\n\n    (nil |> checkVersion 1) == Err \"UUID does not define a valid version\"\n\n    (someVersion4UUID |> checkVersion 4) == Ok someVersion4UUID\n\n","type":"Basics.Int -> UUID.UUID -> Result.Result String.String UUID.UUID"},{"name":"dns","comment":" A UUID for the DNS namespace, \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\".\n\n    UUID.dns |> v3ChildNamed \"elm-lang.org\"\n\n","type":"UUID.UUID"},{"name":"fromString","comment":" You can attempt to create a UUID from a string. This function can interpret\na fairly broad range of formatted (and mis-formatted) UUIDs, including ones with\ntoo much whitespace, too many (or not enough) hyphens, or uppercase characters.\n\n    fromString \"c72c207b-0847-386d-bdbc-2e5def81cf811\" == Err \"UUID was not correct length\"\n\n    fromString \"c72c207b-0847-386d-bdbc-2e5def81cg81\" == Err \"UUID contained non-hexadecimal digits\"\n\n    fromString \"00000000-0000-0000-0000-000000000000\" == Ok nil\n\n    fromString \"urn:uuid:00000000-0000-0000-0000-000000000000\" == Ok nil\n\n    fromString \"{00000000-0000-0000-0000-000000000000}\" == Ok nil\n\n    fromString \"\\n\\n     {urn:uuid: 00  000000-0000-0000-0-000-000000000000}\" == Ok nil\n\n**Note:** if you are decoding from JSON, you may like [json-extra's fromResult function][fromResult].\n\n[fromResult]: https://package.elm-lang.org/packages/elm-community/json-extra/latest/Json-Decode-Extra#fromResult\n\n    uuidDecoder =\n        Json.Decode.string\n            |> Json.Decode.andThen (Json.Decode.Extra.fromResult << UUID.fromString)\n\n","type":"String.String -> Result.Result String.String UUID.UUID"},{"name":"generator","comment":" Generating a random UUID is, I think, the most straightforward way of making a UUID, and I see them used all the time. There are a couple of ways of using a generator to create a value, which are described nicely in the [elm/random docs][elm-random]. Here is an example of how you might use the UUID generator:\n\n[elm-random]: https://package.elm-lang.org/packages/elm/random/latest/\n\n    type Comment\n        = Comment String UUID\n\n    makeComment : String -> Random.Seed -> ( Comment, Random.Seed )\n    makeComment comment seed =\n        UUID.generator\n            |> Random.map (Comment comment)\n            |> Random.step seed\n\n","type":"Random.Generator UUID.UUID"},{"name":"isNil","comment":" `True` if the given UUID is \"00000000-0000-0000-0000-000000000000\".\n","type":"UUID.UUID -> Basics.Bool"},{"name":"isVariant","comment":" `True` if the given UUID is the given variant number. Always `False` is the\ninteger provided is not 1 or 2!\n\n    isVariant 4 someUUID -- Always False, variant 4 doesn't exist!\n\n    someJsonValue\n        |> Json.Decode.decodeValue UUID.decoder\n        |> UUID.isVariant 1\n\n    isVariant 2 (someUUID |> toVariant2) -- True\n\n","type":"Basics.Int -> UUID.UUID -> Basics.Bool"},{"name":"isVersion","comment":" `True` if the given UUID is the given version number. Always `False` is the\ninteger provided is not 1, 2, 3, 4 or 5!\n\n    isVersion 8 someUUID -- always False!\n\n    isVersion 4 nil -- False!\n\n    someJsonValue\n        |> Json.Decode.decodeValue UUID.decoder\n        |> UUID.isVersion 5\n\n    isVersion 3 (nil |> v3ChildNamed \"hello\") -- True\n\n","type":"Basics.Int -> UUID.UUID -> Basics.Bool"},{"name":"microsoftGUID","comment":" Convert UUID to [Microsoft GUID representation](https://en.wikipedia.org/wiki/Universally_unique_identifier#Format)\n\n    microsoftGUID nil == \"{00000000-0000-0000-0000-000000000000}\"\n\n","type":"UUID.UUID -> String.String"},{"name":"nil","comment":" One type of UUID not defined above is the nil UUID. This is a [\"special form\nof UUID\"][nil-rfc] defined as \"00000000-0000-0000-0000-000000000000\". I suppose\nit can be used as a placeholder for something that doesn't have a UUID yet?\n\n[nil-rfc]: https://tools.ietf.org/html/rfc4122#section-4.1.7\n\n","type":"UUID.UUID"},{"name":"oid","comment":" A UUID for the [ISO object ID (OID)][oid] namespace,\n\"6ba7b812-9dad-11d1-80b4-00c04fd430c8\". I am not going to try to explain what an\nOID is, if you need to use this, you probably have a better grasp of them than I\ndo!\n\n[oid]: https://en.wikipedia.org/wiki/Object_identifier\n\n    UUID.oid |> v3ChildNamed \"1.2.250.1\"\n\n","type":"UUID.UUID"},{"name":"toString","comment":" This is just an alias for `canonical`, the most common way to represent a UUID.\n\n    canonical someUUID == toString someUUID\n\n","type":"UUID.UUID -> String.String"},{"name":"toVariant2","comment":" Variant 2 UUIDs are very similar to variant 1 UUIDs, the main _end-user_\ndifference being that they provide 1 fewer bit of randomness, but are a\nMicrosoft standard. Note the single digit change in the following example:\n\n    -- c72c207b-0847-386d-bdbc-2e5def81cf81\n    var1UUID =\n        nil |> v3ChildNamed \"hello world\"\n\n\n    -- c72c207b-0847-386d-ddbc-2e5def81cf81\n    var2UUID =\n        var1UUID |> toVariant2\n\n","type":"UUID.UUID -> UUID.UUID"},{"name":"url","comment":" A UUID for the URL namespace, \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\"\n\n    UUID.url |> v3ChildNamed \"https://package.elm-lang.org\"\n\n","type":"UUID.UUID"},{"name":"urn","comment":" Convert UUID to [URN-namespaced representation](https://en.wikipedia.org/wiki/Universally_unique_identifier#Format)\n\n    urn nil == \"urn:uuid:00000000-0000-0000-0000-000000000000\"\n\n","type":"UUID.UUID -> String.String"},{"name":"v3ChildNamed","comment":" Start with an existing UUID as a \"parent\" UUID, and provide a name to create a new UUID.\n\n    grandparent = nil\n    parent = grandparent |> v3ChildNamed \"parent\"\n    parentsSibling = grandparent |> v3ChildNamed \"parent's sibling\"\n    child1 = parent |> v3ChildNamed \"child1\"\n    child2 = parent |> v3ChildNamed \"child2\"\n    cousin = parentsSibling |> v3ChildNamed \"cousin\"\n\n    UUID.canonical child2 == \"4cacaf93-fcc5-3a02-bc41-c0a3e359e11d\"\n\n","type":"String.String -> UUID.UUID -> UUID.UUID"},{"name":"variant","comment":" If the bits of the UUID indicate that it is a variant 1 or 2 UUID, returns\n`Just 1` or `Just 2`, respectively. Otherwise, `Nothing`!\n\n    variant nil == Nothing\n\n    variant (nil |> v3ChildNamed \"Hello\") == Just 1\n\n","type":"UUID.UUID -> Maybe.Maybe Basics.Int"},{"name":"version","comment":" If the bits of the UUID indicate that it is properly versioned UUID e.g. version 1,\nreturns e.g. `Just 1`. Otherwise, `Nothing`!\n\n    version nil == Nothing\n\n    version (nil |> v3ChildNamed \"Hello\") == Just 3\n\n","type":"UUID.UUID -> Maybe.Maybe Basics.Int"},{"name":"x500","comment":" A UUID for the [X.500 Distinguished Name (DN)][x500] namespace,\n\"6ba7b814-9dad-11d1-80b4-00c04fd430c8\". I am not going to try to explain what a\nX.500 DN is, if you need to use this, you probably have a better grasp of them\nthan I do!\n\n[x500]: https://en.wikipedia.org/wiki/X.500\n\n","type":"UUID.UUID"}],"binops":[]}]